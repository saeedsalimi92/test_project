var app = {
    isDebug: false,
    env: "prod",
    baseUrl: "",
    rootUrl: "http://localhost:3000",
    isMobile: false,
    isTablet: false,
    routes: [
        {
            "name": "home",
            "url": "/",
            "color": "dark"
        },
        // {
        //     "name": "partners",
        //     "url": "/partners",
        //     "color": "light"
        // },
        // {
        //     "name": "invest",
        //     "url": "/invest",
        //     "color": "dark"
        // },
        {
            "name": "about",
            "url": "/about",
            "color": "light"
        },
        // {
        //     "name": "team",
        //     "url": "/team",
        //     "color": "dark"
        // },
        {
            "name": "contact",
            "url": "/contact",
            "color": "light"
        },
        // {
        //     "name": "terms",
        //     "url": "/terms",
        //     "color": "dark"
        // },
        // {
        //     "name": "privacy",
        //     "url": "/privacy",
        //     "color": "dark"
        // },
        // {
        //     "name": "subscribe",
        //     "url": "/subscribe",
        //     "color": "dark"
        // },
        // {
        //     "name": null,
        //     "url": "/sitemap.xml",
        //     "color": "dark"
        // }
    ],
    analyticsId: "UA-130617040-1",
    direction: "ltr",
};

!function () {
    "use strict";

    var u = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function e(e, t) {
        return e(t = {exports: {}}, t.exports), t.exports
    }

    var Ve = e(function (e) {
        var t = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = t)
    }), m = e(function (e) {
        var t = e.exports = {version: "2.6.1"};
        "number" == typeof __e && (__e = t)
    }), Xe = (m.version, function (e) {
        return "object" == typeof e ? null !== e : "function" == typeof e
    }), S = function (e) {
        if (!Xe(e)) throw TypeError(e + " is not an object!");
        return e
    }, We = function (e) {
        try {
            return !!e()
        } catch (e) {
            return !0
        }
    }, Ye = !We(function () {
        return 7 != Object.defineProperty({}, "a", {
            get: function () {
                return 7
            }
        }).a
    }), t = Ve.document, i = Xe(t) && Xe(t.createElement), n = function (e) {
        return i ? t.createElement(e) : {}
    }, r = !Ye && !We(function () {
        return 7 != Object.defineProperty(n("div"), "a", {
            get: function () {
                return 7
            }
        }).a
    }), qe = function (e, t) {
        if (!Xe(e)) return e;
        var i, n;
        if (t && "function" == typeof (i = e.toString) && !Xe(n = i.call(e))) return n;
        if ("function" == typeof (i = e.valueOf) && !Xe(n = i.call(e))) return n;
        if (!t && "function" == typeof (i = e.toString) && !Xe(n = i.call(e))) return n;
        throw TypeError("Can't convert object to primitive value")
    }, a = Object.defineProperty, Qe = {
        f: Ye ? Object.defineProperty : function (e, t, i) {
            if (S(e), t = qe(t, !0), S(i), r) try {
                return a(e, t, i)
            } catch (e) {
            }
            if ("get" in i || "set" in i) throw TypeError("Accessors not supported!");
            return "value" in i && (e[t] = i.value), e
        }
    }, Ze = function (e, t) {
        return {enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t}
    }, Je = Ye ? function (e, t, i) {
        return Qe.f(e, t, Ze(1, i))
    } : function (e, t, i) {
        return e[t] = i, e
    }, o = {}.hasOwnProperty, Ke = function (e, t) {
        return o.call(e, t)
    }, s = 0, l = Math.random(), $e = function (e) {
        return "Symbol(".concat(void 0 === e ? "" : e, ")_", (++s + l).toString(36))
    }, w = e(function (e) {
        var a = $e("src"), t = "toString", i = Function[t], o = ("" + i).split(t);
        m.inspectSource = function (e) {
            return i.call(e)
        }, (e.exports = function (e, t, i, n) {
            var r = "function" == typeof i;
            r && (Ke(i, "name") || Je(i, "name", t)), e[t] !== i && (r && (Ke(i, a) || Je(i, a, e[t] ? "" + e[t] : o.join(String(t)))), e === Ve ? e[t] = i : n ? e[t] ? e[t] = i : Je(e, t, i) : (delete e[t], Je(e, t, i)))
        })(Function.prototype, t, function () {
            return "function" == typeof this && this[a] || i.call(this)
        })
    }), c = function (e) {
        if ("function" != typeof e) throw TypeError(e + " is not a function!");
        return e
    }, et = function (n, r, e) {
        if (c(n), void 0 === r) return n;
        switch (e) {
            case 1:
                return function (e) {
                    return n.call(r, e)
                };
            case 2:
                return function (e, t) {
                    return n.call(r, e, t)
                };
            case 3:
                return function (e, t, i) {
                    return n.call(r, e, t, i)
                }
        }
        return function () {
            return n.apply(r, arguments)
        }
    }, g = "prototype", v = function (e, t, i) {
        var n, r, a, o, s = e & v.F, l = e & v.G, h = e & v.S, c = e & v.P, u = e & v.B,
            p = l ? Ve : h ? Ve[t] || (Ve[t] = {}) : (Ve[t] || {})[g], d = l ? m : m[t] || (m[t] = {}),
            f = d[g] || (d[g] = {});
        for (n in l && (i = t), i) a = ((r = !s && p && void 0 !== p[n]) ? p : i)[n], o = u && r ? et(a, Ve) : c && "function" == typeof a ? et(Function.call, a) : a, p && w(p, n, a, e & v.U), d[n] != a && Je(d, n, o), c && f[n] != a && (f[n] = a)
    };
    Ve.core = m, v.F = 1, v.G = 2, v.S = 4, v.P = 8, v.B = 16, v.W = 32, v.U = 64, v.R = 128;
    var tt = v, p = function (e) {
        if (null == e) throw TypeError("Can't call method on  " + e);
        return e
    }, it = function (e) {
        return Object(p(e))
    }, h = Math.ceil, d = Math.floor, nt = function (e) {
        return isNaN(e = +e) ? 0 : (0 < e ? d : h)(e)
    }, f = Math.max, y = Math.min, rt = function (e, t) {
        return (e = nt(e)) < 0 ? f(e + t, 0) : y(e, t)
    }, _ = Math.min, at = function (e) {
        return 0 < e ? _(nt(e), 9007199254740991) : 0
    }, ot = [].copyWithin || function (e, t) {
        var i = it(this), n = at(i.length), r = rt(e, n), a = rt(t, n),
            o = 2 < arguments.length ? arguments[2] : void 0, s = Math.min((void 0 === o ? n : rt(o, n)) - a, n - r),
            l = 1;
        for (a < r && r < a + s && (l = -1, a += s - 1, r += s - 1); 0 < s--;) a in i ? i[r] = i[a] : delete i[r], r += l, a += l;
        return i
    }, x = e(function (e) {
        var t = "__core-js_shared__", i = Ve[t] || (Ve[t] = {});
        (e.exports = function (e, t) {
            return i[e] || (i[e] = void 0 !== t ? t : {})
        })("versions", []).push({version: m.version, mode: "global", copyright: "© 2018 Denis Pushkarev (zloirock.ru)"})
    }), st = e(function (e) {
        var t = x("wks"), i = Ve.Symbol, n = "function" == typeof i;
        (e.exports = function (e) {
            return t[e] || (t[e] = n && i[e] || (n ? i : $e)("Symbol." + e))
        }).store = t
    }), b = st("unscopables"), T = Array.prototype;
    null == T[b] && Je(T, b, {});
    var E = function (e) {
        T[b][e] = !0
    };
    tt(tt.P, "Array", {copyWithin: ot}), E("copyWithin");
    var A = {}.toString, M = function (e) {
        return A.call(e).slice(8, -1)
    }, P = Object("z").propertyIsEnumerable(0) ? Object : function (e) {
        return "String" == M(e) ? e.split("") : Object(e)
    }, L = Array.isArray || function (e) {
        return "Array" == M(e)
    }, C = st("species"), I = function (e, t) {
        return L(i = e) && ("function" != typeof (n = i.constructor) || n !== Array && !L(n.prototype) || (n = void 0), Xe(n) && null === (n = n[C]) && (n = void 0)), new (void 0 === n ? Array : n)(t);
        var i, n
    }, lt = function (u, e) {
        var p = 1 == u, d = 2 == u, f = 3 == u, m = 4 == u, g = 6 == u, v = 5 == u || g, y = e || I;
        return function (e, t, i) {
            for (var n, r, a = it(e), o = P(a), s = et(t, i, 3), l = at(o.length), h = 0, c = p ? y(e, l) : d ? y(e, 0) : void 0; h < l; h++) if ((v || h in o) && (r = s(n = o[h], h, a), u)) if (p) c[h] = r; else if (r) switch (u) {
                case 3:
                    return !0;
                case 5:
                    return n;
                case 6:
                    return h;
                case 2:
                    c.push(n)
            } else if (m) return !1;
            return g ? -1 : f || m ? m : c
        }
    }, R = function (e, t) {
        return !!e && We(function () {
            t ? e.call(null, function () {
            }, 1) : e.call(null)
        })
    }, O = lt(4);
    tt(tt.P + tt.F * !R([].every, !0), "Array", {
        every: function (e) {
            return O(this, e, arguments[1])
        }
    });
    var ht = function (e) {
        for (var t = it(this), i = at(t.length), n = arguments.length, r = rt(1 < n ? arguments[1] : void 0, i), a = 2 < n ? arguments[2] : void 0, o = void 0 === a ? i : rt(a, i); r < o;) t[r++] = e;
        return t
    };
    tt(tt.P, "Array", {fill: ht}), E("fill");
    var F = lt(2);
    tt(tt.P + tt.F * !R([].filter, !0), "Array", {
        filter: function (e) {
            return F(this, e, arguments[1])
        }
    });
    var N = lt(5), k = "find", U = !0;
    k in [] && Array(1)[k](function () {
        U = !1
    }), tt(tt.P + tt.F * U, "Array", {
        find: function (e) {
            return N(this, e, 1 < arguments.length ? arguments[1] : void 0)
        }
    }), E(k);
    var D = lt(6), z = "findIndex", B = !0;
    z in [] && Array(1)[z](function () {
        B = !1
    }), tt(tt.P + tt.F * B, "Array", {
        findIndex: function (e) {
            return D(this, e, 1 < arguments.length ? arguments[1] : void 0)
        }
    }), E(z);
    var H = lt(0), G = R([].forEach, !0);
    tt(tt.P + tt.F * !G, "Array", {
        forEach: function (e) {
            return H(this, e, arguments[1])
        }
    });
    var j = function (t, e, i, n) {
        try {
            return n ? e(S(i)[0], i[1]) : e(i)
        } catch (e) {
            var r = t.return;
            throw void 0 !== r && S(r.call(t)), e
        }
    }, ct = {}, V = st("iterator"), X = Array.prototype, ut = function (e) {
        return void 0 !== e && (ct.Array === e || X[V] === e)
    }, W = function (e, t, i) {
        t in e ? Qe.f(e, t, Ze(0, i)) : e[t] = i
    }, Y = st("toStringTag"), q = "Arguments" == M(function () {
        return arguments
    }()), pt = function (e) {
        var t, i, n;
        return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (i = function (e, t) {
            try {
                return e[t]
            } catch (e) {
            }
        }(t = Object(e), Y)) ? i : q ? M(t) : "Object" == (n = M(t)) && "function" == typeof t.callee ? "Arguments" : n
    }, Q = st("iterator"), dt = m.getIteratorMethod = function (e) {
        if (null != e) return e[Q] || e["@@iterator"] || ct[pt(e)]
    }, Z = st("iterator"), J = !1;
    try {
        [7][Z]().return = function () {
            J = !0
        }
    } catch (e) {
    }
    var ft = function (e, t) {
        if (!t && !J) return !1;
        var i = !1;
        try {
            var n = [7], r = n[Z]();
            r.next = function () {
                return {done: i = !0}
            }, n[Z] = function () {
                return r
            }, e(n)
        } catch (e) {
        }
        return i
    };
    tt(tt.S + tt.F * !ft(function (e) {
    }), "Array", {
        from: function (e) {
            var t, i, n, r, a = it(e), o = "function" == typeof this ? this : Array, s = arguments.length,
                l = 1 < s ? arguments[1] : void 0, h = void 0 !== l, c = 0, u = dt(a);
            if (h && (l = et(l, 2 < s ? arguments[2] : void 0, 2)), null == u || o == Array && ut(u)) for (i = new o(t = at(a.length)); c < t; c++) W(i, c, h ? l(a[c], c) : a[c]); else for (r = u.call(a), i = new o; !(n = r.next()).done; c++) W(i, c, h ? j(r, l, [n.value, c], !0) : n.value);
            return i.length = c, i
        }
    });
    var K = function (e) {
        return P(p(e))
    }, mt = function (s) {
        return function (e, t, i) {
            var n, r = K(e), a = at(r.length), o = rt(i, a);
            if (s && t != t) {
                for (; o < a;) if ((n = r[o++]) != n) return !0
            } else for (; o < a; o++) if ((s || o in r) && r[o] === t) return s || o || 0;
            return !s && -1
        }
    }, $ = mt(!0);
    tt(tt.P, "Array", {
        includes: function (e) {
            return $(this, e, 1 < arguments.length ? arguments[1] : void 0)
        }
    }), E("includes");
    var ee = mt(!1), te = [].indexOf, ie = !!te && 1 / [1].indexOf(1, -0) < 0;
    tt(tt.P + tt.F * (ie || !R(te)), "Array", {
        indexOf: function (e) {
            return ie ? te.apply(this, arguments) || 0 : ee(this, e, arguments[1])
        }
    }), tt(tt.S, "Array", {isArray: L});
    var ne = function (e, t) {
            return {value: t, done: !!e}
        }, re = x("keys"), ae = function (e) {
            return re[e] || (re[e] = $e(e))
        }, oe = mt(!1), se = ae("IE_PROTO"), le = function (e, t) {
            var i, n = K(e), r = 0, a = [];
            for (i in n) i != se && Ke(n, i) && a.push(i);
            for (; t.length > r;) Ke(n, i = t[r++]) && (~oe(a, i) || a.push(i));
            return a
        }, he = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(","),
        ce = Object.keys || function (e) {
            return le(e, he)
        }, ue = Ye ? Object.defineProperties : function (e, t) {
            S(e);
            for (var i, n = ce(t), r = n.length, a = 0; a < r;) Qe.f(e, i = n[a++], t[i]);
            return e
        }, pe = Ve.document, de = pe && pe.documentElement, fe = ae("IE_PROTO"), me = function () {
        }, ge = "prototype", ve = function () {
            var e, t = n("iframe"), i = he.length;
            for (t.style.display = "none", de.appendChild(t), t.src = "javascript:", (e = t.contentWindow.document).open(), e.write("<script>document.F=Object<\/script>"), e.close(), ve = e.F; i--;) delete ve[ge][he[i]];
            return ve()
        }, gt = Object.create || function (e, t) {
            var i;
            return null !== e ? (me[ge] = S(e), i = new me, me[ge] = null, i[fe] = e) : i = ve(), void 0 === t ? i : ue(i, t)
        }, ye = Qe.f, _e = st("toStringTag"), xe = function (e, t, i) {
            e && !Ke(e = i ? e : e.prototype, _e) && ye(e, _e, {configurable: !0, value: t})
        }, be = {};
    Je(be, st("iterator"), function () {
        return this
    });
    var we = ae("IE_PROTO"), Te = Object.prototype, vt = Object.getPrototypeOf || function (e) {
        return e = it(e), Ke(e, we) ? e[we] : "function" == typeof e.constructor && e instanceof e.constructor ? e.constructor.prototype : e instanceof Object ? Te : null
    }, Se = st("iterator"), Ee = !([].keys && "next" in [].keys()), Ae = "values", Me = function () {
        return this
    }, Pe = function (e, t, i, n, r, a, o) {
        var s, l, h;
        l = t, h = n, (s = i).prototype = gt(be, {next: Ze(1, h)}), xe(s, l + " Iterator");
        var c, u, p, d = function (e) {
                if (!Ee && e in v) return v[e];
                switch (e) {
                    case"keys":
                    case Ae:
                        return function () {
                            return new i(this, e)
                        }
                }
                return function () {
                    return new i(this, e)
                }
            }, f = t + " Iterator", m = r == Ae, g = !1, v = e.prototype, y = v[Se] || v["@@iterator"] || r && v[r],
            _ = y || d(r), x = r ? m ? d("entries") : _ : void 0, b = "Array" == t && v.entries || y;
        if (b && (p = vt(b.call(new e))) !== Object.prototype && p.next && (xe(p, f, !0), "function" != typeof p[Se] && Je(p, Se, Me)), m && y && y.name !== Ae && (g = !0, _ = function () {
            return y.call(this)
        }), (Ee || g || !v[Se]) && Je(v, Se, _), ct[t] = _, ct[f] = Me, r) if (c = {
            values: m ? _ : d(Ae), keys: a ? _ : d("keys"), entries: x
        }, o) for (u in c) u in v || w(v, u, c[u]); else tt(tt.P + tt.F * (Ee || g), t, c);
        return c
    }, yt = Pe(Array, "Array", function (e, t) {
        this._t = K(e), this._i = 0, this._k = t
    }, function () {
        var e = this._t, t = this._k, i = this._i++;
        return !e || i >= e.length ? (this._t = void 0, ne(1)) : ne(0, "keys" == t ? i : "values" == t ? e[i] : [i, e[i]])
    }, "values");
    ct.Arguments = ct.Array, E("keys"), E("values"), E("entries");
    var Le = [].lastIndexOf, Ce = !!Le && 1 / [1].lastIndexOf(1, -0) < 0;
    tt(tt.P + tt.F * (Ce || !R(Le)), "Array", {
        lastIndexOf: function (e) {
            if (Ce) return Le.apply(this, arguments) || 0;
            var t = K(this), i = at(t.length), n = i - 1;
            for (1 < arguments.length && (n = Math.min(n, nt(arguments[1]))), n < 0 && (n = i + n); 0 <= n; n--) if (n in t && t[n] === e) return n || 0;
            return -1
        }
    });
    var Ie = lt(1);
    tt(tt.P + tt.F * !R([].map, !0), "Array", {
        map: function (e) {
            return Ie(this, e, arguments[1])
        }
    }), tt(tt.S + tt.F * We(function () {
        function e() {
        }

        return !(Array.of.call(e) instanceof e)
    }), "Array", {
        of: function () {
            for (var e = 0, t = arguments.length, i = new ("function" == typeof this ? this : Array)(t); e < t;) W(i, e, arguments[e++]);
            return i.length = t, i
        }
    });
    var Re = function (e, t, i, n, r) {
        c(t);
        var a = it(e), o = P(a), s = at(a.length), l = r ? s - 1 : 0, h = r ? -1 : 1;
        if (i < 2) for (; ;) {
            if (l in o) {
                n = o[l], l += h;
                break
            }
            if (l += h, r ? l < 0 : s <= l) throw TypeError("Reduce of empty array with no initial value")
        }
        for (; r ? 0 <= l : l < s; l += h) l in o && (n = t(n, o[l], l, a));
        return n
    };
    tt(tt.P + tt.F * !R([].reduce, !0), "Array", {
        reduce: function (e) {
            return Re(this, e, arguments.length, arguments[1], !1)
        }
    }), tt(tt.P + tt.F * !R([].reduceRight, !0), "Array", {
        reduceRight: function (e) {
            return Re(this, e, arguments.length, arguments[1], !0)
        }
    });
    var Oe = lt(3);
    tt(tt.P + tt.F * !R([].some, !0), "Array", {
        some: function (e) {
            return Oe(this, e, arguments[1])
        }
    });
    var Fe = [].sort, Ne = [1, 2, 3];
    tt(tt.P + tt.F * (We(function () {
        Ne.sort(void 0)
    }) || !We(function () {
        Ne.sort(null)
    }) || !R(Fe)), "Array", {
        sort: function (e) {
            return void 0 === e ? Fe.call(it(this)) : Fe.call(it(this), c(e))
        }
    });
    var ke = st("species"), _t = function (e) {
        var t = Ve[e];
        Ye && t && !t[ke] && Qe.f(t, ke, {
            configurable: !0, get: function () {
                return this
            }
        })
    };
    _t("Array"), tt(tt.S, "Date", {
        now: function () {
            return (new Date).getTime()
        }
    });
    var Ue = Date.prototype.getTime, De = Date.prototype.toISOString, ze = function (e) {
        return 9 < e ? e : "0" + e
    }, Be = We(function () {
        return "0385-07-25T07:06:39.999Z" != De.call(new Date(-5e13 - 1))
    }) || !We(function () {
        De.call(new Date(NaN))
    }) ? function () {
        if (!isFinite(Ue.call(this))) throw RangeError("Invalid time value");
        var e = this, t = e.getUTCFullYear(), i = e.getUTCMilliseconds(), n = t < 0 ? "-" : 9999 < t ? "+" : "";
        return n + ("00000" + Math.abs(t)).slice(n ? -6 : -4) + "-" + ze(e.getUTCMonth() + 1) + "-" + ze(e.getUTCDate()) + "T" + ze(e.getUTCHours()) + ":" + ze(e.getUTCMinutes()) + ":" + ze(e.getUTCSeconds()) + "." + (99 < i ? i : "0" + ze(i)) + "Z"
    } : De;
    tt(tt.P + tt.F * (Date.prototype.toISOString !== Be), "Date", {toISOString: Be}), tt(tt.P + tt.F * We(function () {
        return null !== new Date(NaN).toJSON() || 1 !== Date.prototype.toJSON.call({
            toISOString: function () {
                return 1
            }
        })
    }), "Date", {
        toJSON: function (e) {
            var t = it(this), i = qe(t);
            return "number" != typeof i || isFinite(i) ? t.toISOString() : null
        }
    });
    var He = st("toPrimitive"), Ge = Date.prototype;
    He in Ge || Je(Ge, He, function (e) {
        if ("string" !== e && "number" !== e && "default" !== e) throw TypeError("Incorrect hint");
        return qe(S(this), "number" != e)
    });
    var je = Date.prototype, xt = "Invalid Date", bt = "toString", wt = je[bt], Tt = je.getTime;
    new Date(NaN) + "" != xt && w(je, bt, function () {
        var e = Tt.call(this);
        return e == e ? wt.call(this) : xt
    });
    var St = function (e, t, i) {
        var n = void 0 === i;
        switch (t.length) {
            case 0:
                return n ? e() : e.call(i);
            case 1:
                return n ? e(t[0]) : e.call(i, t[0]);
            case 2:
                return n ? e(t[0], t[1]) : e.call(i, t[0], t[1]);
            case 3:
                return n ? e(t[0], t[1], t[2]) : e.call(i, t[0], t[1], t[2]);
            case 4:
                return n ? e(t[0], t[1], t[2], t[3]) : e.call(i, t[0], t[1], t[2], t[3])
        }
        return e.apply(i, t)
    }, Et = [].slice, At = {}, Mt = Function.bind || function (t) {
        var i = c(this), n = Et.call(arguments, 1), r = function () {
            var e = n.concat(Et.call(arguments));
            return this instanceof r ? function (e, t, i) {
                if (!(t in At)) {
                    for (var n = [], r = 0; r < t; r++) n[r] = "a[" + r + "]";
                    At[t] = Function("F,a", "return new F(" + n.join(",") + ")")
                }
                return At[t](e, i)
            }(i, e.length, e) : St(i, e, t)
        };
        return Xe(i.prototype) && (r.prototype = i.prototype), r
    };
    tt(tt.P, "Function", {bind: Mt});
    var Pt = st("hasInstance"), Lt = Function.prototype;
    Pt in Lt || Qe.f(Lt, Pt, {
        value: function (e) {
            if ("function" != typeof this || !Xe(e)) return !1;
            if (!Xe(this.prototype)) return e instanceof this;
            for (; e = vt(e);) if (this.prototype === e) return !0;
            return !1
        }
    });
    var Ct = Qe.f, It = Function.prototype, Rt = /^\s*function ([^ (]*)/;
    "name" in It || Ye && Ct(It, "name", {
        configurable: !0, get: function () {
            try {
                return ("" + this).match(Rt)[1]
            } catch (e) {
                return ""
            }
        }
    });
    var Ot = function (e, t, i) {
        for (var n in t) w(e, n, t[n], i);
        return e
    }, Ft = function (e, t, i, n) {
        if (!(e instanceof t) || void 0 !== n && n in e) throw TypeError(i + ": incorrect invocation!");
        return e
    }, Nt = e(function (e) {
        var p = {}, d = {}, t = e.exports = function (e, t, i, n, r) {
            var a, o, s, l, h = r ? function () {
                return e
            } : dt(e), c = et(i, n, t ? 2 : 1), u = 0;
            if ("function" != typeof h) throw TypeError(e + " is not iterable!");
            if (ut(h)) {
                for (a = at(e.length); u < a; u++) if ((l = t ? c(S(o = e[u])[0], o[1]) : c(e[u])) === p || l === d) return l
            } else for (s = h.call(e); !(o = s.next()).done;) if ((l = j(s, c, o.value, t)) === p || l === d) return l
        };
        t.BREAK = p, t.RETURN = d
    }), kt = e(function (e) {
        var i = $e("meta"), t = Qe.f, n = 0, r = Object.isExtensible || function () {
            return !0
        }, a = !We(function () {
            return r(Object.preventExtensions({}))
        }), o = function (e) {
            t(e, i, {value: {i: "O" + ++n, w: {}}})
        }, s = e.exports = {
            KEY: i, NEED: !1, fastKey: function (e, t) {
                if (!Xe(e)) return "symbol" == typeof e ? e : ("string" == typeof e ? "S" : "P") + e;
                if (!Ke(e, i)) {
                    if (!r(e)) return "F";
                    if (!t) return "E";
                    o(e)
                }
                return e[i].i
            }, getWeak: function (e, t) {
                if (!Ke(e, i)) {
                    if (!r(e)) return !0;
                    if (!t) return !1;
                    o(e)
                }
                return e[i].w
            }, onFreeze: function (e) {
                return a && s.NEED && r(e) && !Ke(e, i) && o(e), e
            }
        }
    }), Ut = (kt.KEY, kt.NEED, kt.fastKey, kt.getWeak, kt.onFreeze, function (e, t) {
        if (!Xe(e) || e._t !== t) throw TypeError("Incompatible receiver, " + t + " required!");
        return e
    }), Dt = Qe.f, zt = kt.fastKey, Bt = Ye ? "_s" : "size", Ht = function (e, t) {
        var i, n = zt(t);
        if ("F" !== n) return e._i[n];
        for (i = e._f; i; i = i.n) if (i.k == t) return i
    }, Gt = {
        getConstructor: function (e, a, i, n) {
            var r = e(function (e, t) {
                Ft(e, r, a, "_i"), e._t = a, e._i = gt(null), e._f = void 0, e._l = void 0, e[Bt] = 0, null != t && Nt(t, i, e[n], e)
            });
            return Ot(r.prototype, {
                clear: function () {
                    for (var e = Ut(this, a), t = e._i, i = e._f; i; i = i.n) i.r = !0, i.p && (i.p = i.p.n = void 0), delete t[i.i];
                    e._f = e._l = void 0, e[Bt] = 0
                }, delete: function (e) {
                    var t = Ut(this, a), i = Ht(t, e);
                    if (i) {
                        var n = i.n, r = i.p;
                        delete t._i[i.i], i.r = !0, r && (r.n = n), n && (n.p = r), t._f == i && (t._f = n), t._l == i && (t._l = r), t[Bt]--
                    }
                    return !!i
                }, forEach: function (e) {
                    Ut(this, a);
                    for (var t, i = et(e, 1 < arguments.length ? arguments[1] : void 0, 3); t = t ? t.n : this._f;) for (i(t.v, t.k, this); t && t.r;) t = t.p
                }, has: function (e) {
                    return !!Ht(Ut(this, a), e)
                }
            }), Ye && Dt(r.prototype, "size", {
                get: function () {
                    return Ut(this, a)[Bt]
                }
            }), r
        }, def: function (e, t, i) {
            var n, r, a = Ht(e, t);
            return a ? a.v = i : (e._l = a = {
                i: r = zt(t, !0), k: t, v: i, p: n = e._l, n: void 0, r: !1
            }, e._f || (e._f = a), n && (n.n = a), e[Bt]++, "F" !== r && (e._i[r] = a)), e
        }, getEntry: Ht, setStrong: function (e, i, t) {
            Pe(e, i, function (e, t) {
                this._t = Ut(e, i), this._k = t, this._l = void 0
            }, function () {
                for (var e = this, t = e._k, i = e._l; i && i.r;) i = i.p;
                return e._t && (e._l = i = i ? i.n : e._t._f) ? ne(0, "keys" == t ? i.k : "values" == t ? i.v : [i.k, i.v]) : (e._t = void 0, ne(1))
            }, t ? "entries" : "values", !t, !0), _t(i)
        }
    }, jt = {f: {}.propertyIsEnumerable}, Vt = Object.getOwnPropertyDescriptor, Xt = {
        f: Ye ? Vt : function (e, t) {
            if (e = K(e), t = qe(t, !0), r) try {
                return Vt(e, t)
            } catch (e) {
            }
            if (Ke(e, t)) return Ze(!jt.f.call(e, t), e[t])
        }
    }, Wt = function (e, t) {
        if (S(e), !Xe(t) && null !== t) throw TypeError(t + ": can't set as prototype!")
    }, Yt = {
        set: Object.setPrototypeOf || ("__proto__" in {} ? function (e, i, n) {
            try {
                (n = et(Function.call, Xt.f(Object.prototype, "__proto__").set, 2))(e, []), i = !(e instanceof Array)
            } catch (e) {
                i = !0
            }
            return function (e, t) {
                return Wt(e, t), i ? e.__proto__ = t : n(e, t), e
            }
        }({}, !1) : void 0), check: Wt
    }, qt = Yt.set, Qt = function (e, t, i) {
        var n, r = t.constructor;
        return r !== i && "function" == typeof r && (n = r.prototype) !== i.prototype && Xe(n) && qt && qt(e, n), e
    }, Zt = function (n, e, t, i, r, a) {
        var o = Ve[n], s = o, l = r ? "set" : "add", h = s && s.prototype, c = {}, u = function (e) {
            var i = h[e];
            w(h, e, "delete" == e ? function (e) {
                return !(a && !Xe(e)) && i.call(this, 0 === e ? 0 : e)
            } : "has" == e ? function (e) {
                return !(a && !Xe(e)) && i.call(this, 0 === e ? 0 : e)
            } : "get" == e ? function (e) {
                return a && !Xe(e) ? void 0 : i.call(this, 0 === e ? 0 : e)
            } : "add" == e ? function (e) {
                return i.call(this, 0 === e ? 0 : e), this
            } : function (e, t) {
                return i.call(this, 0 === e ? 0 : e, t), this
            })
        };
        if ("function" == typeof s && (a || h.forEach && !We(function () {
            (new s).entries().next()
        }))) {
            var p = new s, d = p[l](a ? {} : -0, 1) != p, f = We(function () {
                p.has(1)
            }), m = ft(function (e) {
                new s(e)
            }), g = !a && We(function () {
                for (var e = new s, t = 5; t--;) e[l](t, t);
                return !e.has(-0)
            });
            m || (((s = e(function (e, t) {
                Ft(e, s, n);
                var i = Qt(new o, e, s);
                return null != t && Nt(t, r, i[l], i), i
            })).prototype = h).constructor = s), (f || g) && (u("delete"), u("has"), r && u("get")), (g || d) && u(l), a && h.clear && delete h.clear
        } else s = i.getConstructor(e, n, r, l), Ot(s.prototype, t), kt.NEED = !0;
        return xe(s, n), c[n] = s, tt(tt.G + tt.W + tt.F * (s != o), c), a || i.setStrong(s, n, r), s
    }, Jt = (Zt("Map", function (e) {
        return function () {
            return e(this, 0 < arguments.length ? arguments[0] : void 0)
        }
    }, {
        get: function (e) {
            var t = Gt.getEntry(Ut(this, "Map"), e);
            return t && t.v
        }, set: function (e, t) {
            return Gt.def(Ut(this, "Map"), 0 === e ? 0 : e, t)
        }
    }, Gt, !0), Math.log1p || function (e) {
        return -1e-8 < (e = +e) && e < 1e-8 ? e - e * e / 2 : Math.log(1 + e)
    }), Kt = Math.sqrt, $t = Math.acosh;
    tt(tt.S + tt.F * !($t && 710 == Math.floor($t(Number.MAX_VALUE)) && $t(1 / 0) == 1 / 0), "Math", {
        acosh: function (e) {
            return (e = +e) < 1 ? NaN : 94906265.62425156 < e ? Math.log(e) + Math.LN2 : Jt(e - 1 + Kt(e - 1) * Kt(e + 1))
        }
    });
    var ei = Math.asinh;
    tt(tt.S + tt.F * !(ei && 0 < 1 / ei(0)), "Math", {
        asinh: function e(t) {
            return isFinite(t = +t) && 0 != t ? t < 0 ? -e(-t) : Math.log(t + Math.sqrt(t * t + 1)) : t
        }
    });
    var ti = Math.atanh;
    tt(tt.S + tt.F * !(ti && 1 / ti(-0) < 0), "Math", {
        atanh: function (e) {
            return 0 == (e = +e) ? e : Math.log((1 + e) / (1 - e)) / 2
        }
    });
    var ii = Math.sign || function (e) {
        return 0 == (e = +e) || e != e ? e : e < 0 ? -1 : 1
    };
    tt(tt.S, "Math", {
        cbrt: function (e) {
            return ii(e = +e) * Math.pow(Math.abs(e), 1 / 3)
        }
    }), tt(tt.S, "Math", {
        clz32: function (e) {
            return (e >>>= 0) ? 31 - Math.floor(Math.log(e + .5) * Math.LOG2E) : 32
        }
    });
    var ni = Math.exp;
    tt(tt.S, "Math", {
        cosh: function (e) {
            return (ni(e = +e) + ni(-e)) / 2
        }
    });
    var ri = Math.expm1,
        ai = !ri || 22025.465794806718 < ri(10) || ri(10) < 22025.465794806718 || -2e-17 != ri(-2e-17) ? function (e) {
            return 0 == (e = +e) ? e : -1e-6 < e && e < 1e-6 ? e + e * e / 2 : Math.exp(e) - 1
        } : ri;
    tt(tt.S + tt.F * (ai != Math.expm1), "Math", {expm1: ai});
    var oi = Math.pow, si = oi(2, -52), li = oi(2, -23), hi = oi(2, 127) * (2 - li), ci = oi(2, -126),
        ui = Math.fround || function (e) {
            var t, i, n = Math.abs(e), r = ii(e);
            return n < ci ? r * (n / ci / li + 1 / si - 1 / si) * ci * li : hi < (i = (t = (1 + li / si) * n) - (t - n)) || i != i ? r * (1 / 0) : r * i
        };
    tt(tt.S, "Math", {fround: ui});
    var pi = Math.abs;
    tt(tt.S, "Math", {
        hypot: function (e, t) {
            for (var i, n, r = 0, a = 0, o = arguments.length, s = 0; a < o;) s < (i = pi(arguments[a++])) ? (r = r * (n = s / i) * n + 1, s = i) : r += 0 < i ? (n = i / s) * n : i;
            return s === 1 / 0 ? 1 / 0 : s * Math.sqrt(r)
        }
    });
    var di = Math.imul;
    tt(tt.S + tt.F * We(function () {
        return -5 != di(4294967295, 5) || 2 != di.length
    }), "Math", {
        imul: function (e, t) {
            var i = 65535, n = +e, r = +t, a = i & n, o = i & r;
            return 0 | a * o + ((i & n >>> 16) * o + a * (i & r >>> 16) << 16 >>> 0)
        }
    }), tt(tt.S, "Math", {log1p: Jt}), tt(tt.S, "Math", {
        log10: function (e) {
            return Math.log(e) * Math.LOG10E
        }
    }), tt(tt.S, "Math", {
        log2: function (e) {
            return Math.log(e) / Math.LN2
        }
    }), tt(tt.S, "Math", {sign: ii});
    var fi = Math.exp;
    tt(tt.S + tt.F * We(function () {
        return -2e-17 != !Math.sinh(-2e-17)
    }), "Math", {
        sinh: function (e) {
            return Math.abs(e = +e) < 1 ? (ai(e) - ai(-e)) / 2 : (fi(e - 1) - fi(-e - 1)) * (Math.E / 2)
        }
    });
    var mi = Math.exp;
    tt(tt.S, "Math", {
        tanh: function (e) {
            var t = ai(e = +e), i = ai(-e);
            return t == 1 / 0 ? 1 : i == 1 / 0 ? -1 : (t - i) / (mi(e) + mi(-e))
        }
    }), tt(tt.S, "Math", {
        trunc: function (e) {
            return (0 < e ? Math.floor : Math.ceil)(e)
        }
    });
    var gi = he.concat("length", "prototype"), vi = {
            f: Object.getOwnPropertyNames || function (e) {
                return le(e, gi)
            }
        }, yi = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff", _i = "[" + yi + "]", xi = RegExp("^" + _i + _i + "*"),
        bi = RegExp(_i + _i + "*$"), wi = function (e, t, i) {
            var n = {}, r = We(function () {
                return !!yi[e]() || "​" != "​"[e]()
            }), a = n[e] = r ? t(Ti) : yi[e];
            i && (n[i] = a), tt(tt.P + tt.F * r, "String", n)
        }, Ti = wi.trim = function (e, t) {
            return e = String(p(e)), 1 & t && (e = e.replace(xi, "")), 2 & t && (e = e.replace(bi, "")), e
        }, Si = wi, Ei = vi.f, Ai = Xt.f, Mi = Qe.f, Pi = Si.trim, Li = "Number", Ci = Ve[Li], Ii = Ci, Ri = Ci.prototype,
        Oi = M(gt(Ri)) == Li, Fi = "trim" in String.prototype, Ni = function (e) {
            var t = qe(e, !1);
            if ("string" == typeof t && 2 < t.length) {
                var i, n, r, a = (t = Fi ? t.trim() : Pi(t, 3)).charCodeAt(0);
                if (43 === a || 45 === a) {
                    if (88 === (i = t.charCodeAt(2)) || 120 === i) return NaN
                } else if (48 === a) {
                    switch (t.charCodeAt(1)) {
                        case 66:
                        case 98:
                            n = 2, r = 49;
                            break;
                        case 79:
                        case 111:
                            n = 8, r = 55;
                            break;
                        default:
                            return +t
                    }
                    for (var o, s = t.slice(2), l = 0, h = s.length; l < h; l++) if ((o = s.charCodeAt(l)) < 48 || r < o) return NaN;
                    return parseInt(s, n)
                }
            }
            return +t
        };
    if (!Ci(" 0o1") || !Ci("0b1") || Ci("+0x1")) {
        Ci = function (e) {
            var t = arguments.length < 1 ? 0 : e, i = this;
            return i instanceof Ci && (Oi ? We(function () {
                Ri.valueOf.call(i)
            }) : M(i) != Li) ? Qt(new Ii(Ni(t)), i, Ci) : Ni(t)
        };
        for (var ki, Ui = Ye ? Ei(Ii) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), Di = 0; Ui.length > Di; Di++) Ke(Ii, ki = Ui[Di]) && !Ke(Ci, ki) && Mi(Ci, ki, Ai(Ii, ki));
        (Ci.prototype = Ri).constructor = Ci, w(Ve, Li, Ci)
    }
    tt(tt.S, "Number", {EPSILON: Math.pow(2, -52)});
    var zi = Ve.isFinite;
    tt(tt.S, "Number", {
        isFinite: function (e) {
            return "number" == typeof e && zi(e)
        }
    });
    var Bi = Math.floor, Hi = function (e) {
        return !Xe(e) && isFinite(e) && Bi(e) === e
    };
    tt(tt.S, "Number", {isInteger: Hi}), tt(tt.S, "Number", {
        isNaN: function (e) {
            return e != e
        }
    });
    var Gi = Math.abs;
    tt(tt.S, "Number", {
        isSafeInteger: function (e) {
            return Hi(e) && Gi(e) <= 9007199254740991
        }
    }), tt(tt.S, "Number", {MAX_SAFE_INTEGER: 9007199254740991}), tt(tt.S, "Number", {MIN_SAFE_INTEGER: -9007199254740991});
    var ji = Ve.parseFloat, Vi = Si.trim, Xi = 1 / ji(yi + "-0") != -1 / 0 ? function (e) {
        var t = Vi(String(e), 3), i = ji(t);
        return 0 === i && "-" == t.charAt(0) ? -0 : i
    } : ji;
    tt(tt.S + tt.F * (Number.parseFloat != Xi), "Number", {parseFloat: Xi});
    var Wi = Ve.parseInt, Yi = Si.trim, qi = /^[-+]?0[xX]/,
        Qi = 8 !== Wi(yi + "08") || 22 !== Wi(yi + "0x16") ? function (e, t) {
            var i = Yi(String(e), 3);
            return Wi(i, t >>> 0 || (qi.test(i) ? 16 : 10))
        } : Wi;
    tt(tt.S + tt.F * (Number.parseInt != Qi), "Number", {parseInt: Qi});
    var Zi = {f: Object.getOwnPropertySymbols}, Ji = Object.assign, Ki = !Ji || We(function () {
        var e = {}, t = {}, i = Symbol(), n = "abcdefghijklmnopqrst";
        return e[i] = 7, n.split("").forEach(function (e) {
            t[e] = e
        }), 7 != Ji({}, e)[i] || Object.keys(Ji({}, t)).join("") != n
    }) ? function (e, t) {
        for (var i = it(e), n = arguments.length, r = 1, a = Zi.f, o = jt.f; r < n;) for (var s, l = P(arguments[r++]), h = a ? ce(l).concat(a(l)) : ce(l), c = h.length, u = 0; u < c;) o.call(l, s = h[u++]) && (i[s] = l[s]);
        return i
    } : Ji;
    tt(tt.S + tt.F, "Object", {assign: Ki}), tt(tt.S, "Object", {create: gt});
    var $i = !We(function () {
        var e = Math.random();
        __defineSetter__.call(null, e, function () {
        }), delete Ve[e]
    });
    Ye && tt(tt.P + $i, "Object", {
        __defineGetter__: function (e, t) {
            Qe.f(it(this), e, {get: c(t), enumerable: !0, configurable: !0})
        }
    }), Ye && tt(tt.P + $i, "Object", {
        __defineSetter__: function (e, t) {
            Qe.f(it(this), e, {set: c(t), enumerable: !0, configurable: !0})
        }
    }), tt(tt.S + tt.F * !Ye, "Object", {defineProperty: Qe.f}), tt(tt.S + tt.F * !Ye, "Object", {defineProperties: ue});
    var en = jt.f, tn = function (s) {
        return function (e) {
            for (var t, i = K(e), n = ce(i), r = n.length, a = 0, o = []; a < r;) en.call(i, t = n[a++]) && o.push(s ? [t, i[t]] : i[t]);
            return o
        }
    }, nn = tn(!0);
    tt(tt.S, "Object", {
        entries: function (e) {
            return nn(e)
        }
    });
    var rn = function (e, t) {
        var i = (m.Object || {})[e] || Object[e], n = {};
        n[e] = t(i), tt(tt.S + tt.F * We(function () {
            i(1)
        }), "Object", n)
    }, an = kt.onFreeze;
    rn("freeze", function (t) {
        return function (e) {
            return t && Xe(e) ? t(an(e)) : e
        }
    });
    var on = Xt.f;
    rn("getOwnPropertyDescriptor", function () {
        return function (e, t) {
            return on(K(e), t)
        }
    });
    var sn = Ve.Reflect, ln = sn && sn.ownKeys || function (e) {
        var t = vi.f(S(e)), i = Zi.f;
        return i ? t.concat(i(e)) : t
    };
    tt(tt.S, "Object", {
        getOwnPropertyDescriptors: function (e) {
            for (var t, i, n = K(e), r = Xt.f, a = ln(n), o = {}, s = 0; a.length > s;) void 0 !== (i = r(n, t = a[s++])) && W(o, t, i);
            return o
        }
    });
    var hn = vi.f, cn = {}.toString,
        un = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
        pn = {
            f: function (e) {
                return un && "[object Window]" == cn.call(e) ? function (e) {
                    try {
                        return hn(e)
                    } catch (e) {
                        return un.slice()
                    }
                }(e) : hn(K(e))
            }
        };
    rn("getOwnPropertyNames", function () {
        return pn.f
    }), rn("getPrototypeOf", function () {
        return function (e) {
            return vt(it(e))
        }
    });
    var dn = Xt.f;
    Ye && tt(tt.P + $i, "Object", {
        __lookupGetter__: function (e) {
            var t, i = it(this), n = qe(e, !0);
            do {
                if (t = dn(i, n)) return t.get
            } while (i = vt(i))
        }
    });
    var fn = Xt.f;
    Ye && tt(tt.P + $i, "Object", {
        __lookupSetter__: function (e) {
            var t, i = it(this), n = qe(e, !0);
            do {
                if (t = fn(i, n)) return t.set
            } while (i = vt(i))
        }
    });
    var mn = kt.onFreeze;
    rn("preventExtensions", function (t) {
        return function (e) {
            return t && Xe(e) ? t(mn(e)) : e
        }
    });
    var gn = Object.is || function (e, t) {
        return e === t ? 0 !== e || 1 / e == 1 / t : e != e && t != t
    };
    tt(tt.S, "Object", {is: gn}), rn("isFrozen", function (t) {
        return function (e) {
            return !Xe(e) || !!t && t(e)
        }
    }), rn("isSealed", function (t) {
        return function (e) {
            return !Xe(e) || !!t && t(e)
        }
    }), rn("isExtensible", function (t) {
        return function (e) {
            return !!Xe(e) && (!t || t(e))
        }
    }), rn("keys", function () {
        return function (e) {
            return ce(it(e))
        }
    });
    var vn = kt.onFreeze;
    rn("seal", function (t) {
        return function (e) {
            return t && Xe(e) ? t(vn(e)) : e
        }
    }), tt(tt.S, "Object", {setPrototypeOf: Yt.set});
    var yn = tn(!1);
    tt(tt.S, "Object", {
        values: function (e) {
            return yn(e)
        }
    });
    var _n, xn, bn, wn = st("species"), Tn = function (e, t) {
            var i, n = S(e).constructor;
            return void 0 === n || null == (i = S(n)[wn]) ? t : c(i)
        }, Sn = Ve.process, En = Ve.setImmediate, An = Ve.clearImmediate, Mn = Ve.MessageChannel, Pn = Ve.Dispatch, Ln = 0,
        Cn = {}, In = "onreadystatechange", Rn = function () {
            var e = +this;
            if (Cn.hasOwnProperty(e)) {
                var t = Cn[e];
                delete Cn[e], t()
            }
        }, On = function (e) {
            Rn.call(e.data)
        };
    En && An || (En = function (e) {
        for (var t = [], i = 1; arguments.length > i;) t.push(arguments[i++]);
        return Cn[++Ln] = function () {
            St("function" == typeof e ? e : Function(e), t)
        }, _n(Ln), Ln
    }, An = function (e) {
        delete Cn[e]
    }, "process" == M(Sn) ? _n = function (e) {
        Sn.nextTick(et(Rn, e, 1))
    } : Pn && Pn.now ? _n = function (e) {
        Pn.now(et(Rn, e, 1))
    } : Mn ? (bn = (xn = new Mn).port2, xn.port1.onmessage = On, _n = et(bn.postMessage, bn, 1)) : Ve.addEventListener && "function" == typeof postMessage && !Ve.importScripts ? (_n = function (e) {
        Ve.postMessage(e + "", "*")
    }, Ve.addEventListener("message", On, !1)) : _n = In in n("script") ? function (e) {
        de.appendChild(n("script"))[In] = function () {
            de.removeChild(this), Rn.call(e)
        }
    } : function (e) {
        setTimeout(et(Rn, e, 1), 0)
    });
    var Fn = {set: En, clear: An}, Nn = Fn.set, kn = Ve.MutationObserver || Ve.WebKitMutationObserver, Un = Ve.process,
        Dn = Ve.Promise, zn = "process" == M(Un);

    function Bn(e) {
        var i, n;
        this.promise = new e(function (e, t) {
            if (void 0 !== i || void 0 !== n) throw TypeError("Bad Promise constructor");
            i = e, n = t
        }), this.resolve = c(i), this.reject = c(n)
    }

    var Hn, Gn, jn, Vn, Xn = {
            f: function (e) {
                return new Bn(e)
            }
        }, Wn = function (e) {
            try {
                return {e: !1, v: e()}
            } catch (e) {
                return {e: !0, v: e}
            }
        }, Yn = Ve.navigator, qn = Yn && Yn.userAgent || "", Qn = function (e, t) {
            if (S(e), Xe(t) && t.constructor === e) return t;
            var i = Xn.f(e);
            return (0, i.resolve)(t), i.promise
        }, Zn = Fn.set, Jn = function () {
            var i, n, r, e = function () {
                var e, t;
                for (zn && (e = Un.domain) && e.exit(); i;) {
                    t = i.fn, i = i.next;
                    try {
                        t()
                    } catch (e) {
                        throw i ? r() : n = void 0, e
                    }
                }
                n = void 0, e && e.enter()
            };
            if (zn) r = function () {
                Un.nextTick(e)
            }; else if (!kn || Ve.navigator && Ve.navigator.standalone) if (Dn && Dn.resolve) {
                var t = Dn.resolve(void 0);
                r = function () {
                    t.then(e)
                }
            } else r = function () {
                Nn.call(Ve, e)
            }; else {
                var a = !0, o = document.createTextNode("");
                new kn(e).observe(o, {characterData: !0}), r = function () {
                    o.data = a = !a
                }
            }
            return function (e) {
                var t = {fn: e, next: void 0};
                n && (n.next = t), i || (i = t, r()), n = t
            }
        }(), Kn = "Promise", $n = Ve.TypeError, er = Ve.process, tr = er && er.versions, ir = tr && tr.v8 || "",
        nr = Ve[Kn], rr = "process" == pt(er), ar = function () {
        }, or = Gn = Xn.f, sr = !!function () {
            try {
                var e = nr.resolve(1), t = (e.constructor = {})[st("species")] = function (e) {
                    e(ar, ar)
                };
                return (rr || "function" == typeof PromiseRejectionEvent) && e.then(ar) instanceof t && 0 !== ir.indexOf("6.6") && -1 === qn.indexOf("Chrome/66")
            } catch (e) {
            }
        }(), lr = function (e) {
            var t;
            return !(!Xe(e) || "function" != typeof (t = e.then)) && t
        }, hr = function (c, i) {
            if (!c._n) {
                c._n = !0;
                var n = c._c;
                Jn(function () {
                    for (var l = c._v, h = 1 == c._s, e = 0, t = function (e) {
                        var t, i, n, r = h ? e.ok : e.fail, a = e.resolve, o = e.reject, s = e.domain;
                        try {
                            r ? (h || (2 == c._h && pr(c), c._h = 1), !0 === r ? t = l : (s && s.enter(), t = r(l), s && (s.exit(), n = !0)), t === e.promise ? o($n("Promise-chain cycle")) : (i = lr(t)) ? i.call(t, a, o) : a(t)) : o(l)
                        } catch (e) {
                            s && !n && s.exit(), o(e)
                        }
                    }; n.length > e;) t(n[e++]);
                    c._c = [], c._n = !1, i && !c._h && cr(c)
                })
            }
        }, cr = function (a) {
            Zn.call(Ve, function () {
                var e, t, i, n = a._v, r = ur(a);
                if (r && (e = Wn(function () {
                    rr ? er.emit("unhandledRejection", n, a) : (t = Ve.onunhandledrejection) ? t({
                        promise: a, reason: n
                    }) : (i = Ve.console) && i.error && i.error("Unhandled promise rejection", n)
                }), a._h = rr || ur(a) ? 2 : 1), a._a = void 0, r && e.e) throw e.v
            })
        }, ur = function (e) {
            return 1 !== e._h && 0 === (e._a || e._c).length
        }, pr = function (t) {
            Zn.call(Ve, function () {
                var e;
                rr ? er.emit("rejectionHandled", t) : (e = Ve.onrejectionhandled) && e({promise: t, reason: t._v})
            })
        }, dr = function (e) {
            var t = this;
            t._d || (t._d = !0, (t = t._w || t)._v = e, t._s = 2, t._a || (t._a = t._c.slice()), hr(t, !0))
        }, fr = function (e) {
            var i, n = this;
            if (!n._d) {
                n._d = !0, n = n._w || n;
                try {
                    if (n === e) throw $n("Promise can't be resolved itself");
                    (i = lr(e)) ? Jn(function () {
                        var t = {_w: n, _d: !1};
                        try {
                            i.call(e, et(fr, t, 1), et(dr, t, 1))
                        } catch (e) {
                            dr.call(t, e)
                        }
                    }) : (n._v = e, n._s = 1, hr(n, !1))
                } catch (e) {
                    dr.call({_w: n, _d: !1}, e)
                }
            }
        };
    sr || (nr = function (e) {
        Ft(this, nr, Kn, "_h"), c(e), Hn.call(this);
        try {
            e(et(fr, this, 1), et(dr, this, 1))
        } catch (e) {
            dr.call(this, e)
        }
    }, (Hn = function (e) {
        this._c = [], this._a = void 0, this._s = 0, this._d = !1, this._v = void 0, this._h = 0, this._n = !1
    }).prototype = Ot(nr.prototype, {
        then: function (e, t) {
            var i = or(Tn(this, nr));
            return i.ok = "function" != typeof e || e, i.fail = "function" == typeof t && t, i.domain = rr ? er.domain : void 0, this._c.push(i), this._a && this._a.push(i), this._s && hr(this, !1), i.promise
        }, catch: function (e) {
            return this.then(void 0, e)
        }
    }), jn = function () {
        var e = new Hn;
        this.promise = e, this.resolve = et(fr, e, 1), this.reject = et(dr, e, 1)
    }, Xn.f = or = function (e) {
        return e === nr || e === Vn ? new jn(e) : Gn(e)
    }), tt(tt.G + tt.W + tt.F * !sr, {Promise: nr}), xe(nr, Kn), _t(Kn), Vn = m[Kn], tt(tt.S + tt.F * !sr, Kn, {
        reject: function (e) {
            var t = or(this);
            return (0, t.reject)(e), t.promise
        }
    }), tt(tt.S + tt.F * !sr, Kn, {
        resolve: function (e) {
            return Qn(this, e)
        }
    }), tt(tt.S + tt.F * !(sr && ft(function (e) {
        nr.all(e).catch(ar)
    })), Kn, {
        all: function (e) {
            var o = this, t = or(o), s = t.resolve, l = t.reject, i = Wn(function () {
                var n = [], r = 0, a = 1;
                Nt(e, !1, function (e) {
                    var t = r++, i = !1;
                    n.push(void 0), a++, o.resolve(e).then(function (e) {
                        i || (i = !0, n[t] = e, --a || s(n))
                    }, l)
                }), --a || s(n)
            });
            return i.e && l(i.v), t.promise
        }, race: function (e) {
            var t = this, i = or(t), n = i.reject, r = Wn(function () {
                Nt(e, !1, function (e) {
                    t.resolve(e).then(i.resolve, n)
                })
            });
            return r.e && n(r.v), i.promise
        }
    }), tt(tt.P + tt.R, "Promise", {
        finally: function (t) {
            var i = Tn(this, m.Promise || Ve.Promise), e = "function" == typeof t;
            return this.then(e ? function (e) {
                return Qn(i, t()).then(function () {
                    return e
                })
            } : t, e ? function (e) {
                return Qn(i, t()).then(function () {
                    throw e
                })
            } : t)
        }
    });
    var mr = (Ve.Reflect || {}).apply, gr = Function.apply;
    tt(tt.S + tt.F * !We(function () {
        mr(function () {
        })
    }), "Reflect", {
        apply: function (e, t, i) {
            var n = c(e), r = S(i);
            return mr ? mr(n, t, r) : gr.call(n, t, r)
        }
    });
    var vr = (Ve.Reflect || {}).construct, yr = We(function () {
        function e() {
        }

        return !(vr(function () {
        }, [], e) instanceof e)
    }), _r = !We(function () {
        vr(function () {
        })
    });
    tt(tt.S + tt.F * (yr || _r), "Reflect", {
        construct: function (e, t) {
            c(e), S(t);
            var i = arguments.length < 3 ? e : c(arguments[2]);
            if (_r && !yr) return vr(e, t, i);
            if (e == i) {
                switch (t.length) {
                    case 0:
                        return new e;
                    case 1:
                        return new e(t[0]);
                    case 2:
                        return new e(t[0], t[1]);
                    case 3:
                        return new e(t[0], t[1], t[2]);
                    case 4:
                        return new e(t[0], t[1], t[2], t[3])
                }
                var n = [null];
                return n.push.apply(n, t), new (Mt.apply(e, n))
            }
            var r = i.prototype, a = gt(Xe(r) ? r : Object.prototype), o = Function.apply.call(e, a, t);
            return Xe(o) ? o : a
        }
    }), tt(tt.S + tt.F * We(function () {
        Reflect.defineProperty(Qe.f({}, 1, {value: 1}), 1, {value: 2})
    }), "Reflect", {
        defineProperty: function (e, t, i) {
            S(e), t = qe(t, !0), S(i);
            try {
                return Qe.f(e, t, i), !0
            } catch (e) {
                return !1
            }
        }
    });
    var xr = Xt.f;
    tt(tt.S, "Reflect", {
        deleteProperty: function (e, t) {
            var i = xr(S(e), t);
            return !(i && !i.configurable) && delete e[t]
        }
    }), tt(tt.S, "Reflect", {
        get: function e(t, i) {
            var n, r, a = arguments.length < 3 ? t : arguments[2];
            return S(t) === a ? t[i] : (n = Xt.f(t, i)) ? Ke(n, "value") ? n.value : void 0 !== n.get ? n.get.call(a) : void 0 : Xe(r = vt(t)) ? e(r, i, a) : void 0
        }
    }), tt(tt.S, "Reflect", {
        getOwnPropertyDescriptor: function (e, t) {
            return Xt.f(S(e), t)
        }
    }), tt(tt.S, "Reflect", {
        getPrototypeOf: function (e) {
            return vt(S(e))
        }
    }), tt(tt.S, "Reflect", {
        has: function (e, t) {
            return t in e
        }
    });
    var br = Object.isExtensible;
    tt(tt.S, "Reflect", {
        isExtensible: function (e) {
            return S(e), !br || br(e)
        }
    }), tt(tt.S, "Reflect", {ownKeys: ln});
    var wr = Object.preventExtensions;
    tt(tt.S, "Reflect", {
        preventExtensions: function (e) {
            S(e);
            try {
                return wr && wr(e), !0
            } catch (e) {
                return !1
            }
        }
    }), tt(tt.S, "Reflect", {
        set: function e(t, i, n) {
            var r, a, o = arguments.length < 4 ? t : arguments[3], s = Xt.f(S(t), i);
            if (!s) {
                if (Xe(a = vt(t))) return e(a, i, n, o);
                s = Ze(0)
            }
            if (Ke(s, "value")) {
                if (!1 === s.writable || !Xe(o)) return !1;
                if (r = Xt.f(o, i)) {
                    if (r.get || r.set || !1 === r.writable) return !1;
                    r.value = n, Qe.f(o, i, r)
                } else Qe.f(o, i, Ze(0, n));
                return !0
            }
            return void 0 !== s.set && (s.set.call(o, n), !0)
        }
    }), Yt && tt(tt.S, "Reflect", {
        setPrototypeOf: function (e, t) {
            Yt.check(e, t);
            try {
                return Yt.set(e, t), !0
            } catch (e) {
                return !1
            }
        }
    });
    var Tr = st("match"), Sr = function (e) {
        var t;
        return Xe(e) && (void 0 !== (t = e[Tr]) ? !!t : "RegExp" == M(e))
    }, Er = function () {
        var e = S(this), t = "";
        return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.unicode && (t += "u"), e.sticky && (t += "y"), t
    }, Ar = Qe.f, Mr = vi.f, Pr = Ve.RegExp, Lr = Pr, Cr = Pr.prototype, Ir = /a/g, Rr = /a/g, Or = new Pr(Ir) !== Ir;
    if (Ye && (!Or || We(function () {
        return Rr[st("match")] = !1, Pr(Ir) != Ir || Pr(Rr) == Rr || "/a/i" != Pr(Ir, "i")
    }))) {
        Pr = function (e, t) {
            var i = this instanceof Pr, n = Sr(e), r = void 0 === t;
            return !i && n && e.constructor === Pr && r ? e : Qt(Or ? new Lr(n && !r ? e.source : e, t) : Lr((n = e instanceof Pr) ? e.source : e, n && r ? Er.call(e) : t), i ? this : Cr, Pr)
        };
        for (var Fr = function (t) {
            t in Pr || Ar(Pr, t, {
                configurable: !0, get: function () {
                    return Lr[t]
                }, set: function (e) {
                    Lr[t] = e
                }
            })
        }, Nr = Mr(Lr), kr = 0; Nr.length > kr;) Fr(Nr[kr++]);
        (Cr.constructor = Pr).prototype = Cr, w(Ve, "RegExp", Pr)
    }
    _t("RegExp"), Ye && "g" != /./g.flags && Qe.f(RegExp.prototype, "flags", {configurable: !0, get: Er});
    var Ur, Dr, zr = function (s) {
            return function (e, t) {
                var i, n, r = String(p(e)), a = nt(t), o = r.length;
                return a < 0 || o <= a ? s ? "" : void 0 : (i = r.charCodeAt(a)) < 55296 || 56319 < i || a + 1 === o || (n = r.charCodeAt(a + 1)) < 56320 || 57343 < n ? s ? r.charAt(a) : i : s ? r.slice(a, a + 2) : n - 56320 + (i - 55296 << 10) + 65536
            }
        }, Br = zr(!0), Hr = function (e, t, i) {
            return t + (i ? Br(e, t).length : 1)
        }, Gr = RegExp.prototype.exec, jr = function (e, t) {
            var i = e.exec;
            if ("function" == typeof i) {
                var n = i.call(e, t);
                if ("object" != typeof n) throw new TypeError("RegExp exec method returned something other than an Object or null");
                return n
            }
            if ("RegExp" !== pt(e)) throw new TypeError("RegExp#exec called on incompatible receiver");
            return Gr.call(e, t)
        }, Vr = RegExp.prototype.exec, Xr = String.prototype.replace, Wr = Vr, Yr = "lastIndex",
        qr = (Ur = /a/, Dr = /b*/g, Vr.call(Ur, "a"), Vr.call(Dr, "a"), 0 !== Ur[Yr] || 0 !== Dr[Yr]),
        Qr = void 0 !== /()??/.exec("")[1];
    (qr || Qr) && (Wr = function (e) {
        var t, i, n, r, a = this;
        return Qr && (i = new RegExp("^" + a.source + "$(?!\\s)", Er.call(a))), qr && (t = a[Yr]), n = Vr.call(a, e), qr && n && (a[Yr] = a.global ? n.index + n[0].length : t), Qr && n && 1 < n.length && Xr.call(n[0], i, function () {
            for (r = 1; r < arguments.length - 2; r++) void 0 === arguments[r] && (n[r] = void 0)
        }), n
    });
    var Zr = Wr;
    tt({target: "RegExp", proto: !0, forced: Zr !== /./.exec}, {exec: Zr});
    var Jr = st("species"), Kr = !We(function () {
        var e = /./;
        return e.exec = function () {
            var e = [];
            return e.groups = {a: "7"}, e
        }, "7" !== "".replace(e, "$<a>")
    }), $r = function () {
        var e = /(?:)/, t = e.exec;
        e.exec = function () {
            return t.apply(this, arguments)
        };
        var i = "ab".split(e);
        return 2 === i.length && "a" === i[0] && "b" === i[1]
    }(), ea = function (i, e, t) {
        var n = st(i), a = !We(function () {
            var e = {};
            return e[n] = function () {
                return 7
            }, 7 != ""[i](e)
        }), r = a ? !We(function () {
            var e = !1, t = /a/;
            return t.exec = function () {
                return e = !0, null
            }, "split" === i && (t.constructor = {}, t.constructor[Jr] = function () {
                return t
            }), t[n](""), !e
        }) : void 0;
        if (!a || !r || "replace" === i && !Kr || "split" === i && !$r) {
            var o = /./[n], s = t(p, n, ""[i], function (e, t, i, n, r) {
                return t.exec === Zr ? a && !r ? {done: !0, value: o.call(t, i, n)} : {
                    done: !0, value: e.call(i, t, n)
                } : {done: !1}
            }), l = s[0], h = s[1];
            w(String.prototype, i, l), Je(RegExp.prototype, n, 2 == e ? function (e, t) {
                return h.call(e, this, t)
            } : function (e) {
                return h.call(e, this)
            })
        }
    };
    ea("match", 1, function (n, r, h, c) {
        return [function (e) {
            var t = n(this), i = null == e ? void 0 : e[r];
            return void 0 !== i ? i.call(e, t) : new RegExp(e)[r](String(t))
        }, function (e) {
            var t = c(h, e, this);
            if (t.done) return t.value;
            var i = S(e), n = String(this);
            if (!i.global) return jr(i, n);
            for (var r, a = i.unicode, o = [], s = i.lastIndex = 0; null !== (r = jr(i, n));) {
                var l = String(r[0]);
                "" === (o[s] = l) && (i.lastIndex = Hr(n, at(i.lastIndex), a)), s++
            }
            return 0 === s ? null : o
        }]
    });
    var ta = Math.max, ia = Math.min, na = Math.floor, ra = /\$([$&`']|\d\d?|<[^>]*>)/g, aa = /\$([$&`']|\d\d?)/g;
    ea("replace", 2, function (r, a, b, w) {
        return [function (e, t) {
            var i = r(this), n = null == e ? void 0 : e[a];
            return void 0 !== n ? n.call(e, i, t) : b.call(String(i), e, t)
        }, function (e, t) {
            var i = w(b, e, this, t);
            if (i.done) return i.value;
            var n = S(e), r = String(this), a = "function" == typeof t;
            a || (t = String(t));
            var o = n.global;
            if (o) {
                var s = n.unicode;
                n.lastIndex = 0
            }
            for (var l = []; ;) {
                var h = jr(n, r);
                if (null === h) break;
                if (l.push(h), !o) break;
                "" === String(h[0]) && (n.lastIndex = Hr(r, at(n.lastIndex), s))
            }
            for (var c, u = "", p = 0, d = 0; d < l.length; d++) {
                h = l[d];
                for (var f = String(h[0]), m = ta(ia(nt(h.index), r.length), 0), g = [], v = 1; v < h.length; v++) g.push(void 0 === (c = h[v]) ? c : String(c));
                var y = h.groups;
                if (a) {
                    var _ = [f].concat(g, m, r);
                    void 0 !== y && _.push(y);
                    var x = String(t.apply(void 0, _))
                } else x = T(f, r, m, g, y, t);
                p <= m && (u += r.slice(p, m) + x, p = m + f.length)
            }
            return u + r.slice(p)
        }];

        function T(a, o, s, l, h, e) {
            var c = s + a.length, u = l.length, t = aa;
            return void 0 !== h && (h = it(h), t = ra), b.call(e, t, function (e, t) {
                var i;
                switch (t.charAt(0)) {
                    case"$":
                        return "$";
                    case"&":
                        return a;
                    case"`":
                        return o.slice(0, s);
                    case"'":
                        return o.slice(c);
                    case"<":
                        i = h[t.slice(1, -1)];
                        break;
                    default:
                        var n = +t;
                        if (0 === n) return t;
                        if (u < n) {
                            var r = na(n / 10);
                            return 0 === r ? t : r <= u ? void 0 === l[r - 1] ? t.charAt(1) : l[r - 1] + t.charAt(1) : t
                        }
                        i = l[n - 1]
                }
                return void 0 === i ? "" : i
            })
        }
    });
    var oa = Math.min, sa = [].push, la = "split", ha = "length", ca = "lastIndex", ua = !!function () {
        try {
            return new RegExp("x", "y")
        } catch (e) {
        }
    }();
    ea("split", 2, function (r, a, g, v) {
        var y;
        return y = "c" == "abbc"[la](/(b)*/)[1] || 4 != "test"[la](/(?:)/, -1)[ha] || 2 != "ab"[la](/(?:ab)*/)[ha] || 4 != "."[la](/(.?)(.?)/)[ha] || 1 < "."[la](/()()/)[ha] || ""[la](/.?/)[ha] ? function (e, t) {
            var i = String(this);
            if (void 0 === e && 0 === t) return [];
            if (!Sr(e)) return g.call(i, e, t);
            for (var n, r, a, o = [], s = (e.ignoreCase ? "i" : "") + (e.multiline ? "m" : "") + (e.unicode ? "u" : "") + (e.sticky ? "y" : ""), l = 0, h = void 0 === t ? 4294967295 : t >>> 0, c = new RegExp(e.source, s + "g"); (n = Zr.call(c, i)) && !(l < (r = c[ca]) && (o.push(i.slice(l, n.index)), 1 < n[ha] && n.index < i[ha] && sa.apply(o, n.slice(1)), a = n[0][ha], l = r, o[ha] >= h));) c[ca] === n.index && c[ca]++;
            return l === i[ha] ? !a && c.test("") || o.push("") : o.push(i.slice(l)), o[ha] > h ? o.slice(0, h) : o
        } : "0"[la](void 0, 0)[ha] ? function (e, t) {
            return void 0 === e && 0 === t ? [] : g.call(this, e, t)
        } : g, [function (e, t) {
            var i = r(this), n = null == e ? void 0 : e[a];
            return void 0 !== n ? n.call(e, i, t) : y.call(String(i), e, t)
        }, function (e, t) {
            var i = v(y, e, this, t, y !== g);
            if (i.done) return i.value;
            var n = S(e), r = String(this), a = Tn(n, RegExp), o = n.unicode,
                s = (n.ignoreCase ? "i" : "") + (n.multiline ? "m" : "") + (n.unicode ? "u" : "") + (ua ? "y" : "g"),
                l = new a(ua ? n : "^(?:" + n.source + ")", s), h = void 0 === t ? 4294967295 : t >>> 0;
            if (0 === h) return [];
            if (0 === r.length) return null === jr(l, r) ? [r] : [];
            for (var c = 0, u = 0, p = []; u < r.length;) {
                l.lastIndex = ua ? u : 0;
                var d, f = jr(l, ua ? r : r.slice(u));
                if (null === f || (d = oa(at(l.lastIndex + (ua ? 0 : u)), r.length)) === c) u = Hr(r, u, o); else {
                    if (p.push(r.slice(c, u)), p.length === h) return p;
                    for (var m = 1; m <= f.length - 1; m++) if (p.push(f[m]), p.length === h) return p;
                    u = c = d
                }
            }
            return p.push(r.slice(c)), p
        }]
    }), ea("search", 1, function (n, r, o, s) {
        return [function (e) {
            var t = n(this), i = null == e ? void 0 : e[r];
            return void 0 !== i ? i.call(e, t) : new RegExp(e)[r](String(t))
        }, function (e) {
            var t = s(o, e, this);
            if (t.done) return t.value;
            var i = S(e), n = String(this), r = i.lastIndex;
            gn(r, 0) || (i.lastIndex = 0);
            var a = jr(i, n);
            return gn(i.lastIndex, r) || (i.lastIndex = r), null === a ? -1 : a.index
        }]
    });
    var pa = "toString", da = /./[pa], fa = function (e) {
        w(RegExp.prototype, pa, e, !0)
    };
    We(function () {
        return "/a/b" != da.call({source: "a", flags: "b"})
    }) ? fa(function () {
        var e = S(this);
        return "/".concat(e.source, "/", "flags" in e ? e.flags : !Ye && e instanceof RegExp ? Er.call(e) : void 0)
    }) : da.name != pa && fa(function () {
        return da.call(this)
    });
    Zt("Set", function (e) {
        return function () {
            return e(this, 0 < arguments.length ? arguments[0] : void 0)
        }
    }, {
        add: function (e) {
            return Gt.def(Ut(this, "Set"), e = 0 === e ? 0 : e, e)
        }
    }, Gt);
    var ma = {f: st}, ga = Qe.f, va = function (e) {
            var t = m.Symbol || (m.Symbol = Ve.Symbol || {});
            "_" == e.charAt(0) || e in t || ga(t, e, {value: ma.f(e)})
        }, ya = kt.KEY, _a = Xt.f, xa = Qe.f, ba = pn.f, wa = Ve.Symbol, Ta = Ve.JSON, Sa = Ta && Ta.stringify,
        Ea = "prototype", Aa = st("_hidden"), Ma = st("toPrimitive"), Pa = {}.propertyIsEnumerable,
        La = x("symbol-registry"), Ca = x("symbols"), Ia = x("op-symbols"), Ra = Object[Ea],
        Oa = "function" == typeof wa, Fa = Ve.QObject, Na = !Fa || !Fa[Ea] || !Fa[Ea].findChild,
        ka = Ye && We(function () {
            return 7 != gt(xa({}, "a", {
                get: function () {
                    return xa(this, "a", {value: 7}).a
                }
            })).a
        }) ? function (e, t, i) {
            var n = _a(Ra, t);
            n && delete Ra[t], xa(e, t, i), n && e !== Ra && xa(Ra, t, n)
        } : xa, Ua = function (e) {
            var t = Ca[e] = gt(wa[Ea]);
            return t._k = e, t
        }, Da = Oa && "symbol" == typeof wa.iterator ? function (e) {
            return "symbol" == typeof e
        } : function (e) {
            return e instanceof wa
        }, za = function (e, t, i) {
            return e === Ra && za(Ia, t, i), S(e), t = qe(t, !0), S(i), Ke(Ca, t) ? (i.enumerable ? (Ke(e, Aa) && e[Aa][t] && (e[Aa][t] = !1), i = gt(i, {enumerable: Ze(0, !1)})) : (Ke(e, Aa) || xa(e, Aa, Ze(1, {})), e[Aa][t] = !0), ka(e, t, i)) : xa(e, t, i)
        }, Ba = function (e, t) {
            S(e);
            for (var i, n = function (e) {
                var t = ce(e), i = Zi.f;
                if (i) for (var n, r = i(e), a = jt.f, o = 0; r.length > o;) a.call(e, n = r[o++]) && t.push(n);
                return t
            }(t = K(t)), r = 0, a = n.length; r < a;) za(e, i = n[r++], t[i]);
            return e
        }, Ha = function (e) {
            var t = Pa.call(this, e = qe(e, !0));
            return !(this === Ra && Ke(Ca, e) && !Ke(Ia, e)) && (!(t || !Ke(this, e) || !Ke(Ca, e) || Ke(this, Aa) && this[Aa][e]) || t)
        }, Ga = function (e, t) {
            if (e = K(e), t = qe(t, !0), e !== Ra || !Ke(Ca, t) || Ke(Ia, t)) {
                var i = _a(e, t);
                return !i || !Ke(Ca, t) || Ke(e, Aa) && e[Aa][t] || (i.enumerable = !0), i
            }
        }, ja = function (e) {
            for (var t, i = ba(K(e)), n = [], r = 0; i.length > r;) Ke(Ca, t = i[r++]) || t == Aa || t == ya || n.push(t);
            return n
        }, Va = function (e) {
            for (var t, i = e === Ra, n = ba(i ? Ia : K(e)), r = [], a = 0; n.length > a;) !Ke(Ca, t = n[a++]) || i && !Ke(Ra, t) || r.push(Ca[t]);
            return r
        };
    Oa || (w((wa = function () {
        if (this instanceof wa) throw TypeError("Symbol is not a constructor!");
        var t = $e(0 < arguments.length ? arguments[0] : void 0), i = function (e) {
            this === Ra && i.call(Ia, e), Ke(this, Aa) && Ke(this[Aa], t) && (this[Aa][t] = !1), ka(this, t, Ze(1, e))
        };
        return Ye && Na && ka(Ra, t, {configurable: !0, set: i}), Ua(t)
    })[Ea], "toString", function () {
        return this._k
    }), Xt.f = Ga, Qe.f = za, vi.f = pn.f = ja, jt.f = Ha, Zi.f = Va, Ye && w(Ra, "propertyIsEnumerable", Ha, !0), ma.f = function (e) {
        return Ua(st(e))
    }), tt(tt.G + tt.W + tt.F * !Oa, {Symbol: wa});
    for (var Xa = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), Wa = 0; Xa.length > Wa;) st(Xa[Wa++]);
    for (var Ya = ce(st.store), qa = 0; Ya.length > qa;) va(Ya[qa++]);
    tt(tt.S + tt.F * !Oa, "Symbol", {
        for: function (e) {
            return Ke(La, e += "") ? La[e] : La[e] = wa(e)
        }, keyFor: function (e) {
            if (!Da(e)) throw TypeError(e + " is not a symbol!");
            for (var t in La) if (La[t] === e) return t
        }, useSetter: function () {
            Na = !0
        }, useSimple: function () {
            Na = !1
        }
    }), tt(tt.S + tt.F * !Oa, "Object", {
        create: function (e, t) {
            return void 0 === t ? gt(e) : Ba(gt(e), t)
        },
        defineProperty: za,
        defineProperties: Ba,
        getOwnPropertyDescriptor: Ga,
        getOwnPropertyNames: ja,
        getOwnPropertySymbols: Va
    }), Ta && tt(tt.S + tt.F * (!Oa || We(function () {
        var e = wa();
        return "[null]" != Sa([e]) || "{}" != Sa({a: e}) || "{}" != Sa(Object(e))
    })), "JSON", {
        stringify: function (e) {
            for (var t, i, n = [e], r = 1; arguments.length > r;) n.push(arguments[r++]);
            if (i = t = n[1], (Xe(t) || void 0 !== e) && !Da(e)) return L(t) || (t = function (e, t) {
                if ("function" == typeof i && (t = i.call(this, e, t)), !Da(t)) return t
            }), n[1] = t, Sa.apply(Ta, n)
        }
    }), wa[Ea][Ma] || Je(wa[Ea], Ma, wa[Ea].valueOf), xe(wa, "Symbol"), xe(Math, "Math", !0), xe(Ve.JSON, "JSON", !0), va("asyncIterator");
    var Qa = /"/g, Za = function (e, t, i, n) {
        var r = String(p(e)), a = "<" + t;
        return "" !== i && (a += " " + i + '="' + String(n).replace(Qa, "&quot;") + '"'), a + ">" + r + "</" + t + ">"
    }, Ja = function (t, e) {
        var i = {};
        i[t] = e(Za), tt(tt.P + tt.F * We(function () {
            var e = ""[t]('"');
            return e !== e.toLowerCase() || 3 < e.split('"').length
        }), "String", i)
    };
    Ja("anchor", function (t) {
        return function (e) {
            return t(this, "a", "name", e)
        }
    }), Ja("big", function (e) {
        return function () {
            return e(this, "big", "", "")
        }
    }), Ja("blink", function (e) {
        return function () {
            return e(this, "blink", "", "")
        }
    }), Ja("bold", function (e) {
        return function () {
            return e(this, "b", "", "")
        }
    });
    var Ka = zr(!1);
    tt(tt.P, "String", {
        codePointAt: function (e) {
            return Ka(this, e)
        }
    });
    var $a = function (e, t, i) {
        if (Sr(t)) throw TypeError("String#" + i + " doesn't accept regex!");
        return String(p(e))
    }, eo = st("match"), to = function (t) {
        var i = /./;
        try {
            "/./"[t](i)
        } catch (e) {
            try {
                return i[eo] = !1, !"/./"[t](i)
            } catch (e) {
            }
        }
        return !0
    }, io = "endsWith", no = ""[io];
    tt(tt.P + tt.F * to(io), "String", {
        endsWith: function (e) {
            var t = $a(this, e, io), i = 1 < arguments.length ? arguments[1] : void 0, n = at(t.length),
                r = void 0 === i ? n : Math.min(at(i), n), a = String(e);
            return no ? no.call(t, a, r) : t.slice(r - a.length, r) === a
        }
    }), Ja("fixed", function (e) {
        return function () {
            return e(this, "tt", "", "")
        }
    }), Ja("fontcolor", function (t) {
        return function (e) {
            return t(this, "font", "color", e)
        }
    }), Ja("fontsize", function (t) {
        return function (e) {
            return t(this, "font", "size", e)
        }
    });
    var ro = String.fromCharCode, ao = String.fromCodePoint;
    tt(tt.S + tt.F * (!!ao && 1 != ao.length), "String", {
        fromCodePoint: function (e) {
            for (var t, i = [], n = arguments.length, r = 0; r < n;) {
                if (t = +arguments[r++], rt(t, 1114111) !== t) throw RangeError(t + " is not a valid code point");
                i.push(t < 65536 ? ro(t) : ro(55296 + ((t -= 65536) >> 10), t % 1024 + 56320))
            }
            return i.join("")
        }
    });
    var oo = "includes";
    tt(tt.P + tt.F * to(oo), "String", {
        includes: function (e) {
            return !!~$a(this, e, oo).indexOf(e, 1 < arguments.length ? arguments[1] : void 0)
        }
    }), Ja("italics", function (e) {
        return function () {
            return e(this, "i", "", "")
        }
    });
    var so = zr(!0);
    Pe(String, "String", function (e) {
        this._t = String(e), this._i = 0
    }, function () {
        var e, t = this._t, i = this._i;
        return i >= t.length ? {value: void 0, done: !0} : (e = so(t, i), this._i += e.length, {value: e, done: !1})
    }), Ja("link", function (t) {
        return function (e) {
            return t(this, "a", "href", e)
        }
    });
    var lo = function (e) {
        var t = String(p(this)), i = "", n = nt(e);
        if (n < 0 || n == 1 / 0) throw RangeError("Count can't be negative");
        for (; 0 < n; (n >>>= 1) && (t += t)) 1 & n && (i += t);
        return i
    }, ho = function (e, t, i, n) {
        var r = String(p(e)), a = r.length, o = void 0 === i ? " " : String(i), s = at(t);
        if (s <= a || "" == o) return r;
        var l = s - a, h = lo.call(o, Math.ceil(l / o.length));
        return h.length > l && (h = h.slice(0, l)), n ? h + r : r + h
    };
    tt(tt.P + tt.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(qn), "String", {
        padStart: function (e) {
            return ho(this, e, 1 < arguments.length ? arguments[1] : void 0, !0)
        }
    }), tt(tt.P + tt.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(qn), "String", {
        padEnd: function (e) {
            return ho(this, e, 1 < arguments.length ? arguments[1] : void 0, !1)
        }
    }), tt(tt.S, "String", {
        raw: function (e) {
            for (var t = K(e.raw), i = at(t.length), n = arguments.length, r = [], a = 0; a < i;) r.push(String(t[a++])), a < n && r.push(String(arguments[a]));
            return r.join("")
        }
    }), tt(tt.P, "String", {repeat: lo}), Ja("small", function (e) {
        return function () {
            return e(this, "small", "", "")
        }
    });
    var co = "startsWith", uo = ""[co];
    tt(tt.P + tt.F * to(co), "String", {
        startsWith: function (e) {
            var t = $a(this, e, co), i = at(Math.min(1 < arguments.length ? arguments[1] : void 0, t.length)),
                n = String(e);
            return uo ? uo.call(t, n, i) : t.slice(i, i + n.length) === n
        }
    }), Ja("strike", function (e) {
        return function () {
            return e(this, "strike", "", "")
        }
    }), Ja("sub", function (e) {
        return function () {
            return e(this, "sub", "", "")
        }
    }), Ja("sup", function (e) {
        return function () {
            return e(this, "sup", "", "")
        }
    }), Si("trim", function (e) {
        return function () {
            return e(this, 3)
        }
    });
    for (var po, fo = $e("typed_array"), mo = $e("view"), go = !(!Ve.ArrayBuffer || !Ve.DataView), vo = go, yo = 0, _o = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); yo < 9;) (po = Ve[_o[yo++]]) ? (Je(po.prototype, fo, !0), Je(po.prototype, mo, !0)) : vo = !1;
    var xo = {ABV: go, CONSTR: vo, TYPED: fo, VIEW: mo}, bo = function (e) {
            if (void 0 === e) return 0;
            var t = nt(e), i = at(t);
            if (t !== i) throw RangeError("Wrong length!");
            return i
        }, wo = e(function (e, t) {
            var i = vi.f, n = Qe.f, r = "ArrayBuffer", a = "DataView", o = "prototype", u = "Wrong index!", s = Ve[r],
                l = Ve[a], h = Ve.Math, p = Ve.RangeError, d = Ve.Infinity, c = s, f = h.abs, m = h.pow, g = h.floor,
                v = h.log, y = h.LN2, _ = "byteLength", x = "byteOffset", b = Ye ? "_b" : "buffer", w = Ye ? "_l" : _,
                T = Ye ? "_o" : x;

            function S(e, t, i) {
                var n, r, a, o = new Array(i), s = 8 * i - t - 1, l = (1 << s) - 1, h = l >> 1,
                    c = 23 === t ? m(2, -24) - m(2, -77) : 0, u = 0, p = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                for ((e = f(e)) != e || e === d ? (r = e != e ? 1 : 0, n = l) : (n = g(v(e) / y), e * (a = m(2, -n)) < 1 && (n--, a *= 2), 2 <= (e += 1 <= n + h ? c / a : c * m(2, 1 - h)) * a && (n++, a /= 2), l <= n + h ? (r = 0, n = l) : 1 <= n + h ? (r = (e * a - 1) * m(2, t), n += h) : (r = e * m(2, h - 1) * m(2, t), n = 0)); 8 <= t; o[u++] = 255 & r, r /= 256, t -= 8) ;
                for (n = n << t | r, s += t; 0 < s; o[u++] = 255 & n, n /= 256, s -= 8) ;
                return o[--u] |= 128 * p, o
            }

            function E(e, t, i) {
                var n, r = 8 * i - t - 1, a = (1 << r) - 1, o = a >> 1, s = r - 7, l = i - 1, h = e[l--], c = 127 & h;
                for (h >>= 7; 0 < s; c = 256 * c + e[l], l--, s -= 8) ;
                for (n = c & (1 << -s) - 1, c >>= -s, s += t; 0 < s; n = 256 * n + e[l], l--, s -= 8) ;
                if (0 === c) c = 1 - o; else {
                    if (c === a) return n ? NaN : h ? -d : d;
                    n += m(2, t), c -= o
                }
                return (h ? -1 : 1) * n * m(2, c - t)
            }

            function A(e) {
                return e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0]
            }

            function M(e) {
                return [255 & e]
            }

            function P(e) {
                return [255 & e, e >> 8 & 255]
            }

            function L(e) {
                return [255 & e, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]
            }

            function C(e) {
                return S(e, 52, 8)
            }

            function I(e) {
                return S(e, 23, 4)
            }

            function R(e, t, i) {
                n(e[o], t, {
                    get: function () {
                        return this[i]
                    }
                })
            }

            function O(e, t, i, n) {
                var r = bo(+i);
                if (r + t > e[w]) throw p(u);
                var a = e[b]._b, o = r + e[T], s = a.slice(o, o + t);
                return n ? s : s.reverse()
            }

            function F(e, t, i, n, r, a) {
                var o = bo(+i);
                if (o + t > e[w]) throw p(u);
                for (var s = e[b]._b, l = o + e[T], h = n(+r), c = 0; c < t; c++) s[l + c] = h[a ? c : t - c - 1]
            }

            if (xo.ABV) {
                if (!We(function () {
                    s(1)
                }) || !We(function () {
                    new s(-1)
                }) || We(function () {
                    return new s, new s(1.5), new s(NaN), s.name != r
                })) {
                    for (var N, k = (s = function (e) {
                        return Ft(this, s), new c(bo(e))
                    })[o] = c[o], U = i(c), D = 0; U.length > D;) (N = U[D++]) in s || Je(s, N, c[N]);
                    k.constructor = s
                }
                var z = new l(new s(2)), B = l[o].setInt8;
                z.setInt8(0, 2147483648), z.setInt8(1, 2147483649), !z.getInt8(0) && z.getInt8(1) || Ot(l[o], {
                    setInt8: function (e, t) {
                        B.call(this, e, t << 24 >> 24)
                    }, setUint8: function (e, t) {
                        B.call(this, e, t << 24 >> 24)
                    }
                }, !0)
            } else s = function (e) {
                Ft(this, s, r);
                var t = bo(e);
                this._b = ht.call(new Array(t), 0), this[w] = t
            }, l = function (e, t, i) {
                Ft(this, l, a), Ft(e, s, a);
                var n = e[w], r = nt(t);
                if (r < 0 || n < r) throw p("Wrong offset!");
                if (n < r + (i = void 0 === i ? n - r : at(i))) throw p("Wrong length!");
                this[b] = e, this[T] = r, this[w] = i
            }, Ye && (R(s, _, "_l"), R(l, "buffer", "_b"), R(l, _, "_l"), R(l, x, "_o")), Ot(l[o], {
                getInt8: function (e) {
                    return O(this, 1, e)[0] << 24 >> 24
                }, getUint8: function (e) {
                    return O(this, 1, e)[0]
                }, getInt16: function (e) {
                    var t = O(this, 2, e, arguments[1]);
                    return (t[1] << 8 | t[0]) << 16 >> 16
                }, getUint16: function (e) {
                    var t = O(this, 2, e, arguments[1]);
                    return t[1] << 8 | t[0]
                }, getInt32: function (e) {
                    return A(O(this, 4, e, arguments[1]))
                }, getUint32: function (e) {
                    return A(O(this, 4, e, arguments[1])) >>> 0
                }, getFloat32: function (e) {
                    return E(O(this, 4, e, arguments[1]), 23, 4)
                }, getFloat64: function (e) {
                    return E(O(this, 8, e, arguments[1]), 52, 8)
                }, setInt8: function (e, t) {
                    F(this, 1, e, M, t)
                }, setUint8: function (e, t) {
                    F(this, 1, e, M, t)
                }, setInt16: function (e, t) {
                    F(this, 2, e, P, t, arguments[2])
                }, setUint16: function (e, t) {
                    F(this, 2, e, P, t, arguments[2])
                }, setInt32: function (e, t) {
                    F(this, 4, e, L, t, arguments[2])
                }, setUint32: function (e, t) {
                    F(this, 4, e, L, t, arguments[2])
                }, setFloat32: function (e, t) {
                    F(this, 4, e, I, t, arguments[2])
                }, setFloat64: function (e, t) {
                    F(this, 8, e, C, t, arguments[2])
                }
            });
            xe(s, r), xe(l, a), Je(l[o], xo.VIEW, !0), t[r] = s, t[a] = l
        }), To = Ve.ArrayBuffer, So = wo.ArrayBuffer, Eo = wo.DataView, Ao = xo.ABV && To.isView, Mo = So.prototype.slice,
        Po = xo.VIEW, Lo = "ArrayBuffer";
    tt(tt.G + tt.W + tt.F * (To !== So), {ArrayBuffer: So}), tt(tt.S + tt.F * !xo.CONSTR, Lo, {
        isView: function (e) {
            return Ao && Ao(e) || Xe(e) && Po in e
        }
    }), tt(tt.P + tt.U + tt.F * We(function () {
        return !new So(2).slice(1, void 0).byteLength
    }), Lo, {
        slice: function (e, t) {
            if (void 0 !== Mo && void 0 === t) return Mo.call(S(this), e);
            for (var i = S(this).byteLength, n = rt(e, i), r = rt(void 0 === t ? i : t, i), a = new (Tn(this, So))(at(r - n)), o = new Eo(this), s = new Eo(a), l = 0; n < r;) s.setUint8(l++, o.getUint8(n++));
            return a
        }
    }), _t(Lo), tt(tt.G + tt.W + tt.F * !xo.ABV, {DataView: wo.DataView});
    var Co = e(function (e) {
        if (Ye) {
            var v = Ve, y = We, _ = tt, x = xo, t = wo, p = et, b = Ft, i = Ze, w = Je, n = Ot, r = nt, T = at, S = bo,
                a = rt, o = qe, s = Ke, E = pt, A = Xe, d = it, f = ut, M = gt, P = vt, L = vi.f, m = dt, l = $e,
                h = st, c = lt, u = mt, g = Tn, C = yt, I = ct, R = ft, O = _t, F = ht, N = ot, k = Qe, U = Xt, D = k.f,
                z = U.f, B = v.RangeError, H = v.TypeError, G = v.Uint8Array, j = "ArrayBuffer", V = "Shared" + j,
                X = "BYTES_PER_ELEMENT", W = "prototype", Y = Array[W], q = t.ArrayBuffer, Q = t.DataView, Z = c(0),
                J = c(2), K = c(3), $ = c(4), ee = c(5), te = c(6), ie = u(!0), ne = u(!1), re = C.values, ae = C.keys,
                oe = C.entries, se = Y.lastIndexOf, le = Y.reduce, he = Y.reduceRight, ce = Y.join, ue = Y.sort,
                pe = Y.slice, de = Y.toString, fe = Y.toLocaleString, me = h("iterator"), ge = h("toStringTag"),
                ve = l("typed_constructor"), ye = l("def_constructor"), _e = x.CONSTR, xe = x.TYPED, be = x.VIEW,
                we = "Wrong length!", Te = c(1, function (e, t) {
                    return Pe(g(e, e[ye]), t)
                }), Se = y(function () {
                    return 1 === new G(new Uint16Array([1]).buffer)[0]
                }), Ee = !!G && !!G[W].set && y(function () {
                    new G(1).set({})
                }), Ae = function (e, t) {
                    var i = r(e);
                    if (i < 0 || i % t) throw B("Wrong offset!");
                    return i
                }, Me = function (e) {
                    if (A(e) && xe in e) return e;
                    throw H(e + " is not a typed array!")
                }, Pe = function (e, t) {
                    if (!(A(e) && ve in e)) throw H("It is not a typed array constructor!");
                    return new e(t)
                }, Le = function (e, t) {
                    return Ce(g(e, e[ye]), t)
                }, Ce = function (e, t) {
                    for (var i = 0, n = t.length, r = Pe(e, n); i < n;) r[i] = t[i++];
                    return r
                }, Ie = function (e, t, i) {
                    D(e, t, {
                        get: function () {
                            return this._d[i]
                        }
                    })
                }, Re = function (e) {
                    var t, i, n, r, a, o, s = d(e), l = arguments.length, h = 1 < l ? arguments[1] : void 0,
                        c = void 0 !== h, u = m(s);
                    if (null != u && !f(u)) {
                        for (o = u.call(s), n = [], t = 0; !(a = o.next()).done; t++) n.push(a.value);
                        s = n
                    }
                    for (c && 2 < l && (h = p(h, arguments[2], 2)), t = 0, i = T(s.length), r = Pe(this, i); t < i; t++) r[t] = c ? h(s[t], t) : s[t];
                    return r
                }, Oe = function () {
                    for (var e = 0, t = arguments.length, i = Pe(this, t); e < t;) i[e] = arguments[e++];
                    return i
                }, Fe = !!G && y(function () {
                    fe.call(new G(1))
                }), Ne = function () {
                    return fe.apply(Fe ? pe.call(Me(this)) : Me(this), arguments)
                }, ke = {
                    copyWithin: function (e, t) {
                        return N.call(Me(this), e, t, 2 < arguments.length ? arguments[2] : void 0)
                    }, every: function (e) {
                        return $(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, fill: function (e) {
                        return F.apply(Me(this), arguments)
                    }, filter: function (e) {
                        return Le(this, J(Me(this), e, 1 < arguments.length ? arguments[1] : void 0))
                    }, find: function (e) {
                        return ee(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, findIndex: function (e) {
                        return te(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, forEach: function (e) {
                        Z(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, indexOf: function (e) {
                        return ne(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, includes: function (e) {
                        return ie(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, join: function (e) {
                        return ce.apply(Me(this), arguments)
                    }, lastIndexOf: function (e) {
                        return se.apply(Me(this), arguments)
                    }, map: function (e) {
                        return Te(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, reduce: function (e) {
                        return le.apply(Me(this), arguments)
                    }, reduceRight: function (e) {
                        return he.apply(Me(this), arguments)
                    }, reverse: function () {
                        for (var e, t = this, i = Me(t).length, n = Math.floor(i / 2), r = 0; r < n;) e = t[r], t[r++] = t[--i], t[i] = e;
                        return t
                    }, some: function (e) {
                        return K(Me(this), e, 1 < arguments.length ? arguments[1] : void 0)
                    }, sort: function (e) {
                        return ue.call(Me(this), e)
                    }, subarray: function (e, t) {
                        var i = Me(this), n = i.length, r = a(e, n);
                        return new (g(i, i[ye]))(i.buffer, i.byteOffset + r * i.BYTES_PER_ELEMENT, T((void 0 === t ? n : a(t, n)) - r))
                    }
                }, Ue = function (e, t) {
                    return Le(this, pe.call(Me(this), e, t))
                }, De = function (e) {
                    Me(this);
                    var t = Ae(arguments[1], 1), i = this.length, n = d(e), r = T(n.length), a = 0;
                    if (i < r + t) throw B(we);
                    for (; a < r;) this[t + a] = n[a++]
                }, ze = {
                    entries: function () {
                        return oe.call(Me(this))
                    }, keys: function () {
                        return ae.call(Me(this))
                    }, values: function () {
                        return re.call(Me(this))
                    }
                }, Be = function (e, t) {
                    return A(e) && e[xe] && "symbol" != typeof t && t in e && String(+t) == String(t)
                }, He = function (e, t) {
                    return Be(e, t = o(t, !0)) ? i(2, e[t]) : z(e, t)
                }, Ge = function (e, t, i) {
                    return !(Be(e, t = o(t, !0)) && A(i) && s(i, "value")) || s(i, "get") || s(i, "set") || i.configurable || s(i, "writable") && !i.writable || s(i, "enumerable") && !i.enumerable ? D(e, t, i) : (e[t] = i.value, e)
                };
            _e || (U.f = He, k.f = Ge), _(_.S + _.F * !_e, "Object", {
                getOwnPropertyDescriptor: He, defineProperty: Ge
            }), y(function () {
                de.call({})
            }) && (de = fe = function () {
                return ce.call(this)
            });
            var je = n({}, ke);
            n(je, ze), w(je, me, ze.values), n(je, {
                slice: Ue, set: De, constructor: function () {
                }, toString: de, toLocaleString: Ne
            }), Ie(je, "buffer", "b"), Ie(je, "byteOffset", "o"), Ie(je, "byteLength", "l"), Ie(je, "length", "e"), D(je, ge, {
                get: function () {
                    return this[xe]
                }
            }), e.exports = function (e, u, t, a) {
                var p = e + ((a = !!a) ? "Clamped" : "") + "Array", i = "get" + e, o = "set" + e, d = v[p], s = d || {},
                    n = d && P(d), r = !d || !x.ABV, l = {}, h = d && d[W], f = function (e, r) {
                        D(e, r, {
                            get: function () {
                                return e = r, (t = this._d).v[i](e * u + t.o, Se);
                                var e, t
                            }, set: function (e) {
                                return t = r, i = e, n = this._d, a && (i = (i = Math.round(i)) < 0 ? 0 : 255 < i ? 255 : 255 & i), void n.v[o](t * u + n.o, i, Se);
                                var t, i, n
                            }, enumerable: !0
                        })
                    };
                r ? (d = t(function (e, t, i, n) {
                    b(e, d, p, "_d");
                    var r, a, o, s, l = 0, h = 0;
                    if (A(t)) {
                        if (!(t instanceof q || (s = E(t)) == j || s == V)) return xe in t ? Ce(d, t) : Re.call(d, t);
                        r = t, h = Ae(i, u);
                        var c = t.byteLength;
                        if (void 0 === n) {
                            if (c % u) throw B(we);
                            if ((a = c - h) < 0) throw B(we)
                        } else if (c < (a = T(n) * u) + h) throw B(we);
                        o = a / u
                    } else o = S(t), r = new q(a = o * u);
                    for (w(e, "_d", {b: r, o: h, l: a, e: o, v: new Q(r)}); l < o;) f(e, l++)
                }), h = d[W] = M(je), w(h, "constructor", d)) : y(function () {
                    d(1)
                }) && y(function () {
                    new d(-1)
                }) && R(function (e) {
                    new d, new d(null), new d(1.5), new d(e)
                }, !0) || (d = t(function (e, t, i, n) {
                    var r;
                    return b(e, d, p), A(t) ? t instanceof q || (r = E(t)) == j || r == V ? void 0 !== n ? new s(t, Ae(i, u), n) : void 0 !== i ? new s(t, Ae(i, u)) : new s(t) : xe in t ? Ce(d, t) : Re.call(d, t) : new s(S(t))
                }), Z(n !== Function.prototype ? L(s).concat(L(n)) : L(s), function (e) {
                    e in d || w(d, e, s[e])
                }), (d[W] = h).constructor = d);
                var c = h[me], m = !!c && ("values" == c.name || null == c.name), g = ze.values;
                w(d, ve, !0), w(h, xe, p), w(h, be, !0), w(h, ye, d), (a ? new d(1)[ge] == p : ge in h) || D(h, ge, {
                    get: function () {
                        return p
                    }
                }), l[p] = d, _(_.G + _.W + _.F * (d != s), l), _(_.S, p, {BYTES_PER_ELEMENT: u}), _(_.S + _.F * y(function () {
                    s.of.call(d, 1)
                }), p, {
                    from: Re, of: Oe
                }), X in h || w(h, X, u), _(_.P, p, ke), O(p), _(_.P + _.F * Ee, p, {set: De}), _(_.P + _.F * !m, p, ze), h.toString != de && (h.toString = de), _(_.P + _.F * y(function () {
                    new d(1).slice()
                }), p, {slice: Ue}), _(_.P + _.F * (y(function () {
                    return [1, 2].toLocaleString() != new d([1, 2]).toLocaleString()
                }) || !y(function () {
                    h.toLocaleString.call([1, 2])
                })), p, {toLocaleString: Ne}), I[p] = m ? c : g, m || w(h, me, g)
            }
        } else e.exports = function () {
        }
    });
    Co("Int8", 1, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Uint8", 1, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Uint8", 1, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }, !0), Co("Int16", 2, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Uint16", 2, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Int32", 4, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Uint32", 4, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Float32", 4, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    }), Co("Float64", 8, function (n) {
        return function (e, t, i) {
            return n(this, e, t, i)
        }
    });
    var Io = kt.getWeak, Ro = lt(5), Oo = lt(6), Fo = 0, No = function (e) {
        return e._l || (e._l = new ko)
    }, ko = function () {
        this.a = []
    }, Uo = function (e, t) {
        return Ro(e.a, function (e) {
            return e[0] === t
        })
    };
    ko.prototype = {
        get: function (e) {
            var t = Uo(this, e);
            if (t) return t[1]
        }, has: function (e) {
            return !!Uo(this, e)
        }, set: function (e, t) {
            var i = Uo(this, e);
            i ? i[1] = t : this.a.push([e, t])
        }, delete: function (t) {
            var e = Oo(this.a, function (e) {
                return e[0] === t
            });
            return ~e && this.a.splice(e, 1), !!~e
        }
    };
    var Do = {
        getConstructor: function (e, i, n, r) {
            var a = e(function (e, t) {
                Ft(e, a, i, "_i"), e._t = i, e._i = Fo++, e._l = void 0, null != t && Nt(t, n, e[r], e)
            });
            return Ot(a.prototype, {
                delete: function (e) {
                    if (!Xe(e)) return !1;
                    var t = Io(e);
                    return !0 === t ? No(Ut(this, i)).delete(e) : t && Ke(t, this._i) && delete t[this._i]
                }, has: function (e) {
                    if (!Xe(e)) return !1;
                    var t = Io(e);
                    return !0 === t ? No(Ut(this, i)).has(e) : t && Ke(t, this._i)
                }
            }), a
        }, def: function (e, t, i) {
            var n = Io(S(t), !0);
            return !0 === n ? No(e).set(t, i) : n[e._i] = i, e
        }, ufstore: No
    }, zo = (e(function (e) {
        var a, t = lt(0), i = "WeakMap", n = kt.getWeak, o = Object.isExtensible, r = Do.ufstore, s = {},
            l = function (e) {
                return function () {
                    return e(this, 0 < arguments.length ? arguments[0] : void 0)
                }
            }, h = {
                get: function (e) {
                    if (Xe(e)) {
                        var t = n(e);
                        return !0 === t ? r(Ut(this, i)).get(e) : t ? t[this._i] : void 0
                    }
                }, set: function (e, t) {
                    return Do.def(Ut(this, i), e, t)
                }
            }, c = e.exports = Zt(i, l, h, Do, !0, !0);
        We(function () {
            return 7 != (new c).set((Object.freeze || Object)(s), 7).get(s)
        }) && (a = Do.getConstructor(l, i), Ki(a.prototype, h), kt.NEED = !0, t(["delete", "has", "get", "set"], function (n) {
            var e = c.prototype, r = e[n];
            w(e, n, function (e, t) {
                if (!Xe(e) || o(e)) return r.call(this, e, t);
                this._f || (this._f = new a);
                var i = this._f[n](e, t);
                return "set" == n ? this : i
            })
        }))
    }), "WeakSet");
    Zt(zo, function (e) {
        return function () {
            return e(this, 0 < arguments.length ? arguments[0] : void 0)
        }
    }, {
        add: function (e) {
            return Do.def(Ut(this, zo), e, !0)
        }
    }, Do, !1, !0);
    var Bo = [].slice, Ho = /MSIE .\./.test(qn), Go = function (r) {
        return function (e, t) {
            var i = 2 < arguments.length, n = !!i && Bo.call(arguments, 2);
            return r(i ? function () {
                ("function" == typeof e ? e : Function(e)).apply(this, n)
            } : e, t)
        }
    };
    tt(tt.G + tt.B + tt.F * Ho, {
        setTimeout: Go(Ve.setTimeout), setInterval: Go(Ve.setInterval)
    }), tt(tt.G + tt.B, {setImmediate: Fn.set, clearImmediate: Fn.clear});
    for (var jo = st("iterator"), Vo = st("toStringTag"), Xo = ct.Array, Wo = {
        CSSRuleList: !0,
        CSSStyleDeclaration: !1,
        CSSValueList: !1,
        ClientRectList: !1,
        DOMRectList: !1,
        DOMStringList: !1,
        DOMTokenList: !0,
        DataTransferItemList: !1,
        FileList: !1,
        HTMLAllCollection: !1,
        HTMLCollection: !1,
        HTMLFormElement: !1,
        HTMLSelectElement: !1,
        MediaList: !0,
        MimeTypeArray: !1,
        NamedNodeMap: !1,
        NodeList: !0,
        PaintRequestList: !1,
        Plugin: !1,
        PluginArray: !1,
        SVGLengthList: !1,
        SVGNumberList: !1,
        SVGPathSegList: !1,
        SVGPointList: !1,
        SVGStringList: !1,
        SVGTransformList: !1,
        SourceBufferList: !1,
        StyleSheetList: !0,
        TextTrackCueList: !1,
        TextTrackList: !1,
        TouchList: !1
    }, Yo = ce(Wo), qo = 0; qo < Yo.length; qo++) {
        var Qo, Zo = Yo[qo], Jo = Wo[Zo], Ko = Ve[Zo], $o = Ko && Ko.prototype;
        if ($o && ($o[jo] || Je($o, jo, Xo), $o[Vo] || Je($o, Vo, Zo), ct[Zo] = Xo, Jo)) for (Qo in yt) $o[Qo] || w($o, Qo, yt[Qo], !0)
    }
    e(function (I) {
        !function (e) {
            var l, t = Object.prototype, h = t.hasOwnProperty, i = "function" == typeof Symbol ? Symbol : {},
                r = i.iterator || "@@iterator", n = i.asyncIterator || "@@asyncIterator",
                a = i.toStringTag || "@@toStringTag", o = e.regeneratorRuntime;
            if (o) I.exports = o; else {
                (o = e.regeneratorRuntime = I.exports).wrap = y;
                var u = "suspendedStart", p = "suspendedYield", d = "executing", f = "completed", m = {}, s = {};
                s[r] = function () {
                    return this
                };
                var c = Object.getPrototypeOf, g = c && c(c(L([])));
                g && g !== t && h.call(g, r) && (s = g);
                var v = w.prototype = x.prototype = Object.create(s);
                b.prototype = v.constructor = w, w.constructor = b, w[a] = b.displayName = "GeneratorFunction", o.isGeneratorFunction = function (e) {
                    var t = "function" == typeof e && e.constructor;
                    return !!t && (t === b || "GeneratorFunction" === (t.displayName || t.name))
                }, o.mark = function (e) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(e, w) : (e.__proto__ = w, a in e || (e[a] = "GeneratorFunction")), e.prototype = Object.create(v), e
                }, o.awrap = function (e) {
                    return {__await: e}
                }, T(S.prototype), S.prototype[n] = function () {
                    return this
                }, o.AsyncIterator = S, o.async = function (e, t, i, n) {
                    var r = new S(y(e, t, i, n));
                    return o.isGeneratorFunction(t) ? r : r.next().then(function (e) {
                        return e.done ? e.value : r.next()
                    })
                }, T(v), v[a] = "Generator", v[r] = function () {
                    return this
                }, v.toString = function () {
                    return "[object Generator]"
                }, o.keys = function (i) {
                    var n = [];
                    for (var e in i) n.push(e);
                    return n.reverse(), function e() {
                        for (; n.length;) {
                            var t = n.pop();
                            if (t in i) return e.value = t, e.done = !1, e
                        }
                        return e.done = !0, e
                    }
                }, o.values = L, P.prototype = {
                    constructor: P, reset: function (e) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = !1, this.delegate = null, this.method = "next", this.arg = l, this.tryEntries.forEach(M), !e) for (var t in this) "t" === t.charAt(0) && h.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = l)
                    }, stop: function () {
                        this.done = !0;
                        var e = this.tryEntries[0].completion;
                        if ("throw" === e.type) throw e.arg;
                        return this.rval
                    }, dispatchException: function (i) {
                        if (this.done) throw i;
                        var n = this;

                        function e(e, t) {
                            return a.type = "throw", a.arg = i, n.next = e, t && (n.method = "next", n.arg = l), !!t
                        }

                        for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                            var r = this.tryEntries[t], a = r.completion;
                            if ("root" === r.tryLoc) return e("end");
                            if (r.tryLoc <= this.prev) {
                                var o = h.call(r, "catchLoc"), s = h.call(r, "finallyLoc");
                                if (o && s) {
                                    if (this.prev < r.catchLoc) return e(r.catchLoc, !0);
                                    if (this.prev < r.finallyLoc) return e(r.finallyLoc)
                                } else if (o) {
                                    if (this.prev < r.catchLoc) return e(r.catchLoc, !0)
                                } else {
                                    if (!s) throw new Error("try statement without catch or finally");
                                    if (this.prev < r.finallyLoc) return e(r.finallyLoc)
                                }
                            }
                        }
                    }, abrupt: function (e, t) {
                        for (var i = this.tryEntries.length - 1; 0 <= i; --i) {
                            var n = this.tryEntries[i];
                            if (n.tryLoc <= this.prev && h.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                                var r = n;
                                break
                            }
                        }
                        r && ("break" === e || "continue" === e) && r.tryLoc <= t && t <= r.finallyLoc && (r = null);
                        var a = r ? r.completion : {};
                        return a.type = e, a.arg = t, r ? (this.method = "next", this.next = r.finallyLoc, m) : this.complete(a)
                    }, complete: function (e, t) {
                        if ("throw" === e.type) throw e.arg;
                        return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), m
                    }, finish: function (e) {
                        for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                            var i = this.tryEntries[t];
                            if (i.finallyLoc === e) return this.complete(i.completion, i.afterLoc), M(i), m
                        }
                    }, catch: function (e) {
                        for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                            var i = this.tryEntries[t];
                            if (i.tryLoc === e) {
                                var n = i.completion;
                                if ("throw" === n.type) {
                                    var r = n.arg;
                                    M(i)
                                }
                                return r
                            }
                        }
                        throw new Error("illegal catch attempt")
                    }, delegateYield: function (e, t, i) {
                        return this.delegate = {
                            iterator: L(e), resultName: t, nextLoc: i
                        }, "next" === this.method && (this.arg = l), m
                    }
                }
            }

            function y(e, t, i, n) {
                var a, o, s, l, r = t && t.prototype instanceof x ? t : x, h = Object.create(r.prototype),
                    c = new P(n || []);
                return h._invoke = (a = e, o = i, s = c, l = u, function (e, t) {
                    if (l === d) throw new Error("Generator is already running");
                    if (l === f) {
                        if ("throw" === e) throw t;
                        return C()
                    }
                    for (s.method = e, s.arg = t; ;) {
                        var i = s.delegate;
                        if (i) {
                            var n = E(i, s);
                            if (n) {
                                if (n === m) continue;
                                return n
                            }
                        }
                        if ("next" === s.method) s.sent = s._sent = s.arg; else if ("throw" === s.method) {
                            if (l === u) throw l = f, s.arg;
                            s.dispatchException(s.arg)
                        } else "return" === s.method && s.abrupt("return", s.arg);
                        l = d;
                        var r = _(a, o, s);
                        if ("normal" === r.type) {
                            if (l = s.done ? f : p, r.arg === m) continue;
                            return {value: r.arg, done: s.done}
                        }
                        "throw" === r.type && (l = f, s.method = "throw", s.arg = r.arg)
                    }
                }), h
            }

            function _(e, t, i) {
                try {
                    return {type: "normal", arg: e.call(t, i)}
                } catch (e) {
                    return {type: "throw", arg: e}
                }
            }

            function x() {
            }

            function b() {
            }

            function w() {
            }

            function T(e) {
                ["next", "throw", "return"].forEach(function (t) {
                    e[t] = function (e) {
                        return this._invoke(t, e)
                    }
                })
            }

            function S(l) {
                var t;
                this._invoke = function (i, n) {
                    function e() {
                        return new Promise(function (e, t) {
                            !function t(e, i, n, r) {
                                var a = _(l[e], l, i);
                                if ("throw" !== a.type) {
                                    var o = a.arg, s = o.value;
                                    return s && "object" == typeof s && h.call(s, "__await") ? Promise.resolve(s.__await).then(function (e) {
                                        t("next", e, n, r)
                                    }, function (e) {
                                        t("throw", e, n, r)
                                    }) : Promise.resolve(s).then(function (e) {
                                        o.value = e, n(o)
                                    }, function (e) {
                                        return t("throw", e, n, r)
                                    })
                                }
                                r(a.arg)
                            }(i, n, e, t)
                        })
                    }

                    return t = t ? t.then(e, e) : e()
                }
            }

            function E(e, t) {
                var i = e.iterator[t.method];
                if (i === l) {
                    if (t.delegate = null, "throw" === t.method) {
                        if (e.iterator.return && (t.method = "return", t.arg = l, E(e, t), "throw" === t.method)) return m;
                        t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
                    }
                    return m
                }
                var n = _(i, e.iterator, t.arg);
                if ("throw" === n.type) return t.method = "throw", t.arg = n.arg, t.delegate = null, m;
                var r = n.arg;
                return r ? r.done ? (t[e.resultName] = r.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = l), t.delegate = null, m) : r : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, m)
            }

            function A(e) {
                var t = {tryLoc: e[0]};
                1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
            }

            function M(e) {
                var t = e.completion || {};
                t.type = "normal", delete t.arg, e.completion = t
            }

            function P(e) {
                this.tryEntries = [{tryLoc: "root"}], e.forEach(A, this), this.reset(!0)
            }

            function L(t) {
                if (t) {
                    var e = t[r];
                    if (e) return e.call(t);
                    if ("function" == typeof t.next) return t;
                    if (!isNaN(t.length)) {
                        var i = -1, n = function e() {
                            for (; ++i < t.length;) if (h.call(t, i)) return e.value = t[i], e.done = !1, e;
                            return e.value = l, e.done = !0, e
                        };
                        return n.next = n
                    }
                }
                return {next: C}
            }

            function C() {
                return {value: l, done: !0}
            }
        }(function () {
            return this || "object" == typeof self && self
        }() || Function("return this")())
    });

    function es(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }

    function ts(e, t) {
        for (var i = 0; i < t.length; i++) {
            var n = t[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
        }
    }

    function is(e, t, i) {
        return t && ts(e.prototype, t), i && ts(e, i), e
    }

    function ns(e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e, writable: !0, configurable: !0
            }
        }), t && as(e, t)
    }

    function rs(e) {
        return (rs = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function as(e, t) {
        return (as = Object.setPrototypeOf || function (e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function os(e, t, i) {
        return (os = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }() ? Reflect.construct : function (e, t, i) {
            var n = [null];
            n.push.apply(n, t);
            var r = new (Function.bind.apply(e, n));
            return i && as(r, i.prototype), r
        }).apply(null, arguments)
    }

    function ss(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }

    function ls(e, t) {
        return !t || "object" != typeof t && "function" != typeof t ? ss(e) : t
    }

    function hs(e, t, i) {
        return (hs = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (e, t, i) {
            var n = function (e, t) {
                for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = rs(e));) ;
                return e
            }(e, t);
            if (n) {
                var r = Object.getOwnPropertyDescriptor(n, t);
                return r.get ? r.get.call(i) : r.value
            }
        })(e, t, i || e)
    }

    function cs(e) {
        return function (e) {
            if (Array.isArray(e)) {
                for (var t = 0, i = new Array(e.length); t < e.length; t++) i[t] = e[t];
                return i
            }
        }(e) || function (e) {
            if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e)) return Array.from(e)
        }(e) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance")
        }()
    }

    function us() {
    }

    us.prototype = {
        on: function (e, t, i) {
            var n = this.e || (this.e = {});
            return (n[e] || (n[e] = [])).push({fn: t, ctx: i}), this
        }, once: function (e, t, i) {
            var n = this;

            function r() {
                n.off(e, r), t.apply(i, arguments)
            }

            return r._ = t, this.on(e, r, i)
        }, emit: function (e) {
            for (var t = [].slice.call(arguments, 1), i = ((this.e || (this.e = {}))[e] || []).slice(), n = 0, r = i.length; n < r; n++) i[n].fn.apply(i[n].ctx, t);
            return this
        }, off: function (e, t) {
            var i = this.e || (this.e = {}), n = i[e], r = [];
            if (n && t) for (var a = 0, o = n.length; a < o; a++) n[a].fn !== t && n[a].fn._ !== t && r.push(n[a]);
            return r.length ? i[e] = r : delete i[e], this
        }
    };
    var ps = us, ds = function () {
            function i(e, t) {
                es(this, i), this.screen = e, this.isInstance = "function" != typeof e, this.internalInstance = null, this.arguments = null, this.properties = null, this.canDispose = !this.isInstance, this.events = null, this.hasEventsListeners = !1, this.setOptions(t)
            }

            return is(i, [{
                key: "setOptions", value: function (e) {
                    for (var t in e) void 0 !== this[t] && (this[t] = e[t])
                }
            }, {
                key: "getScreen", value: function () {
                    var e;
                    if (this.isInstance) e = this.screen; else if (this.internalInstance) e = this.internalInstance; else {
                        var t = this.arguments || [];
                        e = os(this.screen, cs(t)), this.canDispose || (this.internalInstance = e)
                    }
                    if (this.properties) for (var i in this.properties) e[i] = this.properties[i];
                    return this.events && this.addEventsListeners(e), e
                }
            }, {
                key: "addEventsListeners", value: function (e) {
                    if (!this.canDispose) {
                        if (this.hasEventsListeners) return;
                        this.hasEventsListeners = !0
                    }
                    for (var t in this.events) "function" == typeof this.events[t] && e.on(t, this.events[t])
                }
            }, {
                key: "removeEventsListeners", value: function (e) {
                    for (var t in this.hasEventsListeners = !1, this.events) "function" == typeof this.events[t] && e.off(t, this.events[t])
                }
            }, {
                key: "disposeScreen", value: function (e) {
                    var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1];
                    this.events && this.removeEventsListeners(e), (t || this.canDispose) && ("function" == typeof e.dispose && e.dispose(), this.internalInstance = null)
                }
            }, {
                key: "dispose", value: function () {
                    var e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0],
                        t = this.isInstance ? this.screen : this.internalInstance;
                    t && this.disposeScreen(t, e), this.screen = this.internalInstance = this.arguments = this.properties = this.events = null
                }
            }]), i
        }(), fs = function () {
            function i(e, t) {
                es(this, i), this.newScreen = e, this.oldScreen = t, this.promise = this.createPromise()
            }

            return is(i, [{
                key: "createPromise", value: function () {
                    return Promise.resolve()
                }
            }, {
                key: "cancelPromise", value: function () {
                    return Promise.reject("cancel transition").catch(function (e) {
                    })
                }
            }, {
                key: "cancel", value: function () {
                    this.cancelPromise(), this.oldScreen && this.oldScreen.animateOut(!0), this.newScreen && this.newScreen.animateIn(!0)
                }
            }]), i
        }(), ms = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, fs), is(t, [{
                key: "createPromise", value: function () {
                    return this.oldScreen && this.oldScreen.animateOut(), this.newScreen && this.newScreen.animateIn(), Promise.resolve()
                }
            }]), t
        }(), gs = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, fs), is(t, [{
                key: "createPromise", value: function () {
                    var e = this;
                    return Promise.resolve().then(this.newScreen && this.newScreen.animateIn.bind(this.newScreen), this.cancelPromise).then(function () {
                        e.oldScreen && e.oldScreen.animateOut()
                    }, this.cancelPromise)
                }
            }]), t
        }(), vs = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, fs), is(t, [{
                key: "createPromise", value: function () {
                    var e = this;
                    return Promise.resolve().then(this.oldScreen && this.oldScreen.animateOut.bind(this.oldScreen), this.cancelPromise).then(function () {
                        e.newScreen && e.newScreen.animateIn()
                    }, this.cancelPromise)
                }
            }]), t
        }(), ys = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, fs), is(t, [{
                key: "createPromise", value: function () {
                    return Promise.all([Promise.resolve().then(this.oldScreen && this.oldScreen.animateOut.bind(this.oldScreen), this.cancelPromise), Promise.resolve().then(this.newScreen && this.newScreen.animateIn.bind(this.newScreen), this.cancelPromise)])
                }
            }]), t
        }(), _s = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, fs), is(t, [{
                key: "createPromise", value: function () {
                    return Promise.resolve().then(this.oldScreen && this.oldScreen.animateOut.bind(this.oldScreen), this.cancelPromise).then(this.newScreen && this.newScreen.animateIn.bind(this.newScreen), this.cancelPromise)
                }
            }]), t
        }(), xs = {
            None: ms, In: gs, Out: vs, InThenOut: function (e) {
                function t() {
                    return es(this, t), ls(this, rs(t).apply(this, arguments))
                }

                return ns(t, fs), is(t, [{
                    key: "createPromise", value: function () {
                        return Promise.resolve().then(this.newScreen && this.newScreen.animateIn.bind(this.newScreen), this.cancelPromise).then(this.oldScreen && this.oldScreen.animateOut.bind(this.oldScreen), this.cancelPromise)
                    }
                }]), t
            }(), OutAndIn: ys, OutThenIn: _s
        }, bs = function (e) {
            function t() {
                return es(this, t), ls(this, rs(t).apply(this, arguments))
            }

            return ns(t, ps), is(t, [{
                key: "dispose", value: function () {
                }
            }, {
                key: "animateIn", value: function () {
                    var t = this, i = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    return this.emit("animateIn", {cancelTransition: i}), new Promise(function (e) {
                        i ? t.cancelAnimIn(e) : t.createAnimIn(e)
                    }).then(this.onAnimateInComplete.bind(this, i)).catch(function (e) {
                        console.log(e)
                    })
                }
            }, {
                key: "createAnimIn", value: function (e) {
                    e()
                }
            }, {
                key: "cancelAnimIn", value: function (e) {
                    e()
                }
            }, {
                key: "animateOut", value: function () {
                    var t = this, i = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    return this.emit("animateOut", {cancelTransition: i}), new Promise(function (e) {
                        i ? t.cancelAnimOut(e) : t.createAnimOut(e)
                    }).then(this.onAnimateOutComplete.bind(this, i)).catch(function (e) {
                        console.log(e)
                    })
                }
            }, {
                key: "createAnimOut", value: function (e) {
                    e()
                }
            }, {
                key: "cancelAnimOut", value: function (e) {
                    e()
                }
            }, {
                key: "onAnimateInComplete", value: function (e) {
                    this.emit("animateInComplete", {canceledTransition: e})
                }
            }, {
                key: "onAnimateOutComplete", value: function (e) {
                    this.emit("animateOutComplete", {canceledTransition: e})
                }
            }]), t
        }(), ws = function (e) {
            function t() {
                var e;
                return es(this, t), (e = ls(this, rs(t).call(this))).items = {}, e.currentItemId = null, e.previousItemId = null, e.currentScreen = null, e.previousScreen = null, e.transition = null, e.transitionType = xs.None, e
            }

            return ns(t, ps), is(t, [{
                key: "dispose", value: function () {
                    var e = !(0 < arguments.length && void 0 !== arguments[0]) || arguments[0];
                    for (var t in this.transition && (this.transition.cancel(), this.transition = null), this.disposeCurrentScreen(), this.disposePreviousScreen(), this.items) this.items[t].dispose(e), this.removeScreen(t);
                    this.transitionType = null
                }
            }, {
                key: "addScreen", value: function (e, t) {
                    return this.items[e] = t
                }
            }, {
                key: "removeScreen", value: function (e) {
                    this.items[e] && delete this.items[e]
                }
            }, {
                key: "getScreen", value: function (e) {
                    return this.items[e]
                }
            }, {
                key: "showScreen", value: function (e) {
                    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null,
                        i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!this.items[e]) throw new Error("ScreenNavigator - the item with the id " + e + " doesn't exist");
                    return this.transition && this.onTransitionComplete(!0), this.currentScreen && (this.previousItemId = this.currentItemId, this.previousScreen = this.currentScreen), this.currentItemId = e, this.onScreenChange(), this.startTransition(t, i), this.transition.promise
                }
            }, {
                key: "clearScreen", value: function () {
                    var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null;
                    this.currentScreen && (this.previousItemId = this.currentItemId, this.previousScreen = this.currentScreen, this.currentItemId = null, this.onScreenChange(), this.startTransition(e))
                }
            }, {
                key: "disposeScreen", value: function (e, t) {
                    var i = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
                    if (t) {
                        var n = this.items[e];
                        n && n.disposeScreen(t, i)
                    }
                }
            }, {
                key: "disposePreviousScreen", value: function () {
                    this.previousScreen && (this.disposeScreen(this.previousItemId, this.previousScreen), this.previousScreen = null)
                }
            }, {
                key: "disposeCurrentScreen", value: function () {
                    this.currentScreen && (this.disposeScreen(this.currentItemId, this.currentScreen), this.currentScreen = null)
                }
            }, {
                key: "startTransition", value: function () {
                    var e = this, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : null,
                        i = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null,
                        n = t || this.transitionType, r = this.items[this.currentItemId];
                    i && r.setOptions(i), this.currentScreen = r ? r.getScreen(i) : null, this.emit("transitionStart"), this.transition = new n(this.currentScreen, this.previousScreen), this.transition.promise.then(function () {
                        e.onTransitionComplete()
                    })
                }
            }, {
                key: "onScreenChange", value: function () {
                    this.emit("screenChange")
                }
            }, {
                key: "onTransitionComplete", value: function () {
                    var e = 0 < arguments.length && void 0 !== arguments[0] && arguments[0];
                    e && this.transition && this.transition.cancel(), this.transition = null, this.disposePreviousScreen(), e ? this.emit("transitionCancel") : this.emit("transitionComplete")
                }
            }]), t
        }(),
        Ts = "undefined" != typeof window ? window : "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : {},
        Ss = function (u, e) {
            var p = {}, n = u.document, d = u.GreenSockGlobals = u.GreenSockGlobals || u;
            if (d.TweenLite) return d.TweenLite;
            var t, i, r, f, m, a, o, g = function (e) {
                var t, i = e.split("."), n = d;
                for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {};
                return n
            }, v = g("com.greensock"), y = 1e-10, l = function (e) {
                var t, i = [], n = e.length;
                for (t = 0; t !== n; i.push(e[t++])) ;
                return i
            }, _ = function () {
            }, x = (a = Object.prototype.toString, o = a.call([]), function (e) {
                return null != e && (e instanceof Array || "object" == typeof e && !!e.push && a.call(e) === o)
            }), b = {}, w = function (s, l, h, c) {
                this.sc = b[s] ? b[s].sc : [], (b[s] = this).gsClass = null, this.func = h;
                var u = [];
                this.check = function (e) {
                    for (var t, i, n, r, a = l.length, o = a; -1 < --a;) (t = b[l[a]] || new w(l[a], [])).gsClass ? (u[a] = t.gsClass, o--) : e && t.sc.push(this);
                    if (0 === o && h) for (n = (i = ("com.greensock." + s).split(".")).pop(), r = g(i.join("."))[n] = this.gsClass = h.apply(h, u), c && (d[n] = p[n] = r), a = 0; a < this.sc.length; a++) this.sc[a].check()
                }, this.check(!0)
            }, s = u._gsDefine = function (e, t, i, n) {
                return new w(e, t, i, n)
            }, T = v._class = function (e, t, i) {
                return t = t || function () {
                }, s(e, [], function () {
                    return t
                }, i), t
            };
            s.globals = d;
            var h = [0, 0, 1, 1], S = T("easing.Ease", function (e, t, i, n) {
                this._func = e, this._type = i || 0, this._power = n || 0, this._params = t ? h.concat(t) : h
            }, !0), E = S.map = {}, c = S.register = function (e, t, i, n) {
                for (var r, a, o, s, l = t.split(","), h = l.length, c = (i || "easeIn,easeOut,easeInOut").split(","); -1 < --h;) for (a = l[h], r = n ? T("easing." + a, null, !0) : v.easing[a] || {}, o = c.length; -1 < --o;) s = c[o], E[a + "." + s] = E[s + a] = r[s] = e.getRatio ? e : e[s] || new e
            };
            for ((r = S.prototype)._calcEnd = !1, r.getRatio = function (e) {
                if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
                var t = this._type, i = this._power, n = 1 === t ? 1 - e : 2 === t ? e : e < .5 ? 2 * e : 2 * (1 - e);
                return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === t ? 1 - n : 2 === t ? n : e < .5 ? n / 2 : 1 - n / 2
            }, i = (t = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; -1 < --i;) r = t[i] + ",Power" + i, c(new S(null, null, 1, i), r, "easeOut", !0), c(new S(null, null, 2, i), r, "easeIn" + (0 === i ? ",easeNone" : "")), c(new S(null, null, 3, i), r, "easeInOut");
            E.linear = v.easing.Linear.easeIn, E.swing = v.easing.Quad.easeInOut;
            var A = T("events.EventDispatcher", function (e) {
                this._listeners = {}, this._eventTarget = e || this
            });
            (r = A.prototype).addEventListener = function (e, t, i, n, r) {
                r = r || 0;
                var a, o, s = this._listeners[e], l = 0;
                for (this !== f || m || f.wake(), null == s && (this._listeners[e] = s = []), o = s.length; -1 < --o;) (a = s[o]).c === t && a.s === i ? s.splice(o, 1) : 0 === l && a.pr < r && (l = o + 1);
                s.splice(l, 0, {c: t, s: i, up: n, pr: r})
            }, r.removeEventListener = function (e, t) {
                var i, n = this._listeners[e];
                if (n) for (i = n.length; -1 < --i;) if (n[i].c === t) return void n.splice(i, 1)
            }, r.dispatchEvent = function (e) {
                var t, i, n, r = this._listeners[e];
                if (r) for (1 < (t = r.length) && (r = r.slice(0)), i = this._eventTarget; -1 < --t;) (n = r[t]) && (n.up ? n.c.call(n.s || i, {
                    type: e, target: i
                }) : n.c.call(n.s || i))
            };
            var M = u.requestAnimationFrame, P = u.cancelAnimationFrame, L = Date.now || function () {
                return (new Date).getTime()
            }, C = L();
            for (i = (t = ["ms", "moz", "webkit", "o"]).length; -1 < --i && !M;) M = u[t[i] + "RequestAnimationFrame"], P = u[t[i] + "CancelAnimationFrame"] || u[t[i] + "CancelRequestAnimationFrame"];
            T("Ticker", function (e, t) {
                var r, a, o, s, l, h = this, c = L(), i = !(!1 === t || !M) && "auto", u = 500, p = 33,
                    d = function (e) {
                        var t, i, n = L() - C;
                        u < n && (c += n - p), C += n, h.time = (C - c) / 1e3, t = h.time - l, (!r || 0 < t || !0 === e) && (h.frame++, l += t + (s <= t ? .004 : s - t), i = !0), !0 !== e && (o = a(d)), i && h.dispatchEvent("tick")
                    };
                A.call(h), h.time = h.frame = 0, h.tick = function () {
                    d(!0)
                }, h.lagSmoothing = function (e, t) {
                    if (!arguments.length) return u < 1e10;
                    u = e || 1e10, p = Math.min(t, u, 0)
                }, h.sleep = function () {
                    null != o && (i && P ? P(o) : clearTimeout(o), a = _, o = null, h === f && (m = !1))
                }, h.wake = function (e) {
                    null !== o ? h.sleep() : e ? c += -C + (C = L()) : 10 < h.frame && (C = L() - u + 5), a = 0 === r ? _ : i && M ? M : function (e) {
                        return setTimeout(e, 1e3 * (l - h.time) + 1 | 0)
                    }, h === f && (m = !0), d(2)
                }, h.fps = function (e) {
                    if (!arguments.length) return r;
                    s = 1 / ((r = e) || 60), l = this.time + s, h.wake()
                }, h.useRAF = function (e) {
                    if (!arguments.length) return i;
                    h.sleep(), i = e, h.fps(r)
                }, h.fps(e), setTimeout(function () {
                    "auto" === i && h.frame < 5 && "hidden" !== (n || {}).visibilityState && h.useRAF(!1)
                }, 1500)
            }), (r = v.Ticker.prototype = new v.events.EventDispatcher).constructor = v.Ticker;
            var I = T("core.Animation", function (e, t) {
                if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = !0 === t.immediateRender, this.data = t.data, this._reversed = !0 === t.reversed, Z) {
                    m || f.wake();
                    var i = this.vars.useFrames ? Q : Z;
                    i.add(this, i._time), this.vars.paused && this.paused(!0)
                }
            });
            f = I.ticker = new v.Ticker, (r = I.prototype)._dirty = r._gc = r._initted = r._paused = !1, r._totalTime = r._time = 0, r._rawPrevTime = -1, r._next = r._last = r._onUpdate = r._timeline = r.timeline = null, r._paused = !1;
            var R = function () {
                m && 2e3 < L() - C && ("hidden" !== (n || {}).visibilityState || !f.lagSmoothing()) && f.wake();
                var e = setTimeout(R, 2e3);
                e.unref && e.unref()
            };
            R(), r.play = function (e, t) {
                return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
            }, r.pause = function (e, t) {
                return null != e && this.seek(e, t), this.paused(!0)
            }, r.resume = function (e, t) {
                return null != e && this.seek(e, t), this.paused(!1)
            }, r.seek = function (e, t) {
                return this.totalTime(Number(e), !1 !== t)
            }, r.restart = function (e, t) {
                return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, !1 !== t, !0)
            }, r.reverse = function (e, t) {
                return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
            }, r.render = function (e, t, i) {
            }, r.invalidate = function () {
                return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
            }, r.isActive = function () {
                var e, t = this._timeline, i = this._startTime;
                return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime(!0)) >= i && e < i + this.totalDuration() / this._timeScale - 1e-7
            }, r._enabled = function (e, t) {
                return m || f.wake(), this._gc = !e, this._active = this.isActive(), !0 !== t && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
            }, r._kill = function (e, t) {
                return this._enabled(!1, !1)
            }, r.kill = function (e, t) {
                return this._kill(e, t), this
            }, r._uncache = function (e) {
                for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
                return this
            }, r._swapSelfInParams = function (e) {
                for (var t = e.length, i = e.concat(); -1 < --t;) "{self}" === e[t] && (i[t] = this);
                return i
            }, r._callback = function (e) {
                var t = this.vars, i = t[e], n = t[e + "Params"], r = t[e + "Scope"] || t.callbackScope || this;
                switch (n ? n.length : 0) {
                    case 0:
                        i.call(r);
                        break;
                    case 1:
                        i.call(r, n[0]);
                        break;
                    case 2:
                        i.call(r, n[0], n[1]);
                        break;
                    default:
                        i.apply(r, n)
                }
            }, r.eventCallback = function (e, t, i, n) {
                if ("on" === (e || "").substr(0, 2)) {
                    var r = this.vars;
                    if (1 === arguments.length) return r[e];
                    null == t ? delete r[e] : (r[e] = t, r[e + "Params"] = x(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[e + "Scope"] = n), "onUpdate" === e && (this._onUpdate = t)
                }
                return this
            }, r.delay = function (e) {
                return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
            }, r.duration = function (e) {
                return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && 0 < this._time && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
            }, r.totalDuration = function (e) {
                return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
            }, r.time = function (e, t) {
                return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
            }, r.totalTime = function (e, t, i) {
                if (m || f.wake(), !arguments.length) return this._totalTime;
                if (this._timeline) {
                    if (e < 0 && !i && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                        this._dirty && this.totalDuration();
                        var n = this._totalDuration, r = this._timeline;
                        if (n < e && !i && (e = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - e : e) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                    }
                    this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (k.length && K(), this.render(e, t, !1), k.length && K())
                }
                return this
            }, r.progress = r.totalProgress = function (e, t) {
                var i = this.duration();
                return arguments.length ? this.totalTime(i * e, t) : i ? this._time / i : this.ratio
            }, r.startTime = function (e) {
                return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
            }, r.endTime = function (e) {
                return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
            }, r.timeScale = function (e) {
                if (!arguments.length) return this._timeScale;
                var t, i;
                for (e = e || y, this._timeline && this._timeline.smoothChildTiming && (i = (t = this._pauseTime) || 0 === t ? t : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / e), this._timeScale = e, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
                return this
            }, r.reversed = function (e) {
                return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
            }, r.paused = function (e) {
                if (!arguments.length) return this._paused;
                var t, i, n = this._timeline;
                return e != this._paused && n && (m || e || f.wake(), i = (t = n.rawTime()) - this._pauseTime, !e && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== i && this._initted && this.duration() && (t = n.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this
            };
            var O = T("core.SimpleTimeline", function (e) {
                I.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
            });
            (r = O.prototype = new I).constructor = O, r.kill()._gc = !1, r._first = r._last = r._recent = null, r._sortChildren = !1, r.add = r.insert = function (e, t, i, n) {
                var r, a;
                if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = this.rawTime() - (e._timeline.rawTime() - e._pauseTime)), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), r = this._last, this._sortChildren) for (a = e._startTime; r && r._startTime > a;) r = r._prev;
                return r ? (e._next = r._next, r._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = r, this._recent = e, this._timeline && this._uncache(!0), this
            }, r._remove = function (e, t) {
                return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
            }, r.render = function (e, t, i) {
                var n, r = this._first;
                for (this._totalTime = this._time = this._rawPrevTime = e; r;) n = r._next, (r._active || e >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = n
            }, r.rawTime = function () {
                return m || f.wake(), this._totalTime
            };
            var F = T("TweenLite", function (e, t, i) {
                if (I.call(this, t, i), this.render = F.prototype.render, null == e) throw"Cannot tween a null target.";
                this.target = e = "string" != typeof e ? e : F.selector(e) || e;
                var n, r, a,
                    o = e.jquery || e.length && e !== u && e[0] && (e[0] === u || e[0].nodeType && e[0].style && !e.nodeType),
                    s = this.vars.overwrite;
                if (this._overwrite = s = null == s ? q[F.defaultOverwrite] : "number" == typeof s ? s >> 0 : q[s], (o || e instanceof Array || e.push && x(e)) && "number" != typeof e[0]) for (this._targets = a = l(e), this._propLookup = [], this._siblings = [], n = 0; n < a.length; n++) (r = a[n]) ? "string" != typeof r ? r.length && r !== u && r[0] && (r[0] === u || r[0].nodeType && r[0].style && !r.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(l(r))) : (this._siblings[n] = $(r, this, !1), 1 === s && 1 < this._siblings[n].length && te(r, this, null, 1, this._siblings[n])) : "string" == typeof (r = a[n--] = F.selector(r)) && a.splice(n + 1, 1) : a.splice(n--, 1); else this._propLookup = {}, this._siblings = $(e, this, !1), 1 === s && 1 < this._siblings.length && te(e, this, null, 1, this._siblings);
                (this.vars.immediateRender || 0 === t && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -y, this.render(Math.min(0, -this._delay)))
            }, !0), N = function (e) {
                return e && e.length && e !== u && e[0] && (e[0] === u || e[0].nodeType && e[0].style && !e.nodeType)
            };
            (r = F.prototype = new I).constructor = F, r.kill()._gc = !1, r.ratio = 0, r._firstPT = r._targets = r._overwrittenProps = r._startAt = null, r._notifyPluginsOfEnabled = r._lazy = !1, F.version = "2.0.2", F.defaultEase = r._ease = new S(null, null, 1, 1), F.defaultOverwrite = "auto", F.ticker = f, F.autoSleep = 120, F.lagSmoothing = function (e, t) {
                f.lagSmoothing(e, t)
            }, F.selector = u.$ || u.jQuery || function (e) {
                var t = u.$ || u.jQuery;
                return t ? (F.selector = t)(e) : (n || (n = u.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
            };
            var k = [], U = {}, D = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, z = /[\+-]=-?[\.\d]/,
                B = function (e) {
                    for (var t, i = this._firstPT; i;) t = i.blob ? 1 === e && null != this.end ? this.end : e ? this.join("") : this.start : i.c * e + i.s, i.m ? t = i.m.call(this._tween, t, this._target || i.t, this._tween) : t < 1e-6 && -1e-6 < t && !i.blob && (t = 0), i.f ? i.fp ? i.t[i.p](i.fp, t) : i.t[i.p](t) : i.t[i.p] = t, i = i._next
                }, H = function (e, t, i, n) {
                    var r, a, o, s, l, h, c, u = [], p = 0, d = "", f = 0;
                    for (u.start = e, u.end = t, e = u[0] = e + "", t = u[1] = t + "", i && (i(u), e = u[0], t = u[1]), u.length = 0, r = e.match(D) || [], a = t.match(D) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = a.length, s = 0; s < l; s++) c = a[s], d += (h = t.substr(p, t.indexOf(c, p) - p)) || !s ? h : ",", p += h.length, f ? f = (f + 1) % 5 : "rgba(" === h.substr(-5) && (f = 1), c === r[s] || r.length <= s ? d += c : (d && (u.push(d), d = ""), o = parseFloat(r[s]), u.push(o), u._firstPT = {
                        _next: u._firstPT,
                        t: u,
                        p: u.length - 1,
                        s: o,
                        c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - o) || 0,
                        f: 0,
                        m: f && f < 4 ? Math.round : 0
                    }), p += c.length;
                    return (d += t.substr(p)) && u.push(d), u.setRatio = B, z.test(t) && (u.end = null), u
                }, G = function (e, t, i, n, r, a, o, s, l) {
                    "function" == typeof n && (n = n(l || 0, e));
                    var h = typeof e[t],
                        c = "function" !== h ? "" : t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3),
                        u = "get" !== i ? i : c ? o ? e[c](o) : e[c]() : e[t],
                        p = "string" == typeof n && "=" === n.charAt(1), d = {
                            t: e,
                            p: t,
                            s: u,
                            f: "function" === h,
                            pg: 0,
                            n: r || t,
                            m: a ? "function" == typeof a ? a : Math.round : 0,
                            pr: 0,
                            c: p ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0
                        };
                    if (("number" != typeof u || "number" != typeof n && !p) && (o || isNaN(u) || !p && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (d.fp = o, d = {
                        t: H(u, p ? parseFloat(d.s) + d.c + (d.s + "").replace(/[0-9\-\.]/g, "") : n, s || F.defaultStringFilter, d),
                        p: "setRatio",
                        s: 0,
                        c: 1,
                        f: 2,
                        pg: 0,
                        n: r || t,
                        pr: 0,
                        m: 0
                    }) : (d.s = parseFloat(u), p || (d.c = parseFloat(n) - d.s || 0))), d.c) return (d._next = this._firstPT) && (d._next._prev = d), this._firstPT = d
                }, j = F._internals = {isArray: x, isSelector: N, lazyTweens: k, blobDif: H}, V = F._plugins = {},
                X = j.tweenLookup = {}, W = 0, Y = j.reservedProps = {
                    ease: 1,
                    delay: 1,
                    overwrite: 1,
                    onComplete: 1,
                    onCompleteParams: 1,
                    onCompleteScope: 1,
                    useFrames: 1,
                    runBackwards: 1,
                    startAt: 1,
                    onUpdate: 1,
                    onUpdateParams: 1,
                    onUpdateScope: 1,
                    onStart: 1,
                    onStartParams: 1,
                    onStartScope: 1,
                    onReverseComplete: 1,
                    onReverseCompleteParams: 1,
                    onReverseCompleteScope: 1,
                    onRepeat: 1,
                    onRepeatParams: 1,
                    onRepeatScope: 1,
                    easeParams: 1,
                    yoyo: 1,
                    immediateRender: 1,
                    repeat: 1,
                    repeatDelay: 1,
                    data: 1,
                    paused: 1,
                    reversed: 1,
                    autoCSS: 1,
                    lazy: 1,
                    onOverwrite: 1,
                    callbackScope: 1,
                    stringFilter: 1,
                    id: 1,
                    yoyoEase: 1
                }, q = {none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0},
                Q = I._rootFramesTimeline = new O, Z = I._rootTimeline = new O, J = 30, K = j.lazyRender = function () {
                    var e, t = k.length;
                    for (U = {}; -1 < --t;) (e = k[t]) && !1 !== e._lazy && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                    k.length = 0
                };
            Z._startTime = f.time, Q._startTime = f.frame, Z._active = Q._active = !0, setTimeout(K, 1), I._updateRoot = F.render = function () {
                var e, t, i;
                if (k.length && K(), Z.render((f.time - Z._startTime) * Z._timeScale, !1, !1), Q.render((f.frame - Q._startTime) * Q._timeScale, !1, !1), k.length && K(), f.frame >= J) {
                    for (i in J = f.frame + (parseInt(F.autoSleep, 10) || 120), X) {
                        for (e = (t = X[i].tweens).length; -1 < --e;) t[e]._gc && t.splice(e, 1);
                        0 === t.length && delete X[i]
                    }
                    if ((!(i = Z._first) || i._paused) && F.autoSleep && !Q._first && 1 === f._listeners.tick.length) {
                        for (; i && i._paused;) i = i._next;
                        i || f.sleep()
                    }
                }
            }, f.addEventListener("tick", I._updateRoot);
            var $ = function (e, t, i) {
                var n, r, a = e._gsTweenID;
                if (X[a || (e._gsTweenID = a = "t" + W++)] || (X[a] = {
                    target: e, tweens: []
                }), t && ((n = X[a].tweens)[r = n.length] = t, i)) for (; -1 < --r;) n[r] === t && n.splice(r, 1);
                return X[a].tweens
            }, ee = function (e, t, i, n) {
                var r, a, o = e.vars.onOverwrite;
                return o && (r = o(e, t, i, n)), (o = F.onOverwrite) && (a = o(e, t, i, n)), !1 !== r && !1 !== a
            }, te = function (e, t, i, n, r) {
                var a, o, s, l;
                if (1 === n || 4 <= n) {
                    for (l = r.length, a = 0; a < l; a++) if ((s = r[a]) !== t) s._gc || s._kill(null, e, t) && (o = !0); else if (5 === n) break;
                    return o
                }
                var h, c = t._startTime + y, u = [], p = 0, d = 0 === t._duration;
                for (a = r.length; -1 < --a;) (s = r[a]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (h = h || ie(t, 0, d), 0 === ie(s, h, d) && (u[p++] = s)) : s._startTime <= c && s._startTime + s.totalDuration() / s._timeScale > c && ((d || !s._initted) && c - s._startTime <= 2e-10 || (u[p++] = s)));
                for (a = p; -1 < --a;) if (l = (s = u[a])._firstPT, 2 === n && s._kill(i, e, t) && (o = !0), 2 !== n || !s._firstPT && s._initted && l) {
                    if (2 !== n && !ee(s, t)) continue;
                    s._enabled(!1, !1) && (o = !0)
                }
                return o
            }, ie = function (e, t, i) {
                for (var n = e._timeline, r = n._timeScale, a = e._startTime; n._timeline;) {
                    if (a += n._startTime, r *= n._timeScale, n._paused) return -100;
                    n = n._timeline
                }
                return t < (a /= r) ? a - t : i && a === t || !e._initted && a - t < 2 * y ? y : (a += e.totalDuration() / e._timeScale / r) > t + y ? 0 : a - t - y
            };
            r._init = function () {
                var e, t, i, n, r, a, o = this.vars, s = this._overwrittenProps, l = this._duration,
                    h = !!o.immediateRender, c = o.ease;
                if (o.startAt) {
                    for (n in this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {}, o.startAt) r[n] = o.startAt[n];
                    if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = h && !1 !== o.lazy, r.startAt = r.delay = null, r.onUpdate = o.onUpdate, r.onUpdateParams = o.onUpdateParams, r.onUpdateScope = o.onUpdateScope || o.callbackScope || this, this._startAt = F.to(this.target || {}, 0, r), h) if (0 < this._time) this._startAt = null; else if (0 !== l) return
                } else if (o.runBackwards && 0 !== l) if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null; else {
                    for (n in 0 !== this._time && (h = !1), i = {}, o) Y[n] && "autoCSS" !== n || (i[n] = o[n]);
                    if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && !1 !== o.lazy, i.immediateRender = h, this._startAt = F.to(this.target, 0, i), h) {
                        if (0 === this._time) return
                    } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                }
                if (this._ease = c = c ? c instanceof S ? c : "function" == typeof c ? new S(c, o.easeParams) : E[c] || F.defaultEase : F.defaultEase, o.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (a = this._targets.length, e = 0; e < a; e++) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], s ? s[e] : null, e) && (t = !0); else t = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                if (t && F._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards) for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                this._onUpdate = o.onUpdate, this._initted = !0
            }, r._initProps = function (e, t, i, n, r) {
                var a, o, s, l, h, c;
                if (null == e) return !1;
                for (a in U[e._gsTweenID] && K(), this.vars.css || e.style && e !== u && e.nodeType && V.css && !1 !== this.vars.autoCSS && function (e, t) {
                    var i, n = {};
                    for (i in e) Y[i] || i in t && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!V[i] || V[i] && V[i]._autoCSS) || (n[i] = e[i], delete e[i]);
                    e.css = n
                }(this.vars, e), this.vars) if (c = this.vars[a], Y[a]) c && (c instanceof Array || c.push && x(c)) && -1 !== c.join("").indexOf("{self}") && (this.vars[a] = c = this._swapSelfInParams(c, this)); else if (V[a] && (l = new V[a])._onInitTween(e, this.vars[a], this, r)) {
                    for (this._firstPT = h = {
                        _next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f: 1, n: a, pg: 1, pr: l._priority, m: 0
                    }, o = l._overwriteProps.length; -1 < --o;) t[l._overwriteProps[o]] = this._firstPT;
                    (l._priority || l._onInitAllProps) && (s = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
                } else t[a] = G.call(this, e, a, "get", c, a, 0, null, this.vars.stringFilter, r);
                return n && this._kill(n, e) ? this._initProps(e, t, i, n, r) : 1 < this._overwrite && this._firstPT && 1 < i.length && te(e, this, t, this._overwrite, i) ? (this._kill(t, e), this._initProps(e, t, i, n, r)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (U[e._gsTweenID] = !0), s)
            }, r.render = function (e, t, i) {
                var n, r, a, o, s = this._time, l = this._duration, h = this._rawPrevTime;
                if (l - 1e-7 <= e && 0 <= e) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (h < 0 || e <= 0 && -1e-7 <= e || h === y && "isPause" !== this.data) && h !== e && (i = !0, y < h && (r = "onReverseComplete")), this._rawPrevTime = o = !t || e || h === e ? e : y); else if (e < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && 0 < h) && (r = "onReverseComplete", n = this._reversed), e < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (0 <= h && (h !== y || "isPause" !== this.data) && (i = !0), this._rawPrevTime = o = !t || e || h === e ? e : y)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0); else if (this._totalTime = this._time = e, this._easeType) {
                    var c = e / l, u = this._easeType, p = this._easePower;
                    (1 === u || 3 === u && .5 <= c) && (c = 1 - c), 3 === u && (c *= 2), 1 === p ? c *= c : 2 === p ? c *= c * c : 3 === p ? c *= c * c * c : 4 === p && (c *= c * c * c * c), this.ratio = 1 === u ? 1 - c : 2 === u ? c : e / l < .5 ? c / 2 : 1 - c / 2
                } else this.ratio = this._ease.getRatio(e / l);
                if (this._time !== s || i) {
                    if (!this._initted) {
                        if (this._init(), !this._initted || this._gc) return;
                        if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = h, k.push(this), void (this._lazy = [e, t]);
                        this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                    }
                    for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== s && 0 <= e && (this._active = !0), 0 === s && (this._startAt && (0 <= e ? this._startAt.render(e, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || t || this._callback("onStart"))), a = this._firstPT; a;) a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next;
                    this._onUpdate && (e < 0 && this._startAt && -1e-4 !== e && this._startAt.render(e, !0, i), t || (this._time !== s || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (e < 0 && this._startAt && !this._onUpdate && -1e-4 !== e && this._startAt.render(e, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === y && o !== y && (this._rawPrevTime = 0)))
                }
            }, r._kill = function (e, t, i) {
                if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                t = "string" != typeof t ? t || this._targets || this.target : F.selector(t) || t;
                var n, r, a, o, s, l, h, c, u,
                    p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                    d = this._firstPT;
                if ((x(t) || N(t)) && "number" != typeof t[0]) for (n = t.length; -1 < --n;) this._kill(e, t[n], i) && (l = !0); else {
                    if (this._targets) {
                        for (n = this._targets.length; -1 < --n;) if (t === this._targets[n]) {
                            s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = e ? this._overwrittenProps[n] || {} : "all";
                            break
                        }
                    } else {
                        if (t !== this.target) return !1;
                        s = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
                    }
                    if (s) {
                        if (h = e || s, c = e !== r && "all" !== r && e !== s && ("object" != typeof e || !e._tempKill), i && (F.onOverwrite || this.vars.onOverwrite)) {
                            for (a in h) s[a] && (u || (u = []), u.push(a));
                            if ((u || !e) && !ee(this, i, t, u)) return !1
                        }
                        for (a in h) (o = s[a]) && (p && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, l = !0), o.pg && o.t._kill(h) && (l = !0), o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete s[a]), c && (r[a] = 1);
                        !this._firstPT && this._initted && d && this._enabled(!1, !1)
                    }
                }
                return l
            }, r.invalidate = function () {
                return this._notifyPluginsOfEnabled && F._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], I.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -y, this.render(Math.min(0, -this._delay))), this
            }, r._enabled = function (e, t) {
                if (m || f.wake(), e && this._gc) {
                    var i, n = this._targets;
                    if (n) for (i = n.length; -1 < --i;) this._siblings[i] = $(n[i], this, !0); else this._siblings = $(this.target, this, !0)
                }
                return I.prototype._enabled.call(this, e, t), !(!this._notifyPluginsOfEnabled || !this._firstPT) && F._onPluginEvent(e ? "_onEnable" : "_onDisable", this)
            }, F.to = function (e, t, i) {
                return new F(e, t, i)
            }, F.from = function (e, t, i) {
                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new F(e, t, i)
            }, F.fromTo = function (e, t, i, n) {
                return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new F(e, t, n)
            }, F.delayedCall = function (e, t, i, n, r) {
                return new F(t, 0, {
                    delay: e,
                    onComplete: t,
                    onCompleteParams: i,
                    callbackScope: n,
                    onReverseComplete: t,
                    onReverseCompleteParams: i,
                    immediateRender: !1,
                    lazy: !1,
                    useFrames: r,
                    overwrite: 0
                })
            }, F.set = function (e, t) {
                return new F(e, 0, t)
            }, F.getTweensOf = function (e, t) {
                if (null == e) return [];
                var i, n, r, a;
                if (e = "string" != typeof e ? e : F.selector(e) || e, (x(e) || N(e)) && "number" != typeof e[0]) {
                    for (i = e.length, n = []; -1 < --i;) n = n.concat(F.getTweensOf(e[i], t));
                    for (i = n.length; -1 < --i;) for (a = n[i], r = i; -1 < --r;) a === n[r] && n.splice(i, 1)
                } else if (e._gsTweenID) for (i = (n = $(e).concat()).length; -1 < --i;) (n[i]._gc || t && !n[i].isActive()) && n.splice(i, 1);
                return n || []
            }, F.killTweensOf = F.killDelayedCallsTo = function (e, t, i) {
                "object" == typeof t && (i = t, t = !1);
                for (var n = F.getTweensOf(e, t), r = n.length; -1 < --r;) n[r]._kill(i, e)
            };
            var ne = T("plugins.TweenPlugin", function (e, t) {
                this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = ne.prototype
            }, !0);
            if (r = ne.prototype, ne.version = "1.19.0", ne.API = 2, r._firstPT = null, r._addTween = G, r.setRatio = B, r._kill = function (e) {
                var t, i = this._overwriteProps, n = this._firstPT;
                if (null != e[this._propName]) this._overwriteProps = []; else for (t = i.length; -1 < --t;) null != e[i[t]] && i.splice(t, 1);
                for (; n;) null != e[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
                return !1
            }, r._mod = r._roundProps = function (e) {
                for (var t, i = this._firstPT; i;) (t = e[this._propName] || null != i.n && e[i.n.split(this._propName + "_").join("")]) && "function" == typeof t && (2 === i.f ? i.t._applyPT.m = t : i.m = t), i = i._next
            }, F._onPluginEvent = function (e, t) {
                var i, n, r, a, o, s = t._firstPT;
                if ("_onInitAllProps" === e) {
                    for (; s;) {
                        for (o = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                        (s._prev = n ? n._prev : a) ? s._prev._next = s : r = s, (s._next = n) ? n._prev = s : a = s, s = o
                    }
                    s = t._firstPT = r
                }
                for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (i = !0), s = s._next;
                return i
            }, ne.activate = function (e) {
                for (var t = e.length; -1 < --t;) e[t].API === ne.API && (V[(new e[t])._propName] = e[t]);
                return !0
            }, s.plugin = function (e) {
                if (!(e && e.propName && e.init && e.API)) throw"illegal plugin definition.";
                var t, i = e.propName, n = e.priority || 0, r = e.overwriteProps, a = {
                    init: "_onInitTween",
                    set: "setRatio",
                    kill: "_kill",
                    round: "_mod",
                    mod: "_mod",
                    initAll: "_onInitAllProps"
                }, o = T("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
                    ne.call(this, i, n), this._overwriteProps = r || []
                }, !0 === e.global), s = o.prototype = new ne(i);
                for (t in (s.constructor = o).API = e.API, a) "function" == typeof e[t] && (s[a[t]] = e[t]);
                return o.version = e.version, ne.activate([o]), o
            }, t = u._gsQueue) {
                for (i = 0; i < t.length; i++) t[i]();
                for (r in b) b[r].func || u.console.log("GSAP encountered missing dependency: " + r)
            }
            return m = !1, F
        }(Ts), Es = Ts.GreenSockGlobals, As = Es.com.greensock, Ms = As.core.SimpleTimeline, Ps = As.core.Animation,
        Ls = Es.Ease, Cs = Es.Linear, Is = Cs, Rs = Es.Power1, Os = Es.Power2, Fs = Es.Power3, Ns = Es.Power4,
        ks = Es.TweenPlugin;
    As.events.EventDispatcher;
    Ts._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function () {
        var p = function (e) {
                Ms.call(this, e), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                var t, i, n = this.vars;
                for (i in n) t = n[i], c(t) && -1 !== t.join("").indexOf("{self}") && (n[i] = this._swapSelfInParams(t));
                c(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
            }, e = Ss._internals, t = p._internals = {}, d = e.isSelector, c = e.isArray, m = e.lazyTweens,
            g = e.lazyRender, o = Ts._gsDefine.globals, f = function (e) {
                var t, i = {};
                for (t in e) i[t] = e[t];
                return i
            }, v = function (e, t, i) {
                var n, r, a = e.cycle;
                for (n in a) r = a[n], e[n] = "function" == typeof r ? r(i, t[i]) : r[i % r.length];
                delete e.cycle
            }, a = t.pauseCallback = function () {
            }, y = function (e) {
                var t, i = [], n = e.length;
                for (t = 0; t !== n; i.push(e[t++])) ;
                return i
            }, i = p.prototype = new Ms;
        return p.version = "2.0.2", i.constructor = p, i.kill()._gc = i._forcingPlayhead = i._hasPause = !1, i.to = function (e, t, i, n) {
            var r = i.repeat && o.TweenMax || Ss;
            return t ? this.add(new r(e, t, i), n) : this.set(e, i, n)
        }, i.from = function (e, t, i, n) {
            return this.add((i.repeat && o.TweenMax || Ss).from(e, t, i), n)
        }, i.fromTo = function (e, t, i, n, r) {
            var a = n.repeat && o.TweenMax || Ss;
            return t ? this.add(a.fromTo(e, t, i, n), r) : this.set(e, n, r)
        }, i.staggerTo = function (e, t, i, n, r, a, o, s) {
            var l, h, c = new p({
                onComplete: a, onCompleteParams: o, callbackScope: s, smoothChildTiming: this.smoothChildTiming
            }), u = i.cycle;
            for ("string" == typeof e && (e = Ss.selector(e) || e), d(e = e || []) && (e = y(e)), (n = n || 0) < 0 && ((e = y(e)).reverse(), n *= -1), h = 0; h < e.length; h++) (l = f(i)).startAt && (l.startAt = f(l.startAt), l.startAt.cycle && v(l.startAt, e, h)), u && (v(l, e, h), null != l.duration && (t = l.duration, delete l.duration)), c.to(e[h], t, l, h * n);
            return this.add(c, r)
        }, i.staggerFrom = function (e, t, i, n, r, a, o, s) {
            return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(e, t, i, n, r, a, o, s)
        }, i.staggerFromTo = function (e, t, i, n, r, a, o, s, l) {
            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, this.staggerTo(e, t, n, r, a, o, s, l)
        }, i.call = function (e, t, i, n) {
            return this.add(Ss.delayedCall(0, e, t, i), n)
        }, i.set = function (e, t, i) {
            return i = this._parseTimeOrLabel(i, 0, !0), null == t.immediateRender && (t.immediateRender = i === this._time && !this._paused), this.add(new Ss(e, 0, t), i)
        }, p.exportRoot = function (e, t) {
            null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0);
            var i, n, r, a, o = new p(e), s = o._timeline;
            for (null == t && (t = !0), s._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = s._time, r = s._first; r;) a = r._next, t && r instanceof Ss && r.target === r.vars.onComplete || ((n = r._startTime - r._delay) < 0 && (i = 1), o.add(r, n)), r = a;
            return s.add(o, 0), i && o.totalDuration(), o
        }, i.add = function (e, t, i, n) {
            var r, a, o, s, l, h;
            if ("number" != typeof t && (t = this._parseTimeOrLabel(t, 0, !0, e)), !(e instanceof Ps)) {
                if (e instanceof Array || e && e.push && c(e)) {
                    for (i = i || "normal", n = n || 0, r = t, a = e.length, o = 0; o < a; o++) c(s = e[o]) && (s = new p({tweens: s})), this.add(s, r), "string" != typeof s && "function" != typeof s && ("sequence" === i ? r = s._startTime + s.totalDuration() / s._timeScale : "start" === i && (s._startTime -= s.delay())), r += n;
                    return this._uncache(!0)
                }
                if ("string" == typeof e) return this.addLabel(e, t);
                if ("function" != typeof e) throw"Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                e = Ss.delayedCall(0, e)
            }
            if (Ms.prototype.add.call(this, e, t), e._time && (r = Math.max(0, Math.min(e.totalDuration(), (this.rawTime() - e._startTime) * e._timeScale)), 1e-5 < Math.abs(r - e._totalTime) && e.render(r, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (h = (l = this).rawTime() > e._startTime; l._timeline;) h && l._timeline.smoothChildTiming ? l.totalTime(l._totalTime, !0) : l._gc && l._enabled(!0, !1), l = l._timeline;
            return this
        }, i.remove = function (e) {
            if (e instanceof Ps) {
                this._remove(e, !1);
                var t = e._timeline = e.vars.useFrames ? Ps._rootFramesTimeline : Ps._rootTimeline;
                return e._startTime = (e._paused ? e._pauseTime : t._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
            }
            if (e instanceof Array || e && e.push && c(e)) {
                for (var i = e.length; -1 < --i;) this.remove(e[i]);
                return this
            }
            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
        }, i._remove = function (e, t) {
            return Ms.prototype._remove.call(this, e, t), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
        }, i.append = function (e, t) {
            return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
        }, i.insert = i.insertMultiple = function (e, t, i, n) {
            return this.add(e, t || 0, i, n)
        }, i.appendMultiple = function (e, t, i, n) {
            return this.add(e, this._parseTimeOrLabel(null, t, !0, e), i, n)
        }, i.addLabel = function (e, t) {
            return this._labels[e] = this._parseTimeOrLabel(t), this
        }, i.addPause = function (e, t, i, n) {
            var r = Ss.delayedCall(0, a, i, n || this);
            return r.vars.onComplete = r.vars.onReverseComplete = t, r.data = "isPause", this._hasPause = !0, this.add(r, e)
        }, i.removeLabel = function (e) {
            return delete this._labels[e], this
        }, i.getLabelTime = function (e) {
            return null != this._labels[e] ? this._labels[e] : -1
        }, i._parseTimeOrLabel = function (e, t, i, n) {
            var r, a;
            if (n instanceof Ps && n.timeline === this) this.remove(n); else if (n && (n instanceof Array || n.push && c(n))) for (a = n.length; -1 < --a;) n[a] instanceof Ps && n[a].timeline === this && this.remove(n[a]);
            if (r = "number" != typeof e || t ? 99999999999 < this.duration() ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof t) return this._parseTimeOrLabel(t, i && "number" == typeof e && null == this._labels[t] ? e - r : 0, i);
            if (t = t || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = r); else {
                if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? i ? this._labels[e] = r + t : t : this._labels[e] + t;
                t = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = 1 < a ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, i) : r
            }
            return Number(e) + t
        }, i.seek = function (e, t) {
            return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), !1 !== t)
        }, i.stop = function () {
            return this.paused(!0)
        }, i.gotoAndPlay = function (e, t) {
            return this.play(e, t)
        }, i.gotoAndStop = function (e, t) {
            return this.pause(e, t)
        }, i.render = function (e, t, i) {
            this._gc && this._enabled(!0, !1);
            var n, r, a, o, s, l, h, c = this._time, u = this._dirty ? this.totalDuration() : this._totalDuration,
                p = this._startTime, d = this._timeScale, f = this._paused;
            if (c !== this._time && (e += this._time - c), u - 1e-7 <= e && 0 <= e) this._totalTime = this._time = u, this._reversed || this._hasPausedChild() || (r = !0, o = "onComplete", s = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && -1e-7 <= e || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== e && this._first && (s = !0, 1e-10 < this._rawPrevTime && (o = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-10, e = u + 1e-4; else if (e < 1e-7) if (this._totalTime = this._time = 0, (0 !== c || 0 === this._duration && 1e-10 !== this._rawPrevTime && (0 < this._rawPrevTime || e < 0 && 0 <= this._rawPrevTime)) && (o = "onReverseComplete", r = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (s = r = !0, o = "onReverseComplete") : 0 <= this._rawPrevTime && this._first && (s = !0), this._rawPrevTime = e; else {
                if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-10, 0 === e && r) for (n = this._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                e = 0, this._initted || (s = !0)
            } else {
                if (this._hasPause && !this._forcingPlayhead && !t) {
                    if (c <= e) for (n = this._first; n && n._startTime <= e && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (l = n), n = n._next; else for (n = this._last; n && n._startTime >= e && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                    l && (this._time = e = l._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                }
                this._totalTime = this._time = this._rawPrevTime = e
            }
            if (this._time !== c && this._first || i || s || l) {
                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && 0 < e && (this._active = !0), 0 === c && this.vars.onStart && (0 === this._time && this._duration || t || this._callback("onStart")), c <= (h = this._time)) for (n = this._first; n && (a = n._next, h === this._time && (!this._paused || f));) (n._active || n._startTime <= h && !n._paused && !n._gc) && (l === n && this.pause(), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = a; else for (n = this._last; n && (a = n._prev, h === this._time && (!this._paused || f));) {
                    if (n._active || n._startTime <= c && !n._paused && !n._gc) {
                        if (l === n) {
                            for (l = n._prev; l && l.endTime() > this._time;) l.render(l._reversed ? l.totalDuration() - (e - l._startTime) * l._timeScale : (e - l._startTime) * l._timeScale, t, i), l = l._prev;
                            l = null, this.pause()
                        }
                        n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)
                    }
                    n = a
                }
                this._onUpdate && (t || (m.length && g(), this._callback("onUpdate"))), o && (this._gc || p !== this._startTime && d === this._timeScale || (0 === this._time || u >= this.totalDuration()) && (r && (m.length && g(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[o] && this._callback(o)))
            }
        }, i._hasPausedChild = function () {
            for (var e = this._first; e;) {
                if (e._paused || e instanceof p && e._hasPausedChild()) return !0;
                e = e._next
            }
            return !1
        }, i.getChildren = function (e, t, i, n) {
            n = n || -9999999999;
            for (var r = [], a = this._first, o = 0; a;) a._startTime < n || (a instanceof Ss ? !1 !== t && (r[o++] = a) : (!1 !== i && (r[o++] = a), !1 !== e && (o = (r = r.concat(a.getChildren(!0, t, i))).length))), a = a._next;
            return r
        }, i.getTweensOf = function (e, t) {
            var i, n, r = this._gc, a = [], o = 0;
            for (r && this._enabled(!0, !0), n = (i = Ss.getTweensOf(e)).length; -1 < --n;) (i[n].timeline === this || t && this._contains(i[n])) && (a[o++] = i[n]);
            return r && this._enabled(!1, !0), a
        }, i.recent = function () {
            return this._recent
        }, i._contains = function (e) {
            for (var t = e.timeline; t;) {
                if (t === this) return !0;
                t = t.timeline
            }
            return !1
        }, i.shiftChildren = function (e, t, i) {
            i = i || 0;
            for (var n, r = this._first, a = this._labels; r;) r._startTime >= i && (r._startTime += e), r = r._next;
            if (t) for (n in a) a[n] >= i && (a[n] += e);
            return this._uncache(!0)
        }, i._kill = function (e, t) {
            if (!e && !t) return this._enabled(!1, !1);
            for (var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), n = i.length, r = !1; -1 < --n;) i[n]._kill(e, t) && (r = !0);
            return r
        }, i.clear = function (e) {
            var t = this.getChildren(!1, !0, !0), i = t.length;
            for (this._time = this._totalTime = 0; -1 < --i;) t[i]._enabled(!1, !1);
            return !1 !== e && (this._labels = {}), this._uncache(!0)
        }, i.invalidate = function () {
            for (var e = this._first; e;) e.invalidate(), e = e._next;
            return Ps.prototype.invalidate.call(this)
        }, i._enabled = function (e, t) {
            if (e === this._gc) for (var i = this._first; i;) i._enabled(e, !0), i = i._next;
            return Ms.prototype._enabled.call(this, e, t)
        }, i.totalTime = function (e, t, i) {
            this._forcingPlayhead = !0;
            var n = Ps.prototype.totalTime.apply(this, arguments);
            return this._forcingPlayhead = !1, n
        }, i.duration = function (e) {
            return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
        }, i.totalDuration = function (e) {
            if (arguments.length) return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this;
            if (this._dirty) {
                for (var t, i, n = 0, r = this._last, a = 999999999999; r;) t = r._prev, r._dirty && r.totalDuration(), r._startTime > a && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : a = r._startTime, r._startTime < 0 && !r._paused && (n -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), a = 0), n < (i = r._startTime + r._totalDuration / r._timeScale) && (n = i), r = t;
                this._duration = this._totalDuration = n, this._dirty = !1
            }
            return this._totalDuration
        }, i.paused = function (e) {
            if (!e) for (var t = this._first, i = this._time; t;) t._startTime === i && "isPause" === t.data && (t._rawPrevTime = 0), t = t._next;
            return Ps.prototype.paused.apply(this, arguments)
        }, i.usesFrames = function () {
            for (var e = this._timeline; e._timeline;) e = e._timeline;
            return e === Ps._rootFramesTimeline
        }, i.rawTime = function (e) {
            return e && (this._paused || this._repeat && 0 < this.time() && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(e) - this._startTime) * this._timeScale
        }, p
    }, !0);
    var Us = Es.TimelineLite;
    Ts._gsDefine("easing.Back", ["easing.Ease"], function () {
        var i, n, t, e, r = Ts.GreenSockGlobals || Ts, a = r.com.greensock, o = 2 * Math.PI, s = Math.PI / 2,
            l = a._class, h = function (e, t) {
                var i = l("easing." + e, function () {
                }, !0), n = i.prototype = new Ls;
                return n.constructor = i, n.getRatio = t, i
            }, c = Ls.register || function () {
            }, u = function (e, t, i, n, r) {
                var a = l("easing." + e, {easeOut: new t, easeIn: new i, easeInOut: new n}, !0);
                return c(a, e), a
            }, g = function (e, t, i) {
                this.t = e, this.v = t, i && (((this.next = i).prev = this).c = i.v - t, this.gap = i.t - e)
            }, p = function (e, t) {
                var i = l("easing." + e, function (e) {
                    this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
                }, !0), n = i.prototype = new Ls;
                return n.constructor = i, n.getRatio = t, n.config = function (e) {
                    return new i(e)
                }, i
            }, d = u("Back", p("BackOut", function (e) {
                return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
            }), p("BackIn", function (e) {
                return e * e * ((this._p1 + 1) * e - this._p1)
            }), p("BackInOut", function (e) {
                return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
            })), f = l("easing.SlowMo", function (e, t, i) {
                t = t || 0 === t ? t : .7, null == e ? e = .7 : 1 < e && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i
            }, !0), m = f.prototype = new Ls;
        return m.constructor = f, m.getRatio = function (e) {
            var t = e + (.5 - e) * this._p;
            return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 === e ? 0 : 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
        }, f.ease = new f(.7, .7), m.config = f.config = function (e, t, i) {
            return new f(e, t, i)
        }, (m = (i = l("easing.SteppedEase", function (e, t) {
            e = e || 1, this._p1 = 1 / e, this._p2 = e + (t ? 0 : 1), this._p3 = t ? 1 : 0
        }, !0)).prototype = new Ls).constructor = i, m.getRatio = function (e) {
            return e < 0 ? e = 0 : 1 <= e && (e = .999999999), ((this._p2 * e | 0) + this._p3) * this._p1
        }, m.config = i.config = function (e, t) {
            return new i(e, t)
        }, (m = (n = l("easing.ExpoScaleEase", function (e, t, i) {
            this._p1 = Math.log(t / e), this._p2 = t - e, this._p3 = e, this._ease = i
        }, !0)).prototype = new Ls).constructor = n, m.getRatio = function (e) {
            return this._ease && (e = this._ease.getRatio(e)), (this._p3 * Math.exp(this._p1 * e) - this._p3) / this._p2
        }, m.config = n.config = function (e, t, i) {
            return new n(e, t, i)
        }, (m = (t = l("easing.RoughEase", function (e) {
            for (var t, i, n, r, a, o, s = (e = e || {}).taper || "none", l = [], h = 0, c = 0 | (e.points || 20), u = c, p = !1 !== e.randomize, d = !0 === e.clamp, f = e.template instanceof Ls ? e.template : null, m = "number" == typeof e.strength ? .4 * e.strength : .4; -1 < --u;) t = p ? Math.random() : 1 / c * u, i = f ? f.getRatio(t) : t, n = "none" === s ? m : "out" === s ? (r = 1 - t) * r * m : "in" === s ? t * t * m : t < .5 ? (r = 2 * t) * r * .5 * m : (r = 2 * (1 - t)) * r * .5 * m, p ? i += Math.random() * n - .5 * n : u % 2 ? i += .5 * n : i -= .5 * n, d && (1 < i ? i = 1 : i < 0 && (i = 0)), l[h++] = {
                x: t, y: i
            };
            for (l.sort(function (e, t) {
                return e.x - t.x
            }), o = new g(1, 1, null), u = c; -1 < --u;) a = l[u], o = new g(a.x, a.y, o);
            this._prev = new g(0, 0, 0 !== o.t ? o : o.next)
        }, !0)).prototype = new Ls).constructor = t, m.getRatio = function (e) {
            var t = this._prev;
            if (e > t.t) {
                for (; t.next && e >= t.t;) t = t.next;
                t = t.prev
            } else for (; t.prev && e <= t.t;) t = t.prev;
            return (this._prev = t).v + (e - t.t) / t.gap * t.c
        }, m.config = function (e) {
            return new t(e)
        }, t.ease = new t, u("Bounce", h("BounceOut", function (e) {
            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        }), h("BounceIn", function (e) {
            return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : e < 2 / 2.75 ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
        }), h("BounceInOut", function (e) {
            var t = e < .5;
            return (e = t ? 1 - 2 * e : 2 * e - 1) < 1 / 2.75 ? e *= 7.5625 * e : e = e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
        })), u("Circ", h("CircOut", function (e) {
            return Math.sqrt(1 - (e -= 1) * e)
        }), h("CircIn", function (e) {
            return -(Math.sqrt(1 - e * e) - 1)
        }), h("CircInOut", function (e) {
            return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        })), u("Elastic", (e = function (e, t, i) {
            var n = l("easing." + e, function (e, t) {
                this._p1 = 1 <= e ? e : 1, this._p2 = (t || i) / (e < 1 ? e : 1), this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0), this._p2 = o / this._p2
            }, !0), r = n.prototype = new Ls;
            return r.constructor = n, r.getRatio = t, r.config = function (e, t) {
                return new n(e, t)
            }, n
        })("ElasticOut", function (e) {
            return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
        }, .3), e("ElasticIn", function (e) {
            return -this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2)
        }, .3), e("ElasticInOut", function (e) {
            return (e *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1
        }, .45)), u("Expo", h("ExpoOut", function (e) {
            return 1 - Math.pow(2, -10 * e)
        }), h("ExpoIn", function (e) {
            return Math.pow(2, 10 * (e - 1)) - .001
        }), h("ExpoInOut", function (e) {
            return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
        })), u("Sine", h("SineOut", function (e) {
            return Math.sin(e * s)
        }), h("SineIn", function (e) {
            return 1 - Math.cos(e * s)
        }), h("SineInOut", function (e) {
            return -.5 * (Math.cos(Math.PI * e) - 1)
        })), l("easing.EaseLookup", {
            find: function (e) {
                return Ls.map[e]
            }
        }, !0), c(r.SlowMo, "SlowMo", "ease,"), c(t, "RoughEase", "ease,"), c(i, "SteppedEase", "ease,"), d
    }, !0);
    Es.Back, Es.Elastic, Es.Bounce, Es.RoughEase, Es.SlowMo, Es.SteppedEase, Es.Circ, Es.Expo, Es.Sine, Es.ExpoScaleEase;

    function Ds(e) {
        e.getChildren().forEach(function (e) {
            var t = !e.vars.data || void 0 === e.vars.data.clear || !0 === e.vars.data.clear;
            if (e.target && e.vars && e.vars.css && t) {
                var i;
                for (var n in e.vars.css) i ? i += "," : i = "", "autoAlpha" === n && (n = "opacity,visibility"), i += n;
                i && function t(e, i) {
                    Array.isArray(e) ? e.forEach(function (e) {
                        t(e, i)
                    }) : (e.jquery || 1 === e.nodeType || "string" == typeof e) && Ss.set(e, {clearProps: i})
                }(e.target, i)
            }
        })
    }

    var zs, Bs = e(function (e) {
        var i, r, t, W, Y, q, a, Q, o, Z, J, n, K, s, $, l, h, c = e.exports && void 0 !== u ? u : u || window;
        r = (i = c).GreenSockGlobals || i, t = function (e) {
            var t, i = e.split("."), n = r;
            for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {};
            return n
        }("com.greensock.utils"), W = function e(t) {
            var i = t.nodeType, n = "";
            if (1 === i || 9 === i || 11 === i) {
                if ("string" == typeof t.textContent) return t.textContent;
                for (t = t.firstChild; t; t = t.nextSibling) n += e(t)
            } else if (3 === i || 4 === i) return t.nodeValue;
            return n
        }, Y = document, q = Y.defaultView ? Y.defaultView.getComputedStyle : function () {
        }, a = /([A-Z])/g, Q = function (e, t, i, n) {
            var r;
            return (i = i || q(e, null)) ? r = (e = i.getPropertyValue(t.replace(a, "-$1").toLowerCase())) || i.length ? e : i[t] : e.currentStyle && (r = (i = e.currentStyle)[t]), n ? r : parseInt(r, 10) || 0
        }, o = function (e) {
            return !!(e.length && e[0] && (e[0].nodeType && e[0].style && !e.nodeType || e[0].length && e[0][0]))
        }, Z = ")eefec303079ad17405c", J = /(?:<br>|<br\/>|<br \/>)/gi, n = "<div style='position:relative;display:inline-block;" + (Y.all && !Y.addEventListener ? "*display:inline;*zoom:1;'" : "'"), K = function (e) {
            var t = -1 !== (e = e || "").indexOf("++"), i = 1;
            return t && (e = e.split("++").join("")), function () {
                return n + (e ? " class='" + e + (t ? i++ : "") + "'>" : ">")
            }
        }, s = t.SplitText = r.SplitText = function (e, t) {
            if ("string" == typeof e && (e = s.selector(e)), !e) throw"cannot split a null element.";
            this.elements = o(e) ? function (e) {
                var t, i, n, r = [], a = e.length;
                for (t = 0; t < a; t++) if (i = e[t], o(i)) for (n = i.length, n = 0; n < i.length; n++) r.push(i[n]); else r.push(i);
                return r
            }(e) : [e], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t)
        }, $ = function (e, t) {
            for (var i = t.length; -1 < --i;) e.push(t[i])
        }, l = function (e, t, i, n, r) {
            J.test(e.innerHTML) && (e.innerHTML = e.innerHTML.replace(J, Z));
            var a, o, s, l, h, c, u, p, d, f, m, g, v, y, _ = W(e), x = t.type || t.split || "chars,words,lines",
                b = -1 !== x.indexOf("lines") ? [] : null, w = -1 !== x.indexOf("words"), T = -1 !== x.indexOf("chars"),
                S = "absolute" === t.position || !0 === t.absolute, E = S ? "&#173; " : " ", A = -999, M = q(e),
                P = Q(e, "paddingLeft", M), L = Q(e, "borderBottomWidth", M) + Q(e, "borderTopWidth", M),
                C = Q(e, "borderLeftWidth", M) + Q(e, "borderRightWidth", M),
                I = Q(e, "paddingTop", M) + Q(e, "paddingBottom", M),
                R = Q(e, "paddingLeft", M) + Q(e, "paddingRight", M), O = Q(e, "textAlign", M, !0), F = e.clientHeight,
                N = e.clientWidth, k = "</div>", U = K(t.wordsClass), D = K(t.charsClass),
                z = -1 !== (t.linesClass || "").indexOf("++"), B = t.linesClass, H = -1 !== _.indexOf("<"), G = !0,
                j = [], V = [], X = [];
            for (z && (B = B.split("++").join("")), H && (_ = _.split("<").join("{{LT}}")), a = _.length, l = U(), h = 0; h < a; h++) if (")" === (u = _.charAt(h)) && _.substr(h, 20) === Z) l += (G ? k : "") + "<BR/>", G = !1, h !== a - 20 && _.substr(h + 20, 20) !== Z && (l += " " + U(), G = !0), h += 19; else if (" " === u && " " !== _.charAt(h - 1) && h !== a - 1 && _.substr(h - 20, 20) !== Z) {
                for (l += G ? k : "", G = !1; " " === _.charAt(h + 1);) l += E, h++;
                ")" === _.charAt(h + 1) && _.substr(h + 1, 20) === Z || (l += E + U(), G = !0)
            } else l += T && " " !== u ? D() + u + "</div>" : u;
            for (e.innerHTML = l + (G ? k : ""), H && function e(t, i, n) {
                var r = t.nodeType;
                if (1 === r || 9 === r || 11 === r) for (t = t.firstChild; t; t = t.nextSibling) e(t, i, n); else 3 !== r && 4 !== r || (t.nodeValue = t.nodeValue.split(i).join(n))
            }(e, "{{LT}}", "<"), a = (c = e.getElementsByTagName("*")).length, p = [], h = 0; h < a; h++) p[h] = c[h];
            if (b || S) for (h = 0; h < a; h++) ((s = (d = p[h]).parentNode === e) || S || T && !w) && (f = d.offsetTop, b && s && f !== A && "BR" !== d.nodeName && (o = [], b.push(o), A = f), S && (d._x = d.offsetLeft, d._y = f, d._w = d.offsetWidth, d._h = d.offsetHeight), b && (w !== s && T || (o.push(d), d._x -= P), s && h && (p[h - 1]._wordEnd = !0), "BR" === d.nodeName && d.nextSibling && "BR" === d.nextSibling.nodeName && b.push([])));
            for (h = 0; h < a; h++) s = (d = p[h]).parentNode === e, "BR" !== d.nodeName ? (S && (g = d.style, w || s || (d._x += d.parentNode._x, d._y += d.parentNode._y), g.left = d._x + "px", g.top = d._y + "px", g.position = "absolute", g.display = "block", g.width = d._w + 1 + "px", g.height = d._h + "px"), w ? s && "" !== d.innerHTML ? V.push(d) : T && j.push(d) : s ? (e.removeChild(d), p.splice(h--, 1), a--) : !s && T && (f = !b && !S && d.nextSibling, e.appendChild(d), f || e.appendChild(Y.createTextNode(" ")), j.push(d))) : b || S ? (e.removeChild(d), p.splice(h--, 1), a--) : w || e.appendChild(d);
            if (b) {
                for (S && (m = Y.createElement("div"), e.appendChild(m), v = m.offsetWidth + "px", f = m.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(m)), g = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;) e.removeChild(e.firstChild);
                for (y = !S || !w && !T, h = 0; h < b.length; h++) {
                    for (o = b[h], (m = Y.createElement("div")).style.cssText = "display:block;text-align:" + O + ";position:" + (S ? "absolute;" : "relative;"), B && (m.className = B + (z ? h + 1 : "")), X.push(m), a = o.length, c = 0; c < a; c++) "BR" !== o[c].nodeName && (d = o[c], m.appendChild(d), y && (d._wordEnd || w) && m.appendChild(Y.createTextNode(" ")), S && (0 === c && (m.style.top = d._y + "px", m.style.left = P + f + "px"), d.style.top = "0px", f && (d.style.left = d._x - f + "px")));
                    0 === a && (m.innerHTML = "&nbsp;"), w || T || (m.innerHTML = W(m).split(String.fromCharCode(160)).join(" ")), S && (m.style.width = v, m.style.height = d._h + "px"), e.appendChild(m)
                }
                e.style.cssText = g
            }
            S && (F > e.clientHeight && (e.style.height = F - I + "px", e.clientHeight < F && (e.style.height = F + L + "px")), N > e.clientWidth && (e.style.width = N - R + "px", e.clientWidth < N && (e.style.width = N + C + "px"))), $(i, j), $(n, V), $(r, X)
        }, (h = s.prototype).split = function (e) {
            this.isSplit && this.revert(), this.vars = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
            for (var t = this.elements.length; -1 < --t;) this._originals[t] = this.elements[t].innerHTML, l(this.elements[t], this.vars, this.chars, this.words, this.lines);
            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
        }, h.revert = function () {
            if (!this._originals) throw"revert() call wasn't scoped properly.";
            for (var e = this._originals.length; -1 < --e;) this.elements[e].innerHTML = this._originals[e];
            return this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
        }, s.selector = i.$ || i.jQuery || function (e) {
            var t = i.$ || i.jQuery;
            return t ? (s.selector = t)(e) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e)
        }, s.version = "0.3.3", e.exports && (e.exports = (c.GreenSockGlobals || c).SplitText)
    }), Hs = function () {
        function t(e) {
            es(this, t), this.element = e.element, this.lines = this.element.querySelector(".scroll-cta__lines"), this.line2 = this.lines.querySelector("div:nth-child(2)"), this.labelBackground = this.element.querySelector(".scroll-cta__label--background"), this.labelMask = this.element.querySelector(".scroll-cta__label__mask"), this.labelMaskInner = this.element.querySelector(".scroll-cta__label__mask__inner"), this.timeline = null, this.isVisible = !0
        }

        return is(t, [{
            key: "dispose", value: function () {
            }
        }, {
            key: "disposeTimeline", value: function () {
                this.timeline && (this.timeline.kill(), Ds(this.timeline), this.timeline = null)
            }
        }, {
            key: "setVisibility", value: function (e) {
                this.isVisible !== e && (this.isVisible = e, this.element.style.visibility = this.isVisible ? "" : "hidden", this.isVisible ? this.animateIn() : this.animateOut())
            }
        }, {
            key: "animateIn", value: function () {
                return this.disposeTimeline(), this.timeline = new Us({onComplete: this.onTimelineComplete.bind(this)}).from(this.lines, .9, {
                    scaleY: 0, yPercent: 100, ease: Ns.easeOut
                }, 0).from(this.line2, .9, {
                    scaleY: 1, ease: Ns.easeOut
                }, .7).from(this.labelBackground, .4, {opacity: 0}, .4).from(this.labelMask, .9, {
                    xPercent: -100, ease: Ns.easeOut
                }, 1).from(this.labelMaskInner, .9, {xPercent: 100, ease: Ns.easeOut}, 1), this.timeline
            }
        }, {
            key: "animateOut", value: function () {
                return this.disposeTimeline(), this.timeline = new Us({onComplete: this.onTimelineComplete.bind(this)}).set(this.element, {visibility: "inherit"}, 0).to(this.labelMask, .4, {
                    xPercent: -100, ease: Ns.easeIn
                }, 0).to(this.labelMaskInner, .4, {
                    xPercent: 100, ease: Ns.easeIn
                }, 0).to(this.labelBackground, .4, {opacity: 0}, .4).to(this.line2, .4, {
                    scaleY: 1, ease: Ns.easeOut
                }, .4).to(this.lines, .5, {scaleY: 0, yPercent: 100, ease: Ns.easeOut}, .9), this.timeline
            }
        }, {
            key: "onTimelineComplete", value: function () {
                this.disposeTimeline(), this.element.style.visibility = this.isVisible ? "" : "hidden"
            }
        }]), t
    }(), Gs = function () {
        function e() {
            es(this, e)
        }

        return is(e, [{
            key: "resize", value: function () {
            }
        }, {
            key: "reset", value: function () {
            }
        }, {
            key: "clear", value: function () {
            }
        }, {
            key: "render", value: function (e) {
            }
        }]), e
    }(), js = ["", "ms", "Webkit", "Moz", "O"], Vs = js.length, Xs = {};

    function Ws(e) {
        if (Xs[e]) return Xs[e];
        zs || (zs = document.createElement("div"));
        for (var t = e, i = 0; i < Vs; i++) {
            var n = js[i], r = n + (e = "" === n ? e : e.charAt(0).toUpperCase() + e.substring(1).toLowerCase());
            if (void 0 !== zs.style[r]) {
                t = r;
                break
            }
        }
        return Xs[e] = t
    }

    for (var Ys = Ws("transform"), qs = function (e) {
        function n(e) {
            var t;
            es(this, n), (t = ls(this, rs(n).call(this))).element = e.element, t.background = t.element.querySelector(".page__line__background"), t.runner = t.element.querySelector(".page__line__runner");
            var i = ".page__title, .page__section__title";
            return e.stepsSelector && (i += "," + e.stepsSelector), t.stepElements = t.element.parentNode.querySelectorAll(i), t.isVisible = !1, t.scrollable = !0, t.y = 0, t.numSteps = t.stepElements.length, t.currentStepIndex = 0, t
        }

        return ns(n, Gs), is(n, [{
            key: "initSteps", value: function () {
                var i = this;
                this.steps = [], cs(this.stepElements).forEach(function (e) {
                    var t = e.getBoundingClientRect();
                    i.steps.push(t.y)
                }), this.y = this.steps[this.currentStepIndex]
            }
        }, {
            key: "dispose", value: function () {
            }
        }, {
            key: "resize", value: function () {
                this.initSteps(), this.scrollable = app.windowWidth >= app.screenS
            }
        }, {
            key: "render", value: function (e) {
                if (this.isVisible && this.scrollable) {
                    var t = this.steps[this.currentStepIndex];
                    if (!e.isInertialScroll) {
                        for (var i = Number.MAX_VALUE, n = 0; n < this.numSteps; n++) {
                            var r = this.steps[n];
                            if (!(r < e.scrollTop || r > e.scrollTop + app.windowHeight)) {
                                var a = Math.abs(e.scrollTop - r);
                                a < i && (this.currentStepIndex = n), i = a
                            }
                        }
                        t = this.steps[this.currentStepIndex]
                    }
                    var o = 1 + .1 * e.diffProgress, s = this.y;
                    this.y += .08 * (t - this.y), this.isActive = .001 < Math.abs(s - this.y), this.runner.style[Ys] = "translateY(".concat(this.y, "px) scaleY(").concat(o, ")")
                }
            }
        }, {
            key: "animateIn", value: function () {
                return app.windowWidth >= app.screenS && "safari" === app.browser && (this.element.style.display = "none", this.element.offsetHeight, this.element.style.display = ""), new Us({onComplete: this.onAnimateInComplete.bind(this)}).from(this.background, 1, {
                    scaleY: 0, ease: Os.easeInOut
                }, 0).fromTo(this.runner, 1, {scaleY: 2, yPercent: -200}, {
                    y: this.y, scaleY: 1, yPercent: 0, data: {clear: !1}, ease: Os.easeInOut
                }, .3)
            }
        }, {
            key: "onAnimateInComplete", value: function () {
                this.isVisible = !0
            }
        }]), n
    }(), Qs = e(function (o) {
        (function () {
            var e, t, i, n, r, a;
            "undefined" != typeof performance && null !== performance && performance.now ? o.exports = function () {
                return performance.now()
            } : "undefined" != typeof process && null !== process && process.hrtime ? (o.exports = function () {
                return (e() - r) / 1e6
            }, t = process.hrtime, n = (e = function () {
                var e;
                return 1e9 * (e = t())[0] + e[1]
            })(), a = 1e9 * process.uptime(), r = n - a) : i = Date.now ? (o.exports = function () {
                return Date.now() - i
            }, Date.now()) : (o.exports = function () {
                return (new Date).getTime() - i
            }, (new Date).getTime())
        }).call(u)
    }), Zs = "undefined" == typeof window ? u : window, Js = ["moz", "webkit"], Ks = "AnimationFrame", $s = Zs["request" + Ks], el = Zs["cancel" + Ks] || Zs["cancelRequest" + Ks], tl = 0; !$s && tl < Js.length; tl++) $s = Zs[Js[tl] + "Request" + Ks], el = Zs[Js[tl] + "Cancel" + Ks] || Zs[Js[tl] + "CancelRequest" + Ks];
    if (!$s || !el) {
        var il = 0, nl = 0, rl = [];
        $s = function (e) {
            if (0 === rl.length) {
                var t = Qs(), i = Math.max(0, 1e3 / 60 - (t - il));
                il = i + t, setTimeout(function () {
                    for (var e = rl.slice(0), t = rl.length = 0; t < e.length; t++) if (!e[t].cancelled) try {
                        e[t].callback(il)
                    } catch (e) {
                        setTimeout(function () {
                            throw e
                        }, 0)
                    }
                }, Math.round(i))
            }
            return rl.push({handle: ++nl, callback: e, cancelled: !1}), nl
        }, el = function (e) {
            for (var t = 0; t < rl.length; t++) rl[t].handle === e && (rl[t].cancelled = !0)
        }
    }
    var al = function (e) {
        return $s.call(Zs, e)
    };
    al.cancel = function () {
        el.apply(Zs, arguments)
    }, al.polyfill = function (e) {
        e || (e = Zs), e.requestAnimationFrame = $s, e.cancelAnimationFrame = el
    };
    var ol = Ws("transform"), sl = "js-scroll-locked", ll = function (e) {
        function r() {
            var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            es(this, r), e = ls(this, rs(r).call(this));
            var i = {containerScrollable: !0, containerSelector: ".scroll-container"};
            for (var n in i) t.hasOwnProperty(n) || (t[n] = i[n]);
            return e.containerScrollable = t.containerScrollable, e.containerSelector = t.containerSelector, e.isSleeping = !0, e.oldScrollTop = -1, e.scrollTop = 0, e.pageHeight = 0, e.windowHeight = window.innerHeight, e.isTicking = !1, e.onFrameCb = e.onFrame.bind(ss(ss(e))), e.onFrameCbId = 0, e.isInertialScroll = !1, e.items = [], e.itemsToRemove = [], e.direction = 1, e.locked = !1, e.lockedScrollTop = 0, e.isFirstFrameAfterUnlock = !1, e.containerY = 0, e.containerOldY = 0, e.body = document.querySelector('#__nuxt'), e.hasActiveItem = !1, e.diffProgress = 0, e.container = document.querySelector(e.containerSelector), e.containerScrollable && e.container.classList.add("js-scrollable"), e.onScrollCb = e.onScroll.bind(ss(ss(e))), window.addEventListener("scroll", e.onScrollCb), e
        }

        return ns(r, ps), is(r, [{
            key: "dispose", value: function () {
                this.stopTicker(), this.clear(), window.removeEventListener("scroll", this.onScrollCb), this.off("locked").off("unlocked").off("firstFrameAfterUnlock"), this.locked && this.body.classList.remove(sl), this.containerScrollable && (this.container.style[ol] = "", this.body.style.height = ""), this.onScrollExternalCb = null
            }
        }, {
            key: "resize", value: function (e) {
                if (!this.locked) {
                    this.isInertialScroll = !1, this.pageHeight = this.container.clientHeight, this.windowHeight = window.innerHeight, this.containerScrollable && this.resizeBody();
                    for (var t = 0, i = this.items.length; t < i; t++) {
                        this.items[t].resize(this)
                    }
                    this.render()
                }
            }
        }, {
            key: "resizeBody", value: function () {
                this.body.style.height = Math.floor(this.pageHeight) + "px"
            }
        }, {
            key: "clear", value: function () {
                this.items.length = 0, this.itemsToRemove.length = 0
            }
        }, {
            key: "clearTransforms", value: function () {
                for (var e = 0, t = this.items.length; e < t; e++) {
                    this.items[e].clear()
                }
            }
        }, {
            key: "lock", value: function () {
                this.locked = !0, this.lockedScrollTop = 0, this.containerY = this.containerOldY = 0, this.body.classList.add(sl), this.containerScrollable && (this.container.style[ol] = ""), this.container.style.top = -this.lockedScrollTop + "px", this.stopTicker(), this.emit("locked")
            }
        }, {
            key: "unlock", value: function () {
                this.scrollTop = this.lockedScrollTop, this.body.classList.remove(sl), this.containerScrollable ? this.resizeBody() : this.body.style.height = "", this.locked = !1, this.isFirstFrameAfterUnlock = !0, window.scrollTo(0, this.lockedScrollTop), this.emit("unlocked")
            }
        }, {
            key: "addItem", value: function (e) {
                return this.items.push(e), e
            }
        }, {
            key: "addItems", value: function (e) {
                for (var t = 0, i = e.length; t < i; t++) this.addItem(e[t])
            }
        }, {
            key: "startTicker", value: function () {
                this.isTicking || (this.isTicking = !0, this.onFrameCbId = al(this.onFrameCb))
            }
        }, {
            key: "stopTicker", value: function () {
                this.isTicking && (this.isTicking = !1, this.isSleeping = !0, al.cancel(this.onFrameCbId))
            }
        }, {
            key: "removeItem", value: function (e) {
                -1 !== this.items.indexOf(e) && (e.needsRemove = !1, this.itemsToRemove.push(e))
            }
        }, {
            key: "render", value: function () {
                if (this.isFirstFrameAfterUnlock && (this.isFirstFrameAfterUnlock = !1, this.container.style.top = "", this.emit("firstFrameAfterUnlock")), !this.isInertialScroll) for (var e, t; this.itemsToRemove.length;) e = this.itemsToRemove.pop(), t = this.items.indexOf(e), this.items.splice(t, 1);
                this.containerScrollable ? (this.containerY += .08 * (this.scrollTop - this.containerY), this.diffProgress = Math.abs(this.containerY - this.containerOldY), this.hasActiveItem = .001 < this.diffProgress, this.hasActiveItem || (this.containerY = Math.round(this.containerY)), this.container.style[ol] = "translate3d(0," + -1 * this.containerY + "px,0)", this.containerOldY = this.containerY) : this.containerY = this.scrollTop;
                for (var i = 0, n = this.items.length; i < n; i++) {
                    var r = this.items[i];
                    r.render(this), this.hasActiveItem || (this.hasActiveItem = r.isActive), r.needsRemove && this.removeItem(r)
                }
                !this.isInertialScroll && this.onScrollExternalCb && this.onScrollExternalCb(), this.hasActiveItem || (this.isSleeping = !0), this.isInertialScroll = !0
            }
        }, {
            key: "onFrame", value: function () {
                this.isSleeping ? this.isTicking = !1 : (this.render(), this.onFrameCbId = al(this.onFrameCb))
            }
        }, {
            key: "onScroll", value: function (e) {
                this.locked || (this.scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.querySelector('#__nuxt').scrollTop || 0, this.direction = this.scrollTop > this.oldScrollTop ? 1 : -1, this.oldScrollTop = this.scrollTop, this.isInertialScroll = !1, this.isSleeping && (this.isSleeping = !1, this.startTicker()))
            }
        }]), r
    }(), hl = Ws("transform"), cl = function (e) {
        function n() {
            var e, t = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            for (var i in es(this, n), (e = ls(this, rs(n).call(this))).isVisible = !1, e.mediaMatched = !0, e.sticky = !1, e.smoothScroll = !1, e.inView = !1, e.trigger = null, e.calcTrigger = null, e.data = {}, e.element = null, e.target = null, e.offset = 0, e.y = 0, e.oldY = 0, e.inertia = .068, e.duration = Number.MAX_VALUE, e.autoRemove = !0, e.reverse = !0, e.triggered = !1, e.media = null, e.calcMaxY = null, e.calcOffset = null, e.calcDuration = null, e.maxY = 0, e.onResize = null, e.onUpdate = null, e.onEnter = null, e.onExit = null, e.toggleClass = null, e.offsetOrigin = 0, e.autoResize = !0, t) void 0 !== e[i] && (e[i] = t[i]);
            return e.isActive = !1, e.needsRemove = !1, e.hasTrigger = e.trigger || e.calcTrigger, e.element || (e.element = e.target), e.isNode = e.target && 0 < e.target.nodeType, e
        }

        return ns(n, Gs), is(n, [{
            key: "resize", value: function (e) {
                var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
                if (this.autoResize || !t) if (this.mediaMatched = !this.media || ("function" == typeof this.media ? this.media() : window.innerWidth > this.media), this.mediaMatched) {
                    var i = this.element.style[hl];
                    this.element.style[hl] = "", this.height = this.element.clientHeight, this.top = e.scrollTop + this.element.getBoundingClientRect().top, this.bottom = this.top + this.height, this.offsetOrigin = this.top - .5 * (window.innerHeight - this.height), this.element.style[hl] = i, this.calcMaxY && (this.maxY = this.calcMaxY()), this.calcOffset && (this.offset = this.calcOffset()), this.calcDuration && (this.duration = this.calcDuration()), this.calcTrigger && (this.trigger = this.calcTrigger()), this.onResize && this.onResize()
                } else this.reset()
            }
        }, {
            key: "clear", value: function () {
                item.isNode && (item.target.style[hl] = "")
            }
        }, {
            key: "reset", value: function () {
                (this.smoothScroll || this.sticky) && (this.target.style[hl] = ""), this.toggleClass && this.target.classList.remove(this.toggleClass)
            }
        }, {
            key: "render", value: function (e) {
                if (this.mediaMatched) {
                    var t, i, n;
                    if (this.smoothScroll && (i = (this.offsetOrigin - e.scrollTop) / e.pageHeight, this.y += (i * this.offset - this.y) * this.inertia, (t = Math.abs(i) < 1.5) && !e.hasActiveItem && (n = Math.abs(this.y - this.oldY), this.isActive = .001 < n, isActive || (item.y = Math.round(item.y))), this.oldY = this.y, t && (this.isNode ? this.target.style[hl] = "translate3d(0," + -this.y + "px,0)" : this.target.y = -this.y, this.onUpdate && this.onUpdate())), this.sticky && e.containerScrollable && (this.y = e.containerY, this.maxY && this.y > this.maxY && (this.y = this.maxY), this.target.style[hl] = "translate3d(0," + this.y + "px,0)"), this.inView) {
                        var r = this.isVisible;
                        this.isVisible = !(this.top + this.offset > e.containerY + e.windowHeight || this.bottom < e.containerY), !r && this.isVisible ? (this.onEnter && this.onEnter(), this.toggleClass && this.target.classList.add(this.toggleClass), this.autoRemove && (this.needsRemove = !0)) : r && !this.isVisible && this.reverse && (this.onExit && this.onExit(), this.toggleClass && this.target.classList.remove(this.toggleClass))
                    }
                    if (this.hasTrigger && !e.isInertialScroll) {
                        var a = this.triggered;
                        this.triggered = e.scrollTop >= this.trigger && e.scrollTop <= this.trigger + this.duration, !a && this.triggered ? (this.onEnter && this.onEnter(), this.toggleClass && this.target.classList.add(this.toggleClass), this.autoRemove && (this.needsRemove = !0)) : a && !this.triggered && (this.onExit && this.onExit(), this.toggleClass && this.target.classList.remove(this.toggleClass))
                    }
                }
            }
        }]), n
    }(), ul = "light", pl = "dark";
    Ts._gsDefine.plugin({
        propName: "attr", API: 2, version: "0.6.1", init: function (e, t, i, n) {
            var r, a;
            if ("function" != typeof e.setAttribute) return !1;
            for (r in t) "function" == typeof (a = t[r]) && (a = a(n, e)), this._addTween(e, "setAttribute", e.getAttribute(r) + "", a + "", r, !1, r), this._overwriteProps.push(r);
            return !0
        }
    }), e(function (e) {
        var t = e.exports && void 0 !== u ? u : u || window;
        (t._gsQueue || (t._gsQueue = [])).push(function () {
            function c(e, t, i, n) {
                return i = parseFloat(i) - parseFloat(e), n = parseFloat(n) - parseFloat(t), Math.sqrt(i * i + n * n)
            }

            function u(e) {
                return "string" != typeof e && e.nodeType || (e = t.TweenLite.selector(e)).length && (e = e[0]), e
            }

            function d(e) {
                if (!e) return 0;
                var t, i, n, r, a, o, s, l, h = (e = u(e)).tagName.toLowerCase();
                if ("path" === h) t = e.getTotalLength() || 0; else if ("rect" === h) t = 2 * ((i = e.getBBox()).width + i.height); else if ("circle" === h) t = 2 * Math.PI * parseFloat(e.getAttribute("r")); else if ("line" === h) t = c(e.getAttribute("x1"), e.getAttribute("y1"), e.getAttribute("x2"), e.getAttribute("y2")); else if ("polyline" === h || "polygon" === h) for (a = (n = e.getAttribute("points").split(" "))[t = 0].split(","), "polygon" === h && (n.push(n[0]), -1 === n[0].indexOf(",") && n.push(n[1])), o = 1; o < n.length; o++) 1 === (r = n[o].split(",")).length && (r[1] = n[o++]), 2 === r.length && (t += c(a[0], a[1], r[0], r[1]) || 0, a = r); else "ellipse" === h && (s = parseFloat(e.getAttribute("rx")), l = parseFloat(e.getAttribute("ry")), t = Math.PI * (3 * (s + l) - Math.sqrt((3 * s + l) * (s + 3 * l))));
                return t || 0
            }

            var e, a = document.defaultView ? document.defaultView.getComputedStyle : function () {
            };

            function f(e, t) {
                if (!e) return [0, 0];
                e = u(e), t = t || d(e) + 1;
                var i = a(e), n = i.strokeDasharray || "", r = parseFloat(i.strokeDashoffset);
                return t < (n = -1 === n.indexOf(" ") ? t : parseFloat(n.split(" ")[0]) || 1e-5) && (n = t), [Math.max(0, -r), n - r]
            }

            (e = t._gsDefine.plugin({
                propName: "drawSVG",
                API: 2,
                version: "0.0.4",
                global: !0,
                overwriteProps: ["drawSVG"],
                init: function (e, t, i) {
                    if (!e.getBBox) return !1;
                    var n, r, a, o, s, l, h, c, u, p = d(e) + 1;
                    return this._style = e.style, !0 === t || "true" === t ? t = "0 100%" : t ? -1 === (t + "").indexOf(" ") && (t = "0 " + t) : t = "0 0", n = f(e, p), o = t, s = p, l = n[0], u = o.indexOf(" "), c = -1 === u ? (h = void 0 !== l ? l + "" : o, o) : (h = o.substr(0, u), o.substr(u + 1)), h = -1 !== h.indexOf("%") ? parseFloat(h) / 100 * s : parseFloat(h), r = (c = -1 !== c.indexOf("%") ? parseFloat(c) / 100 * s : parseFloat(c)) < h ? [c, h] : [h, c], this._length = p + 10, 0 === n[0] && 0 === r[0] ? (a = Math.max(1e-5, r[1] - p), this._dash = p + a, this._offset = p - n[1] + a, this._addTween(this, "_offset", this._offset, p - r[1] + a, "drawSVG")) : (this._dash = n[1] - n[0] || 1e-6, this._offset = -n[0], this._addTween(this, "_dash", this._dash, r[1] - r[0] || 1e-5, "drawSVG"), this._addTween(this, "_offset", this._offset, -r[0], "drawSVG")), !0
                },
                set: function (e) {
                    this._firstPT && (this._super.setRatio.call(this, e), this._style.strokeDashoffset = this._offset, this._style.strokeDasharray = this._dash + " " + this._length)
                }
            })).getLength = d, e.getPosition = f
        }), t._gsDefine && t._gsQueue.pop()()
    });
    var dl = 0, fl = new (function (e) {
        function t() {
            var e;
            return es(this, t), (e = ls(this,
                rs(t).call(this))).color = dl,
                e.element = document.querySelector(".logo"),
                e.maskRect = document.querySelector("#logo__mask rect"),
                e.shapePath = e.element.querySelector(".logo__img path[data-id=shape]"),
                e.textPath = e.element.querySelector(".logo__img path[data-id=text]"),
                e.textPath.style.clipPath = "url(#logo__mask)",
                e.isVisible = !1,
            app.hasTouch || (e.element.addEventListener("mouseenter",
                e.onRollOver.bind(ss(ss(e)))), e.element.addEventListener("mouseleave", e.onRollOut.bind(ss(ss(e))))), e
        }

        return ns(t, ps), is(t, [{
            key: "setColor", value: function (e) {
                e !== this.color && (this.color = e)
            }
        }, {
            key: "show", value: function () {
                this.isVisible = !0, this.element.style.visibility = "inherit"
            }
        }, {
            key: "onRollOver", value: function () {
                var e = this.element.querySelector(".logo__img-background");
                Ss.killTweensOf([e, this.shapePath]), (new Us).set(e, {visibility: "inherit"}).to(this.shapePath, .7, {
                    drawSVG: "100% 100%", ease: Os.easeOut
                })
            }
        }, {
            key: "onRollOut", value: function () {
                var e = this.element.querySelector(".logo__img-background");
                Ss.killTweensOf([e, this.shapePath]), (new Us).to(this.shapePath, .7, {
                    drawSVG: "100% 0", ease: Os.easeOut
                }).set(e, {clearProps: "visibility"})
            }
        }]), t
    }()), ml = function (e) {

        function i(e) {

            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).pageId = e.id, t.element = document.querySelector(".main-loading"), t.progressElement = t.element.querySelector(".main-loading__bar__progress"), t.progress = 0, t.progressTween = null, t.timeline = null, t
        }

        return ns(i, ps), is(i, [{
            key: "dispose", value: function () {
            }
        }, {
            key: "animateIn", value: function () {
                if ("msie" === app.browser) return this.animateInWithoutCss();
                var i = Ws("animation-play-state"), e = new Promise(function (e) {
                    if (Modernizr.cssanimations) {
                        var t = document.querySelector(".main-loading__bar__total");
                        "running" === getComputedStyle(t).getPropertyValue(i) ? t.addEventListener("animationend", e) : e()
                    } else e()
                }), t = new Promise(function (e) {
                    if (Modernizr.cssanimations) {
                        var t = document.querySelector(".main-loading__logo path[data-id=shape]");
                        "running" === getComputedStyle(t).getPropertyValue(i) ? t.addEventListener("animationend", e) : e()
                    } else e()
                });
                return Promise.all([e, t]).then(this.onAnimateInComplete.bind(this))
            }
        }, {
            key: "animateInWithoutCss", value: function () {
                var t = new Us, e = new Promise(function (e) {
                    t.eventCallback("onComplete", function () {
                        e(!0)
                    })
                });
                return t.fromTo(".main-loading__bar__total", .9, {opacity: 1, scaleY: 0}, {
                    opacity: .1, scaleY: 1, ease: Fs.easeInOut
                }, 0).fromTo(".main-loading__logo path[data-id=shape]", 1.2, {opacity: 1, drawSVG: 0}, {
                    opacity: .1, drawSVG: "100%", ease: Fs.easeInOut
                }, .5), e.then(this.onAnimateInComplete.bind(this))
            }
        }, {
            key: "animateOut", value: function () {
                var t = (new Us).to(this.progressElement, .7, {
                    scaleY: 0, yPercent: -100, ease: Fs.easeInOut
                }, 0).fromTo(".main-loading__bar__total", .9, {opacity: .1, animation: "none"}, {
                    scaleY: 0, yPercent: -100, ease: Fs.easeInOut
                }, .4);
                if ("home" === this.pageId) {
                    var e = document.querySelector(".main-loading__logo").getBoundingClientRect(),
                        i = fl.element.getBoundingClientRect();
                    t.to(".main-loading__inner", 1.2, {
                        y: i.y - e.y, ease: Fs.easeInOut
                    }, 0).to(".main-loading__logo path[data-id=text]", .3, {opacity: .1}, 0)
                } else t.to(".main-loading__logo", .7, {y: -30, ease: Fs.easeInOut}, 0).from(fl.element, .7, {
                    y: 30, ease: Fs.easeOut
                }, .4).from(fl.shapePath, .9, {
                    drawSVG: 0, ease: Fs.easeOut
                }, .4).fromTo(".main-loading__logo path[data-id=shape]", .7, {
                    animation: "none", opacity: .2, strokeDashoffset: 0
                }, {drawSVG: "100% 100%", ease: Os.easeInOut}, 0).set(fl.element, {
                    clearProps: "x,y,scaleX,scaleY", immediateRender: !1
                });
                return new Promise(function (e) {
                    t.eventCallback("onComplete", function () {
                        e(!0)
                    })
                }).then(this.onAnimateOutComplete.bind(this))
            }
        }, {
            key: "setProgress", value: function (e) {
                if (!(e < this.progress)) {
                    var t = 2.5 * (e - (this.progressElement._gsTransform && this.progressElement._gsTransform.scaleY || 0));
                    this.progress = e, this.progressTween && this.progressTween.kill(), this.progressTween = Ss.to(this.progressElement, t, {
                        scaleY: this.progress, ease: Ns.easeOut, onComplete: this.onProgressTweenComplete.bind(this)
                    })
                }
            }
        }, {
            key: "resetProgress", value: function () {
                this.setProgress(0)
            }
        }, {
            key: "resize", value: function (e) {
            }
        }, {
            key: "onAnimateInComplete", value: function () {
                this.progress || (this.progress = .65, this.progressTween = Ss.to(this.progressElement, 4, {
                    scaleY: this.progress, ease: Sine.easeInOut
                }))
            }
        }, {
            key: "onAnimateOutComplete", value: function () {
                this.element.style.visibility = "hidden"
            }
        }, {
            key: "onProgressTweenComplete", value: function () {
                1 === this.progress && this.onComplete()
            }
        }, {
            key: "onComplete", value: function () {
                this.isComplete || (this.isComplete = !0, this.emit("complete"))
            }
        }]), i
    }(), gl = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).pageId = e.id, t.element = document.querySelector(".ajax-loading"), t.line = t.element.querySelector(".ajax-loading__line"), t.lineBackground = t.element.querySelector(".ajax-loading__line__background"), t.lineProgress = t.element.querySelector(".ajax-loading__line__progress"), t.progress = 0, t.progressTween = null, t.timeline = null, t
        }

        return ns(i, ps), is(i, [{
            key: "dispose", value: function () {
            }
        }, {
            key: "animateIn", value: function () {
                this.progress = 0, this.isComplete = !1, this.element.style.visibility = "inherit";
                var t = (new Us).set(this.line, {scaleY: 1}).set(this.lineProgress, {scaleY: 0}).fromTo(this.lineBackground, .8, {scaleY: 0}, {
                    scaleY: 1, ease: Fs.easeOut
                });
                return new Promise(function (e) {
                    t.eventCallback("onComplete", function () {
                        e(!0)
                    })
                }).then(this.onAnimateInComplete.bind(this))
            }
        }, {
            key: "animateOut", value: function () {
                var e = app.windowWidth < app.screenM ? 0 : .3,
                    t = (new Us).to(this.line, .8, {scaleY: 0, ease: Fs.easeInOut}, e);
                return ("home" === this.pageId || app.windowWidth < app.screenM) && t.to(this.line, .8, {
                    yPercent: -100, ease: Fs.easeInOut
                }, e), new Promise(function (e) {
                    t.eventCallback("onComplete", function () {
                        e(!0)
                    })
                }).then(this.onAnimateOutComplete.bind(this))
            }
        }, {
            key: "resize", value: function (e) {
            }
        }, {
            key: "setProgress", value: function (e) {
                if (!(e < this.progress)) {
                    var t = 1 * (e - (this.lineProgress._gsTransform && this.lineProgress._gsTransform.scaleY || 0));
                    this.progress = e, this.progressTween && this.progressTween.kill(), this.progressTween = Ss.to(this.lineProgress, t, {
                        scaleY: this.progress, ease: Power4.easeOut, onComplete: this.onProgressTweenComplete.bind(this)
                    })
                }
            }
        }, {
            key: "onProgressTweenComplete", value: function () {
                1 === this.progress && this.onComplete()
            }
        }, {
            key: "onComplete", value: function () {
                this.isComplete || (this.isComplete = !0, this.emit("complete"))
            }
        }, {
            key: "onAnimateInComplete", value: function () {
                this.progress || (this.progress = .65, this.progressTween = Ss.to(this.lineProgress, 4, {
                    scaleY: this.progress, ease: Rs.easeInOut
                }))
            }
        }, {
            key: "onAnimateOutComplete", value: function () {
                this.element.style.visibility = "hidden", Ss.set(this.line, {clearProps: "all"})
            }
        }]), i
    }(), vl = {OPEN: 0, CLOSE: 1}, yl = new (function (e) {
        function i() {
            var e;
            es(this, i), (e = ls(this, rs(i).call(this))).state = vl.OPEN, e.element = document.querySelector(".nav-toggle"), e.element.addEventListener("click", e.onClick.bind(ss(ss(e)))), e.element.addEventListener("mouseleave", e.onRollOut.bind(ss(ss(e)))), e.element.addEventListener("mouseenter", e.onRollOver.bind(ss(ss(e)))), e.textOpenElement = e.element.querySelector(".nav-toggle__text--open"), e.textCloseElement = e.element.querySelector(".nav-toggle__text--close"), e.timeline = null, e.shapeElement = e.element.querySelector(".nav-toggle__shape"), e.shapePaths = e.shapeElement.querySelectorAll("path"), e.shapePathStrokeDashoffset = 110, e.lineElement = e.element.querySelector(".nav-toggle__line"), e.lineElements = e.lineElement.querySelectorAll("span");
            var t = window.getComputedStyle(e.lineElements[1]).getPropertyValue(Ws("transform")).split("(")[1].split(")")[0].split(",");
            return e.lineScale = parseFloat(t[0]), e
        }

        return ns(i, ps), is(i, [{
            key: "toggleState", value: function () {
                this.setState(this.state === vl.OPEN ? vl.CLOSE : vl.OPEN)
            }
        }, {
            key: "setState", value: function (e) {
                e !== this.state && (this.state = e, this.element.classList.toggle("nav-toggle--open", this.state !== vl.OPEN), this.timeline && this.timeline.kill(), this.timeline = new Us({onComplete: this.onTimelineComplete.bind(this)}), e === vl.CLOSE ? this.animToCloseState() : this.animToOpenState())
            }
        }, {
            key: "animToCloseState", value: function () {
                this.timeline.set([this.shapeElement, this.textOpenElement], {visibility: "inherit"}).to(this.shapePaths[1], .7, {drawSVG: "50% 50%"}, 0).to(this.shapePaths[0], .7, {drawSVG: "50% 50%"}, .3).to(this.textOpenElement, .4, {
                    opacity: 0, x: -14
                }, 0).fromTo(this.textCloseElement, .7, {opacity: 0, x: 14}, {
                    opacity: 1, x: 0
                }, .4).fromTo(this.lineElement, .4, {scaleX: 0}, {scaleX: 1}, .4).fromTo(this.lineElements[1], .4, {scaleX: 1}, {scaleX: this.lineScale}, .6)
            }
        }, {
            key: "animToOpenState", value: function () {
                this.timeline.set([this.lineElement, this.textCloseElement], {visibility: "inherit"}).to(this.textCloseElement, .4, {
                    opacity: 0, x: 14, ease: Rs.easeIn
                }, .3).to(this.lineElements[1], .4, {scaleX: 1}, 0).to(this.lineElement, .4, {
                    scaleX: 0, ease: Rs.easeInOut
                }, .3).to(this.shapePaths[0], .7, {drawSVG: "0% 100%"}, .3).to(this.shapePaths[1], .7, {
                    drawSVG: this.shapePathStrokeDashoffset, ease: Rs.easeInOut
                }, .4).to(this.textOpenElement, .7, {opacity: 1, x: 0, ease: Rs.easeOut}, .6)
            }
        }, {
            key: "show", value: function () {
                this.element.style.visibility = "inherit", TweenLite.set(this.shapePaths[1], {drawSVG: this.shapePathStrokeDashoffset}), TweenLite.from(this.element, .7, {opacity: 0})
            }
        }, {
            key: "onClick", value: function () {
                this.toggleState(), this.emit("click", {state: this.state})
            }
        }, {
            key: "onRollOver", value: function () {
                this.timeline || (this.state === vl.OPEN ? (TweenLite.to(this.shapePaths[1], .7, {
                    drawSVG: "100%", ease: Os.easeOut
                }), TweenLite.to(this.textOpenElement, .7, {
                    x: -10, ease: Os.easeOut
                })) : TweenLite.to(this.lineElements[1], .7, {scaleX: 1 - this.lineScale, ease: Os.easeOut}))
            }
        }, {
            key: "onRollOut", value: function () {
                this.timeline || (this.state === vl.OPEN ? (TweenLite.to(this.shapePaths[1], .7, {
                    drawSVG: this.shapePathStrokeDashoffset, ease: Os.easeOut
                }), TweenLite.to(this.textOpenElement, .7, {
                    x: 0, ease: Os.easeOut
                })) : TweenLite.to(this.lineElements[1], .7, {scaleX: this.lineScale, ease: Os.easeOut}))
            }
        }, {
            key: "onTimelineComplete", value: function () {
                this.timeline = null
            }
        }]), i
    }()), _l = new (function () {
        function e() {
            es(this, e), this.element = document.querySelector(".subscribe-cta"), this.isVisible = !1
        }

        return is(e, [{
            key: "show", value: function () {
                this.isVisible = !0, this.element.style.visibility = "inherit", Ss.from(this.element, .7, {opacity: 0})
            }
        }]), e
    }());
    var xl, bl, wl, Tl = !1, Sl = "analytics-allowed";

    function El(e) {
        (Tl = e) && wl && Al(wl), bl.style.display = "none", localStorage.setItem(Sl, Tl)
    }

    function Al(e) {
        var t, i;
        (wl = e, Tl) && (t = xl, i = e, window.gtag && window.gtag("config", t, i))
    }

    function Ml() {
        El(!0)
    }

    function Pl() {
        El(!1)
    }

    var Ll = {
        init: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
            xl = e.id;
            var t = localStorage.getItem(Sl);
            t ? Tl = "true" === t : ((bl = document.querySelector(".analytics-banner")).querySelector(".analytics-banner__action--accept").addEventListener("click", Ml), bl.querySelector(".analytics-banner__action--decline").addEventListener("click", Pl), bl.style.visibility = "inherit")
        }, trackPage: Al
    };
    var Cl = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).id = e.id, t.owner = e.owner, t.element = e.element, t.prevScreenData = e.prevScreenData, t.url = e.url || window.location.url, t.color = e.color, t.isAjax = !t.element, t.screenData = {id: t.id}, t.isVisible = !1, t.isLoading = !1, t.loadingAnim = null, t.numAssetsToLoad = 0, t.numAssetsLoaded = 0, t.loadAssetsTimeOut = -1, t.timeline = null, t.splitSectionHeads = null, t.hasScrollbar = !0, t.sectionElementsToAnimateIn = ".page__section__title, .page__section__head, .page__section__body, .page__list__item", t.lineStepsSelector = null, t.container = document.querySelector(".page-container"), t.isAjax ? (document.querySelector('#__nuxt').classList.add("page-id-" + t.id), t.updateColor()) : t.initPage(), t
        }

        return ns(i, bs), is(i, [{
            key: "initPage", value: function () {
                console.log('abs', this)

                this.isAjax && this.initAjaxPage(), this.initScrollCTA(), this.initLine(), this.initScroll(), this.updateTitle(), this.detectScrollbar()
            }
        }, {
            key: "initAjaxPage", value: function () {

                this.container.appendChild(this.element)
            }
        }, {
            key: "initScrollCTA", value: function () {
                var e = this.element.querySelector(".scroll-cta");
                e && (this.scrollCTA = new Hs({element: e}))
            }
        }, {
            key: "initLine", value: function () {
                var e = this.element.querySelector(".page__line");
                e && (this.line = new qs({element: e, stepsSelector: this.lineStepsSelector}))
            }
        }, {
            key: "initScroll", value: function () {
                var e = this;
                this.scroll = new ll({containerScrollable: !app.isMobile}), this.scrollCTA && this.scroll.addItem(new cl({
                    element: this.scrollCTA.element, autoRemove: !1, calcTrigger: function () {
                        return .25 * window.innerHeight
                    }, onEnter: function () {
                        e.scrollCTA.setVisibility(!1)
                    }, onExit: function () {
                        e.scrollCTA.setVisibility(!0)
                    }
                })), this.line && this.scroll.addItem(this.line)
            }
        }, {
            key: "dispose", value: function () {
                hs(rs(i.prototype), "dispose", this).call(this), this.element && this.element.parentNode.removeChild(this.element), this.disposeLoadingAnim(), this.disposeTimeline(), this.disposeScrollCTA(), this.disposeLine(), this.disposeScroll()
            }
        }, {
            key: "disposeLoadingAnim", value: function () {
                this.loadingAnim && (this.loadingAnim.dispose(), this.loadingAnim.off("complete"), this.loadingAnim = null)
            }
        }, {
            key: "disposeScrollCTA", value: function () {
                this.scrollCTA && (this.scrollCTA.dispose(), this.scrollCTA = null)
            }
        }, {
            key: "disposeLine", value: function () {
                this.line && (this.line.dispose(), this.line = null)
            }
        }, {
            key: "disposeScroll", value: function () {
                this.scroll && (this.scroll.dispose(), this.scroll = null)
            }
        }, {
            key: "disposeTimeline", value: function () {
                if (this.timeline) {
                    if (this.timeline.kill(), this.splitSectionHeads) {
                        for (; this.splitSectionHeads.length;) {
                            this.splitSectionHeads.shift().revert()
                        }
                        this.splitSectionHeads = null
                    }
                    Ds(this.timeline), this.timeline = null
                }
            }
        }, {
            key: "detectScrollbar", value: function () {
                this.hasScrollbar = this.element.scrollHeight > app.windowHeight, document.querySelector('#__nuxt').classList.toggle("js-no-scrollbar", !this.hasScrollbar)
            }
        }, {
            key: "resize", value: function (e) {
                this.scroll && this.scroll.resize(), this.detectScrollbar()
            }
        }, {
            key: "lockScroll", value: function () {
                this.scroll && this.scroll.lock()
            }
        }, {
            key: "unlockScroll", value: function () {
                this.scroll && this.scroll.unlock()
            }
        }, {
            key: "updateTitle", value: function () {
                var e = this.element.getAttribute("data-title");
                e && e.length && (document.title = e)
            }
        }, {
            key: "updateColor", value: function () {
                var e = this.color || this.element.getAttribute("data-color") || pl;
                this.changeColor(e)
            }
        }, {
            key: "changeColor", value: function (e) {
                var t = "color-" + e;
                if (!document.querySelector('#__nuxt').classList.contains(t)) {
                    var i = "color-" + (e === ul ? pl : ul);
                    document.querySelector('#__nuxt').classList.add(t), document.querySelector('#__nuxt').classList.remove(i)
                }
            }
        }, {
            key: "load", value: function () {
                this.isLoading = !0, this.isAjax ? this.loadHtml() : this.loadAssets()
            }
        }, {
            key: "loadHtml", value: function () {
                window.fetch(this.url, {
                    headers: {
                        "X-Requested-With": "XMLHttpRequest", credentials: "same-origin"
                    }
                }).then(function (t) {
                    return t.text().then(function (e) {
                        return {url: t.url, text: e, status: t.status}
                    })
                }).then(this.onHtmlLoaded.bind(this))
            }
        }, {
            key: "loadAssets", value: function () {
                var i = this;
                return this.loadAssetsTimeOut = setTimeout(function () {
                    i.onAssetsLoaded()
                }, 4e3), new Promise(function (e, t) {
                    i.populateLoader(e, t)
                }).then(this.onAssetsLoaded.bind(this)).catch(this.onLoadAssetsError.bind(this))
            }
        }, {
            key: "populateLoader", value: function (e, t) {
                var i = this, n = this.element.querySelector(".page__background");
                n || e();
                var r, a,
                    o = window.getComputedStyle(n).getPropertyValue("background-image").split("url(").join("").split(")").join("").split('"').join("").split("").join("");
                this.numAssetsToLoad = 1, (r = o, a = new Image, a.src = r, new Promise(function (e, t) {
                    function i() {
                        a.naturalWidth ? e(a) : t(a), a.removeEventListener("load", i), a.removeEventListener("error", i)
                    }

                    a.naturalWidth || a.complete ? e(a) : (a.addEventListener("load", i), a.addEventListener("error", i))
                })).then(function (e) {
                    i.onAssetLoaded(e)
                }).then(e).catch(t)
            }
        }, {
            key: "abortLoadAssets", value: function () {
            }
        }, {
            key: "animateIn", value: function () {
                hs(rs(i.prototype), "animateIn", this).call(this), this.isVisible = !0
            }
        }, {
            key: "createAnimIn", value: function (e) {
                console.log(this.isAjax, app.ski)

                if (!this.isAjax)
                    return document.querySelector(".main-loading").style.visibility = "hidden",
                        e(), void this.animateInContent();
                this.isAjax ? this.loadingAnim = new gl({id: this.id}) : this.loadingAnim = new ml({id: this.id}), this.loadingAnim.on("complete", this.onLoadingAnimComplete.bind(this)), this.loadingAnim.animateIn().then(e)
            }
        }, {
            key: "animateInContent", value: function () {
                this.isAjax || (yl.show(), fl.show(), _l.show()), this.createAnimInContent(), Ll.trackPage({page_path: window.location.pathname}), app.windowWidth < app.screenS && (this.isAjax || "home" !== this.id) && this.timeline.shiftChildren(.5)
            }
        }, {
            key: "createAnimInContent", value: function () {
                this.timeline = new Us({onComplete: this.onAnimateInContentComplete.bind(this)});
                var e = this.element.querySelectorAll(this.sectionElementsToAnimateIn), t = new Us;
                this.element.style.visibility = "inherit", this.scroll && this.scroll.resize(), this.timeline.add(t, .6), this.splitSectionHeads = [];
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    if (n.getBoundingClientRect().y > window.innerHeight) break;
                    if (n.classList.contains("page__section__head") && !n.classList.contains("interactive-text")) {
                        var r = new Bs(n, {type: "lines"});
                        t.staggerFrom(r.lines, .7, {
                            y: 50, opacity: 0, ease: Fs.easeOut
                        }, .06, 0 !== i ? "-=.6" : 0), this.splitSectionHeads.push(r)
                    } else t.from(n, .7, {y: 50, opacity: 0, ease: Fs.easeOut}, 0 !== i ? "-=.6" : 0)
                }
                this.timeline.addLabel("content");
                var a = this.element.querySelector(".page__title");
                a && this.timeline.from(a, 1, {
                    y: 80, opacity: 0, ease: Fs.easeOut
                }, .1), app.windowWidth >= app.screenS && (this.scrollCTA && this.hasScrollbar && this.timeline.add(this.scrollCTA.animateIn()), this.line && this.timeline.add(this.line.animateIn(), .3))
            }
        }, {
            key: "animateOut", value: function () {
                hs(rs(i.prototype), "animateOut", this).call(this), this.isVisible = !1
            }
        }, {
            key: "createAnimOut", value: function (e) {
                this.element && (this.element.style.visibility = ""), this.owner.currentScreen.id !== this.id && document.querySelector('#__nuxt').classList.remove("page-id-" + this.id), e()
            }
        }, {
            key: "onAnimateInComplete", value: function (e) {
                hs(rs(i.prototype), "onAnimateInComplete", this).call(this, e), this.load()
            }
        }, {
            key: "onPopState", value: function (e) {
            }
        }, {
            key: "onHtmlLoaded", value: function (e) {
                var t;
                this.isVisible && (this.element = (t = e.text, (new DOMParser).parseFromString(t, "text/html").body.firstChild), this.initPage(), this.loadAssets())
            }
        }, {
            key: "onAssetLoaded", value: function (e) {
                this.numAssetsLoaded++;
                var t = this.numAssetsLoaded / this.numAssetsToLoad;
                this.isLoading && this.loadingAnim && this.loadingAnim.setProgress(t)
            }
        }, {
            key: "onAssetsLoaded", value: function () {
                this.isLoading = !1, clearTimeout(this.loadAssetsTimeOut), this.loadingAnim && this.loadingAnim.setProgress(1)
            }
        }, {
            key: "onLoadAssetsError", value: function () {
                this.onAssetLoaded()
            }
        }, {
            key: "onLoadingAnimComplete", value: function () {
                this.loadingAnim.animateOut().then(this.onLoadingAnimAnimateOutComplete.bind(this)), this.animateInContent()
            }
        }, {
            key: "onLoadingAnimAnimateOutComplete", value: function () {
                this.disposeLoadingAnim()
            }
        }, {
            key: "onAnimateInContentComplete", value: function () {
                this.disposeTimeline()
            }
        }]), i
    }();

    function Il() {
    }

    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }), void 0 === Math.sign && (Math.sign = function (e) {
        return e < 0 ? -1 : 0 < e ? 1 : +e
    }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && (Object.assign = function (e) {
        if (null == e) throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }), Object.assign(Il.prototype, {
        addEventListener: function (e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
        }, hasEventListener: function (e, t) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[e] && -1 !== i[e].indexOf(t)
        }, removeEventListener: function (e, t) {
            if (void 0 !== this._listeners) {
                var i = this._listeners[e];
                if (void 0 !== i) {
                    var n = i.indexOf(t);
                    -1 !== n && i.splice(n, 1)
                }
            }
        }, dispatchEvent: function (e) {
            if (void 0 !== this._listeners) {
                var t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    for (var i = t.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, e)
                }
            }
        }
    });
    var Rl, Ol, Fl, Nl, kl, Ul, Dl, zl, Bl, Hl, Gl, jl, Vl, Xl, Wl, Yl, ql, Ql, Zl, Jl, Kl, $l = 0, eh = 1, th = 2,
        ih = 0, nh = 1, rh = 2, ah = 1, oh = 2, sh = 0, lh = 1, hh = 2, ch = 0, uh = 0, ph = 1, dh = 2, fh = 3, mh = 4,
        gh = 5, vh = 100, yh = 101, _h = 102, xh = 103, bh = 104, wh = 200, Th = 201, Sh = 202, Eh = 203, Ah = 204,
        Mh = 205, Ph = 206, Lh = 207, Ch = 208, Ih = 209, Rh = 210, Oh = 0, Fh = 1, Nh = 2, kh = 3, Uh = 4, Dh = 5,
        zh = 6, Bh = 7, Hh = 0, Gh = 1, jh = 2, Vh = 0, Xh = 1, Wh = 2, Yh = 3, qh = 4, Qh = 301, Zh = 302, Jh = 303,
        Kh = 304, $h = 305, ec = 306, tc = 307, ic = 1e3, nc = 1001, rc = 1002, ac = 1003, oc = 1004, sc = 1005,
        lc = 1006, hc = 1007, cc = 1008, uc = 1009, pc = 1010, dc = 1011, fc = 1012, mc = 1013, gc = 1014, vc = 1015,
        yc = 1016, _c = 1017, xc = 1018, bc = 1019, wc = 1020, Tc = 1021, Sc = 1022, Ec = 1023, Ac = 1024, Mc = 1025,
        Pc = 1026, Lc = 1027, Cc = 1028, Ic = 33776, Rc = 33777, Oc = 33778, Fc = 33779, Nc = 35840, kc = 35841,
        Uc = 35842, Dc = 35843, zc = 36196, Bc = 37808, Hc = 37809, Gc = 37810, jc = 37811, Vc = 37812, Xc = 37813,
        Wc = 37814, Yc = 37815, qc = 37816, Qc = 37817, Zc = 37818, Jc = 37819, Kc = 37820, $c = 37821, eu = 2400,
        tu = 2401, iu = 0, nu = 3e3, ru = 3001, au = 3007, ou = 3002, su = 3004, lu = 3005, hu = 3006, cu = 3200,
        uu = 3201, pu = 0, du = 1, fu = {
            DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
                for (var r = [], e = 0; e < 256; e++) r[e] = (e < 16 ? "0" : "") + e.toString(16);
                return function () {
                    var e = 4294967295 * Math.random() | 0, t = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0;
                    return (r[255 & e] + r[e >> 8 & 255] + r[e >> 16 & 255] + r[e >> 24 & 255] + "-" + r[255 & t] + r[t >> 8 & 255] + "-" + r[t >> 16 & 15 | 64] + r[t >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 & 255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 & n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255]).toUpperCase()
                }
            }(), clamp: function (e, t, i) {
                return Math.max(t, Math.min(i, e))
            }, euclideanModulo: function (e, t) {
                return (e % t + t) % t
            }, mapLinear: function (e, t, i, n, r) {
                return n + (e - t) * (r - n) / (i - t)
            }, lerp: function (e, t, i) {
                return (1 - i) * e + i * t
            }, smoothstep: function (e, t, i) {
                return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
            }, smootherstep: function (e, t, i) {
                return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
            }, randInt: function (e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            }, randFloat: function (e, t) {
                return e + Math.random() * (t - e)
            }, randFloatSpread: function (e) {
                return e * (.5 - Math.random())
            }, degToRad: function (e) {
                return e * fu.DEG2RAD
            }, radToDeg: function (e) {
                return e * fu.RAD2DEG
            }, isPowerOfTwo: function (e) {
                return 0 == (e & e - 1) && 0 !== e
            }, ceilPowerOfTwo: function (e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }, floorPowerOfTwo: function (e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }
        };

    function mu(e, t) {
        this.x = e || 0, this.y = t || 0
    }

    function gu() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function vu(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function yu(e, t, i) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0
    }

    function _u() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    Object.defineProperties(mu.prototype, {
        width: {
            get: function () {
                return this.x
            }, set: function (e) {
                this.x = e
            }
        }, height: {
            get: function () {
                return this.y
            }, set: function (e) {
                this.y = e
            }
        }
    }), Object.assign(mu.prototype, {
        isVector2: !0, set: function (e, t) {
            return this.x = e, this.y = t, this
        }, setScalar: function (e) {
            return this.x = e, this.y = e, this
        }, setX: function (e) {
            return this.x = e, this
        }, setY: function (e) {
            return this.y = e, this
        }, setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }, getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y)
        }, copy: function (e) {
            return this.x = e.x, this.y = e.y, this
        }, add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
        }, addScalar: function (e) {
            return this.x += e, this.y += e, this
        }, addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this
        }, addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this
        }, sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
        }, subScalar: function (e) {
            return this.x -= e, this.y -= e, this
        }, subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this
        }, multiply: function (e) {
            return this.x *= e.x, this.y *= e.y, this
        }, multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this
        }, divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this
        }, divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        }, applyMatrix3: function (e) {
            var t = this.x, i = this.y, n = e.elements;
            return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this
        }, min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
        }, max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
        }, clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
        }, clampScalar: (Rl = new mu, Ol = new mu, function (e, t) {
            return Rl.set(e, e), Ol.set(t, t), this.clamp(Rl, Ol)
        }), clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }, roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        }, dot: function (e) {
            return this.x * e.x + this.y * e.y
        }, cross: function (e) {
            return this.x * e.y - this.y * e.x
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, angle: function () {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI), e
        }, distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        }, distanceToSquared: function (e) {
            var t = this.x - e.x, i = this.y - e.y;
            return t * t + i * i
        }, manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }, setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        }, lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
        }, lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        }, equals: function (e) {
            return e.x === this.x && e.y === this.y
        }, fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
        }, fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
        }, rotateAround: function (e, t) {
            var i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
            return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this
        }
    }), Object.assign(gu.prototype, {
        isMatrix4: !0, set: function (e, t, i, n, r, a, o, s, l, h, c, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = h, g[10] = c, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
        }, identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }, clone: function () {
            return (new gu).fromArray(this.elements)
        }, copy: function (e) {
            var t = this.elements, i = e.elements;
            return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
        }, copyPosition: function (e) {
            var t = this.elements, i = e.elements;
            return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
        }, extractBasis: function (e, t, i) {
            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        }, makeBasis: function (e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
        }, extractRotation: (Gl = new yu, function (e) {
            var t = this.elements, i = e.elements, n = 1 / Gl.setFromMatrixColumn(e, 0).length(),
                r = 1 / Gl.setFromMatrixColumn(e, 1).length(), a = 1 / Gl.setFromMatrixColumn(e, 2).length();
            return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }), makeRotationFromEuler: function (e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), o = Math.sin(i), s = Math.cos(n),
                l = Math.sin(n), h = Math.cos(r), c = Math.sin(r);
            if ("XYZ" === e.order) {
                var u = a * h, p = a * c, d = o * h, f = o * c;
                t[0] = s * h, t[4] = -s * c, t[8] = l, t[1] = p + d * l, t[5] = u - f * l, t[9] = -o * s, t[2] = f - u * l, t[6] = d + p * l, t[10] = a * s
            } else if ("YXZ" === e.order) {
                var m = s * h, g = s * c, v = l * h, y = l * c;
                t[0] = m + y * o, t[4] = v * o - g, t[8] = a * l, t[1] = a * c, t[5] = a * h, t[9] = -o, t[2] = g * o - v, t[6] = y + m * o, t[10] = a * s
            } else if ("ZXY" === e.order) {
                m = s * h, g = s * c, v = l * h, y = l * c;
                t[0] = m - y * o, t[4] = -a * c, t[8] = v + g * o, t[1] = g + v * o, t[5] = a * h, t[9] = y - m * o, t[2] = -a * l, t[6] = o, t[10] = a * s
            } else if ("ZYX" === e.order) {
                u = a * h, p = a * c, d = o * h, f = o * c;
                t[0] = s * h, t[4] = d * l - p, t[8] = u * l + f, t[1] = s * c, t[5] = f * l + u, t[9] = p * l - d, t[2] = -l, t[6] = o * s, t[10] = a * s
            } else if ("YZX" === e.order) {
                var _ = a * s, x = a * l, b = o * s, w = o * l;
                t[0] = s * h, t[4] = w - _ * c, t[8] = b * c + x, t[1] = c, t[5] = a * h, t[9] = -o * h, t[2] = -l * h, t[6] = x * c + b, t[10] = _ - w * c
            } else if ("XZY" === e.order) {
                _ = a * s, x = a * l, b = o * s, w = o * l;
                t[0] = s * h, t[4] = -c, t[8] = l * h, t[1] = _ * c + w, t[5] = a * h, t[9] = x * c - b, t[2] = b * c - x, t[6] = o * h, t[10] = w * c + _
            }
            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
        }, makeRotationFromQuaternion: (Bl = new yu(0, 0, 0), Hl = new yu(1, 1, 1), function (e) {
            return this.compose(Bl, e, Hl)
        }), lookAt: (Ul = new yu, Dl = new yu, zl = new yu, function (e, t, i) {
            var n = this.elements;
            return zl.subVectors(e, t), 0 === zl.lengthSq() && (zl.z = 1), zl.normalize(), Ul.crossVectors(i, zl), 0 === Ul.lengthSq() && (1 === Math.abs(i.z) ? zl.x += 1e-4 : zl.z += 1e-4, zl.normalize(), Ul.crossVectors(i, zl)), Ul.normalize(), Dl.crossVectors(zl, Ul), n[0] = Ul.x, n[4] = Dl.x, n[8] = zl.x, n[1] = Ul.y, n[5] = Dl.y, n[9] = zl.y, n[2] = Ul.z, n[6] = Dl.z, n[10] = zl.z, this
        }), multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        }, premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        }, multiplyMatrices: function (e, t) {
            var i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[4], s = i[8], l = i[12], h = i[1],
                c = i[5], u = i[9], p = i[13], d = i[2], f = i[6], m = i[10], g = i[14], v = i[3], y = i[7], _ = i[11],
                x = i[15], b = n[0], w = n[4], T = n[8], S = n[12], E = n[1], A = n[5], M = n[9], P = n[13], L = n[2],
                C = n[6], I = n[10], R = n[14], O = n[3], F = n[7], N = n[11], k = n[15];
            return r[0] = a * b + o * E + s * L + l * O, r[4] = a * w + o * A + s * C + l * F, r[8] = a * T + o * M + s * I + l * N, r[12] = a * S + o * P + s * R + l * k, r[1] = h * b + c * E + u * L + p * O, r[5] = h * w + c * A + u * C + p * F, r[9] = h * T + c * M + u * I + p * N, r[13] = h * S + c * P + u * R + p * k, r[2] = d * b + f * E + m * L + g * O, r[6] = d * w + f * A + m * C + g * F, r[10] = d * T + f * M + m * I + g * N, r[14] = d * S + f * P + m * R + g * k, r[3] = v * b + y * E + _ * L + x * O, r[7] = v * w + y * A + _ * C + x * F, r[11] = v * T + y * M + _ * I + x * N, r[15] = v * S + y * P + _ * R + x * k, this
        }, multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
        }, applyToBufferAttribute: (kl = new yu, function (e) {
            for (var t = 0, i = e.count; t < i; t++) kl.x = e.getX(t), kl.y = e.getY(t), kl.z = e.getZ(t), kl.applyMatrix4(this), e.setXYZ(t, kl.x, kl.y, kl.z);
            return e
        }), determinant: function () {
            var e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], o = e[5], s = e[9], l = e[13],
                h = e[2], c = e[6], u = e[10], p = e[14];
            return e[3] * (+r * s * c - n * l * c - r * o * u + i * l * u + n * o * p - i * s * p) + e[7] * (+t * s * p - t * l * u + r * a * u - n * a * p + n * l * h - r * s * h) + e[11] * (+t * l * c - t * o * p - r * a * c + i * a * p + r * o * h - i * l * h) + e[15] * (-n * o * h - t * s * c + t * o * u + n * a * c - i * a * u + i * s * h)
        }, transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        }, setPosition: function (e) {
            var t = this.elements;
            return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
        }, getInverse: function (e, t) {
            var i = this.elements, n = e.elements, r = n[0], a = n[1], o = n[2], s = n[3], l = n[4], h = n[5], c = n[6],
                u = n[7], p = n[8], d = n[9], f = n[10], m = n[11], g = n[12], v = n[13], y = n[14], _ = n[15],
                x = d * y * u - v * f * u + v * c * m - h * y * m - d * c * _ + h * f * _,
                b = g * f * u - p * y * u - g * c * m + l * y * m + p * c * _ - l * f * _,
                w = p * v * u - g * d * u + g * h * m - l * v * m - p * h * _ + l * d * _,
                T = g * d * c - p * v * c - g * h * f + l * v * f + p * h * y - l * d * y,
                S = r * x + a * b + o * w + s * T;
            if (0 === S) {
                var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(E);
                return console.warn(E), this.identity()
            }
            var A = 1 / S;
            return i[0] = x * A, i[1] = (v * f * s - d * y * s - v * o * m + a * y * m + d * o * _ - a * f * _) * A, i[2] = (h * y * s - v * c * s + v * o * u - a * y * u - h * o * _ + a * c * _) * A, i[3] = (d * c * s - h * f * s - d * o * u + a * f * u + h * o * m - a * c * m) * A, i[4] = b * A, i[5] = (p * y * s - g * f * s + g * o * m - r * y * m - p * o * _ + r * f * _) * A, i[6] = (g * c * s - l * y * s - g * o * u + r * y * u + l * o * _ - r * c * _) * A, i[7] = (l * f * s - p * c * s + p * o * u - r * f * u - l * o * m + r * c * m) * A, i[8] = w * A, i[9] = (g * d * s - p * v * s - g * a * m + r * v * m + p * a * _ - r * d * _) * A, i[10] = (l * v * s - g * h * s + g * a * u - r * v * u - l * a * _ + r * h * _) * A, i[11] = (p * h * s - l * d * s - p * a * u + r * d * u + l * a * m - r * h * m) * A, i[12] = T * A, i[13] = (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * A, i[14] = (g * h * o - l * v * o - g * a * c + r * v * c + l * a * y - r * h * y) * A, i[15] = (l * d * o - p * h * o + p * a * c - r * d * c - l * a * f + r * h * f) * A, this
        }, scale: function (e) {
            var t = this.elements, i = e.x, n = e.y, r = e.z;
            return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this
        }, getMaxScaleOnAxis: function () {
            var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, i, n))
        }, makeTranslation: function (e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
        }, makeRotationX: function (e) {
            var t = Math.cos(e), i = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
        }, makeRotationY: function (e) {
            var t = Math.cos(e), i = Math.sin(e);
            return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
        }, makeRotationZ: function (e) {
            var t = Math.cos(e), i = Math.sin(e);
            return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }, makeRotationAxis: function (e, t) {
            var i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, o = e.y, s = e.z, l = r * a, h = r * o;
            return this.set(l * a + i, l * o - n * s, l * s + n * o, 0, l * o + n * s, h * o + i, h * s - n * a, 0, l * s - n * o, h * s + n * a, r * s * s + i, 0, 0, 0, 0, 1), this
        }, makeScale: function (e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        }, makeShear: function (e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this
        }, compose: function (e, t, i) {
            var n = this.elements, r = t._x, a = t._y, o = t._z, s = t._w, l = r + r, h = a + a, c = o + o, u = r * l,
                p = r * h, d = r * c, f = a * h, m = a * c, g = o * c, v = s * l, y = s * h, _ = s * c, x = i.x,
                b = i.y, w = i.z;
            return n[0] = (1 - (f + g)) * x, n[1] = (p + _) * x, n[2] = (d - y) * x, n[3] = 0, n[4] = (p - _) * b, n[5] = (1 - (u + g)) * b, n[6] = (m + v) * b, n[7] = 0, n[8] = (d + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) * w, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this
        }, decompose: (Fl = new yu, Nl = new gu, function (e, t, i) {
            var n = this.elements, r = Fl.set(n[0], n[1], n[2]).length(), a = Fl.set(n[4], n[5], n[6]).length(),
                o = Fl.set(n[8], n[9], n[10]).length();
            this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Nl.copy(this);
            var s = 1 / r, l = 1 / a, h = 1 / o;
            return Nl.elements[0] *= s, Nl.elements[1] *= s, Nl.elements[2] *= s, Nl.elements[4] *= l, Nl.elements[5] *= l, Nl.elements[6] *= l, Nl.elements[8] *= h, Nl.elements[9] *= h, Nl.elements[10] *= h, t.setFromRotationMatrix(Nl), i.x = r, i.y = a, i.z = o, this
        }), makePerspective: function (e, t, i, n, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements, s = 2 * r / (t - e), l = 2 * r / (i - n), h = (t + e) / (t - e),
                c = (i + n) / (i - n), u = -(a + r) / (a - r), p = -2 * a * r / (a - r);
            return o[0] = s, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = l, o[9] = c, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        }, makeOrthographic: function (e, t, i, n, r, a) {
            var o = this.elements, s = 1 / (t - e), l = 1 / (i - n), h = 1 / (a - r), c = (t + e) * s, u = (i + n) * l,
                p = (a + r) * h;
            return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -c, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        }, equals: function (e) {
            for (var t = this.elements, i = e.elements, n = 0; n < 16; n++) if (t[n] !== i[n]) return !1;
            return !0
        }, fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 16; i++) this.elements[i] = e[i + t];
            return this
        }, toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
        }
    }), Object.assign(vu, {
        slerp: function (e, t, i, n) {
            return i.copy(e).slerp(t, n)
        }, slerpFlat: function (e, t, i, n, r, a, o) {
            var s = i[n + 0], l = i[n + 1], h = i[n + 2], c = i[n + 3], u = r[a + 0], p = r[a + 1], d = r[a + 2],
                f = r[a + 3];
            if (c !== f || s !== u || l !== p || h !== d) {
                var m = 1 - o, g = s * u + l * p + h * d + c * f, v = 0 <= g ? 1 : -1, y = 1 - g * g;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y), x = Math.atan2(_, g * v);
                    m = Math.sin(m * x) / _, o = Math.sin(o * x) / _
                }
                var b = o * v;
                if (s = s * m + u * b, l = l * m + p * b, h = h * m + d * b, c = c * m + f * b, m === 1 - o) {
                    var w = 1 / Math.sqrt(s * s + l * l + h * h + c * c);
                    s *= w, l *= w, h *= w, c *= w
                }
            }
            e[t] = s, e[t + 1] = l, e[t + 2] = h, e[t + 3] = c
        }
    }), Object.defineProperties(vu.prototype, {
        x: {
            get: function () {
                return this._x
            }, set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        }, y: {
            get: function () {
                return this._y
            }, set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        }, z: {
            get: function () {
                return this._z
            }, set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        }, w: {
            get: function () {
                return this._w
            }, set: function (e) {
                this._w = e, this.onChangeCallback()
            }
        }
    }), Object.assign(vu.prototype, {
        isQuaternion: !0, set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this
        }, clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }, copy: function (e) {
            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
        }, setFromEuler: function (e, t) {
            if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = e._x, n = e._y, r = e._z, a = e.order, o = Math.cos, s = Math.sin, l = o(i / 2), h = o(n / 2),
                c = o(r / 2), u = s(i / 2), p = s(n / 2), d = s(r / 2);
            return "XYZ" === a ? (this._x = u * h * c + l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c - u * p * d) : "YXZ" === a ? (this._x = u * h * c + l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c + u * p * d) : "ZXY" === a ? (this._x = u * h * c - l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c - u * p * d) : "ZYX" === a ? (this._x = u * h * c - l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c + u * p * d) : "YZX" === a ? (this._x = u * h * c + l * p * d, this._y = l * p * c + u * h * d, this._z = l * h * d - u * p * c, this._w = l * h * c - u * p * d) : "XZY" === a && (this._x = u * h * c - l * p * d, this._y = l * p * c - u * h * d, this._z = l * h * d + u * p * c, this._w = l * h * c + u * p * d), !1 !== t && this.onChangeCallback(), this
        }, setFromAxisAngle: function (e, t) {
            var i = t / 2, n = Math.sin(i);
            return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this.onChangeCallback(), this
        }, setFromRotationMatrix: function (e) {
            var t, i = e.elements, n = i[0], r = i[4], a = i[8], o = i[1], s = i[5], l = i[9], h = i[2], c = i[6],
                u = i[10], p = n + s + u;
            return this._z = 0 < p ? (t = .5 / Math.sqrt(p + 1), this._w = .25 / t, this._x = (c - l) * t, this._y = (a - h) * t, (o - r) * t) : s < n && u < n ? (t = 2 * Math.sqrt(1 + n - s - u), this._w = (c - l) / t, this._x = .25 * t, this._y = (r + o) / t, (a + h) / t) : u < s ? (t = 2 * Math.sqrt(1 + s - n - u), this._w = (a - h) / t, this._x = (r + o) / t, this._y = .25 * t, (l + c) / t) : (t = 2 * Math.sqrt(1 + u - n - s), this._w = (o - r) / t, this._x = (a + h) / t, this._y = (l + c) / t, .25 * t), this.onChangeCallback(), this
        }, setFromUnitVectors: (Vl = new yu, function (e, t) {
            return void 0 === Vl && (Vl = new yu), (jl = e.dot(t) + 1) < 1e-6 ? (jl = 0, Math.abs(e.x) > Math.abs(e.z) ? Vl.set(-e.y, e.x, 0) : Vl.set(0, -e.z, e.y)) : Vl.crossVectors(e, t), this._x = Vl.x, this._y = Vl.y, this._z = Vl.z, this._w = jl, this.normalize()
        }), angleTo: function (e) {
            return 2 * Math.acos(Math.abs(fu.clamp(this.dot(e), -1, 1)))
        }, rotateTowards: function (e, t) {
            var i = this.angleTo(e);
            if (0 === i) return this;
            var n = Math.min(1, t / i);
            return this.slerp(e, n), this
        }, inverse: function () {
            return this.conjugate()
        }, conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        }, dot: function (e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }, lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }, length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }, normalize: function () {
            var e = this.length();
            return this._w = 0 === e ? (this._x = 0, this._y = 0, this._z = 0, 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w * e), this.onChangeCallback(), this
        }, multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        }, premultiply: function (e) {
            return this.multiplyQuaternions(e, this)
        }, multiplyQuaternions: function (e, t) {
            var i = e._x, n = e._y, r = e._z, a = e._w, o = t._x, s = t._y, l = t._z, h = t._w;
            return this._x = i * h + a * o + n * l - r * s, this._y = n * h + a * s + r * o - i * l, this._z = r * h + a * l + i * s - n * o, this._w = a * h - i * o - n * s - r * l, this.onChangeCallback(), this
        }, slerp: function (e, t) {
            if (0 === t) return this;
            if (1 === t) return this.copy(e);
            var i = this._x, n = this._y, r = this._z, a = this._w, o = a * e._w + i * e._x + n * e._y + r * e._z;
            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = i, this._y = n, this._z = r, this;
            var s = 1 - o * o;
            if (s <= Number.EPSILON) {
                var l = 1 - t;
                return this._w = l * a + t * this._w, this._x = l * i + t * this._x, this._y = l * n + t * this._y, this._z = l * r + t * this._z, this.normalize()
            }
            var h = Math.sqrt(s), c = Math.atan2(h, o), u = Math.sin((1 - t) * c) / h, p = Math.sin(t * c) / h;
            return this._w = a * u + this._w * p, this._x = i * u + this._x * p, this._y = n * u + this._y * p, this._z = r * u + this._z * p, this.onChangeCallback(), this
        }, equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }, fromArray: function (e, t) {
            return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
        }, onChange: function (e) {
            return this.onChangeCallback = e, this
        }, onChangeCallback: function () {
        }
    }), Object.assign(yu.prototype, {
        isVector3: !0, set: function (e, t, i) {
            return this.x = e, this.y = t, this.z = i, this
        }, setScalar: function (e) {
            return this.x = e, this.y = e, this.z = e, this
        }, setX: function (e) {
            return this.x = e, this
        }, setY: function (e) {
            return this.y = e, this
        }, setZ: function (e) {
            return this.z = e, this
        }, setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }, getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        }, copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this
        }, add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
        }, addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this
        }, addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
        }, addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
        }, sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
        }, subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this
        }, subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
        }, multiply: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
        }, multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this
        }, multiplyVectors: function (e, t) {
            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
        }, applyEuler: (Jl = new vu, function (e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Jl.setFromEuler(e))
        }), applyAxisAngle: (Zl = new vu, function (e, t) {
            return this.applyQuaternion(Zl.setFromAxisAngle(e, t))
        }), applyMatrix3: function (e) {
            var t = this.x, i = this.y, n = this.z, r = e.elements;
            return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this
        }, applyMatrix4: function (e) {
            var t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
            return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this
        }, applyQuaternion: function (e) {
            var t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, o = e.z, s = e.w, l = s * t + a * n - o * i,
                h = s * i + o * t - r * n, c = s * n + r * i - a * t, u = -r * t - a * i - o * n;
            return this.x = l * s + u * -r + h * -o - c * -a, this.y = h * s + u * -a + c * -r - l * -o, this.z = c * s + u * -o + l * -a - h * -r, this
        }, project: function (e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }, unproject: (Ql = new gu, function (e) {
            return this.applyMatrix4(Ql.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
        }), transformDirection: function (e) {
            var t = this.x, i = this.y, n = this.z, r = e.elements;
            return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize()
        }, divide: function (e) {
            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
        }, divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        }, min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
        }, max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
        }, clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
        }, clampScalar: (Yl = new yu, ql = new yu, function (e, t) {
            return Yl.set(e, e, e), ql.set(t, t, t), this.clamp(Yl, ql)
        }), clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }, roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }, dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        }, lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
        }, lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        }, cross: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
        }, crossVectors: function (e, t) {
            var i = e.x, n = e.y, r = e.z, a = t.x, o = t.y, s = t.z;
            return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a, this
        }, projectOnVector: function (e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        }, projectOnPlane: (Wl = new yu, function (e) {
            return Wl.copy(this).projectOnVector(e), this.sub(Wl)
        }), reflect: (Xl = new yu, function (e) {
            return this.sub(Xl.copy(e).multiplyScalar(2 * this.dot(e)))
        }), angleTo: function (e) {
            var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
            return Math.acos(fu.clamp(t, -1, 1))
        }, distanceTo: function (e) {
            return Math.sqrt(this.distanceToSquared(e))
        }, distanceToSquared: function (e) {
            var t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
            return t * t + i * i + n * n
        }, manhattanDistanceTo: function (e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }, setFromSpherical: function (e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }, setFromSphericalCoords: function (e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this
        }, setFromCylindrical: function (e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }, setFromCylindricalCoords: function (e, t, i) {
            return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
        }, setFromMatrixPosition: function (e) {
            var t = e.elements;
            return this.x = t[12], this.y = t[13], this.z = t[14], this
        }, setFromMatrixScale: function (e) {
            var t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(),
                n = this.setFromMatrixColumn(e, 2).length();
            return this.x = t, this.y = i, this.z = n, this
        }, setFromMatrixColumn: function (e, t) {
            return this.fromArray(e.elements, 4 * t)
        }, equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }, fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
        }, fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
        }
    }), Object.assign(_u.prototype, {
        isMatrix3: !0, set: function (e, t, i, n, r, a, o, s, l) {
            var h = this.elements;
            return h[0] = e, h[1] = n, h[2] = o, h[3] = t, h[4] = r, h[5] = s, h[6] = i, h[7] = a, h[8] = l, this
        }, identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }, clone: function () {
            return (new this.constructor).fromArray(this.elements)
        }, copy: function (e) {
            var t = this.elements, i = e.elements;
            return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
        }, setFromMatrix4: function (e) {
            var t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }, applyToBufferAttribute: (Kl = new yu, function (e) {
            for (var t = 0, i = e.count; t < i; t++) Kl.x = e.getX(t), Kl.y = e.getY(t), Kl.z = e.getZ(t), Kl.applyMatrix3(this), e.setXYZ(t, Kl.x, Kl.y, Kl.z);
            return e
        }), multiply: function (e) {
            return this.multiplyMatrices(this, e)
        }, premultiply: function (e) {
            return this.multiplyMatrices(e, this)
        }, multiplyMatrices: function (e, t) {
            var i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[3], s = i[6], l = i[1], h = i[4],
                c = i[7], u = i[2], p = i[5], d = i[8], f = n[0], m = n[3], g = n[6], v = n[1], y = n[4], _ = n[7],
                x = n[2], b = n[5], w = n[8];
            return r[0] = a * f + o * v + s * x, r[3] = a * m + o * y + s * b, r[6] = a * g + o * _ + s * w, r[1] = l * f + h * v + c * x, r[4] = l * m + h * y + c * b, r[7] = l * g + h * _ + c * w, r[2] = u * f + p * v + d * x, r[5] = u * m + p * y + d * b, r[8] = u * g + p * _ + d * w, this
        }, multiplyScalar: function (e) {
            var t = this.elements;
            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
        }, determinant: function () {
            var e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], s = e[6], l = e[7],
                h = e[8];
            return t * a * h - t * o * l - i * r * h + i * o * s + n * r * l - n * a * s
        }, getInverse: function (e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = e.elements, n = this.elements, r = i[0], a = i[1], o = i[2], s = i[3], l = i[4], h = i[5], c = i[6],
                u = i[7], p = i[8], d = p * l - h * u, f = h * c - p * s, m = u * s - l * c, g = r * d + a * f + o * m;
            if (0 === g) {
                var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                if (!0 === t) throw new Error(v);
                return console.warn(v), this.identity()
            }
            var y = 1 / g;
            return n[0] = d * y, n[1] = (o * u - p * a) * y, n[2] = (h * a - o * l) * y, n[3] = f * y, n[4] = (p * r - o * c) * y, n[5] = (o * s - h * r) * y, n[6] = m * y, n[7] = (a * c - u * r) * y, n[8] = (l * r - a * s) * y, this
        }, transpose: function () {
            var e, t = this.elements;
            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }, getNormalMatrix: function (e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        }, transposeIntoArray: function (e) {
            var t = this.elements;
            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
        }, setUvTransform: function (e, t, i, n, r, a, o) {
            var s = Math.cos(r), l = Math.sin(r);
            this.set(i * s, i * l, -i * (s * a + l * o) + a + e, -n * l, n * s, -n * (-l * a + s * o) + o + t, 0, 0, 1)
        }, scale: function (e, t) {
            var i = this.elements;
            return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this
        }, rotate: function (e) {
            var t = Math.cos(e), i = Math.sin(e), n = this.elements, r = n[0], a = n[3], o = n[6], s = n[1], l = n[4],
                h = n[7];
            return n[0] = t * r + i * s, n[3] = t * a + i * l, n[6] = t * o + i * h, n[1] = -i * r + t * s, n[4] = -i * a + t * l, n[7] = -i * o + t * h, this
        }, translate: function (e, t) {
            var i = this.elements;
            return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this
        }, equals: function (e) {
            for (var t = this.elements, i = e.elements, n = 0; n < 9; n++) if (t[n] !== i[n]) return !1;
            return !0
        }, fromArray: function (e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 9; i++) this.elements[i] = e[i + t];
            return this
        }, toArray: function (e, t) {
            void 0 === e && (e = []), void 0 === t && (t = 0);
            var i = this.elements;
            return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
        }
    });
    var xu, bu, wu, Tu, Su, Eu, Au, Mu, Pu, Lu, Cu, Iu, Ru, Ou, Fu, Nu, ku = {
        getDataURL: function (e) {
            var t;
            if (e instanceof HTMLCanvasElement) t = e; else {
                (t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")).width = e.width, t.height = e.height;
                var i = t.getContext("2d");
                e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height)
            }
            return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }, Uu = 0;

    function Du(e, t, i, n, r, a, o, s, l, h) {
        Object.defineProperty(this, "id", {value: Uu++}), this.uuid = fu.generateUUID(), this.name = "", this.image = void 0 !== e ? e : Du.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : Du.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : nc, this.wrapT = void 0 !== n ? n : nc, this.magFilter = void 0 !== r ? r : lc, this.minFilter = void 0 !== a ? a : cc, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : Ec, this.type = void 0 !== s ? s : uc, this.offset = new mu(0, 0), this.repeat = new mu(1, 1), this.center = new mu(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new _u, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== h ? h : nu, this.version = 0, this.onUpdate = null
    }

    function zu(e, t, i, n) {
        this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function Bu(e, t, i) {
        this.width = e, this.height = t, this.scissor = new zu(0, 0, e, t), this.scissorTest = !1, this.viewport = new zu(0, 0, e, t), void 0 === (i = i || {}).minFilter && (i.minFilter = lc), this.texture = new Du(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 === i.generateMipmaps || i.generateMipmaps, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function Hu(e, t, i) {
        Bu.call(this, e, t, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
    }

    function Gu(e, t, i, n, r, a, o, s, l, h, c, u) {
        Du.call(this, null, a, o, s, l, h, n, r, c, u), this.image = {
            data: e, width: t, height: i
        }, this.magFilter = void 0 !== l ? l : ac, this.minFilter = void 0 !== h ? h : ac, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }

    function ju(e, t) {
        this.min = void 0 !== e ? e : new yu(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new yu(-1 / 0, -1 / 0, -1 / 0)
    }

    function Vu(e, t) {
        this.center = void 0 !== e ? e : new yu, this.radius = void 0 !== t ? t : 0
    }

    function Xu(e, t) {
        this.normal = void 0 !== e ? e : new yu(1, 0, 0), this.constant = void 0 !== t ? t : 0
    }

    function Wu(e, t, i, n, r, a) {
        this.planes = [void 0 !== e ? e : new Xu, void 0 !== t ? t : new Xu, void 0 !== i ? i : new Xu, void 0 !== n ? n : new Xu, void 0 !== r ? r : new Xu, void 0 !== a ? a : new Xu]
    }

    Du.DEFAULT_IMAGE = void 0, Du.DEFAULT_MAPPING = 300, Du.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: Du, isTexture: !0, updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
        }, toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
            var i = {
                metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = fu.generateUUID()), !t && void 0 === e.images[n.uuid]) {
                    var r;
                    if (Array.isArray(n)) {
                        r = [];
                        for (var a = 0, o = n.length; a < o; a++) r.push(ku.getDataURL(n[a]))
                    } else r = ku.getDataURL(n);
                    e.images[n.uuid] = {uuid: n.uuid, url: r}
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i), i
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }, transformUv: function (e) {
            if (300 !== this.mapping) return e;
            if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                case ic:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case nc:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case rc:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
            if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                case ic:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case nc:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case rc:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
            return this.flipY && (e.y = 1 - e.y), e
        }
    }), Object.defineProperty(Du.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(zu.prototype, {
        isVector4: !0, set: function (e, t, i, n) {
            return this.x = e, this.y = t, this.z = i, this.w = n, this
        }, setScalar: function (e) {
            return this.x = e, this.y = e, this.z = e, this.w = e, this
        }, setX: function (e) {
            return this.x = e, this
        }, setY: function (e) {
            return this.y = e, this
        }, setZ: function (e) {
            return this.z = e, this
        }, setW: function (e) {
            return this.w = e, this
        }, setComponent: function (e, t) {
            switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
            }
            return this
        }, getComponent: function (e) {
            switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }, copy: function (e) {
            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
        }, add: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
        }, addScalar: function (e) {
            return this.x += e, this.y += e, this.z += e, this.w += e, this
        }, addVectors: function (e, t) {
            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
        }, addScaledVector: function (e, t) {
            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
        }, sub: function (e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
        }, subScalar: function (e) {
            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
        }, subVectors: function (e, t) {
            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
        }, multiplyScalar: function (e) {
            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
        }, applyMatrix4: function (e) {
            var t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements;
            return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this
        }, divideScalar: function (e) {
            return this.multiplyScalar(1 / e)
        }, setAxisAngleFromQuaternion: function (e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return this.z = t < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = e.x / t, this.y = e.y / t, e.z / t), this
        }, setAxisAngleFromRotationMatrix: function (e) {
            var t, i, n, r, a = e.elements, o = a[0], s = a[4], l = a[8], h = a[1], c = a[5], u = a[9], p = a[2],
                d = a[6], f = a[10];
            if (Math.abs(s - h) < .01 && Math.abs(l - p) < .01 && Math.abs(u - d) < .01) {
                if (Math.abs(s + h) < .1 && Math.abs(l + p) < .1 && Math.abs(u + d) < .1 && Math.abs(o + c + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                t = Math.PI;
                var m = (o + 1) / 2, g = (c + 1) / 2, v = (f + 1) / 2, y = (s + h) / 4, _ = (l + p) / 4,
                    x = (u + d) / 4;
                return g < m && v < m ? r = m < .01 ? (i = 0, n = .707106781) : (n = y / (i = Math.sqrt(m)), _ / i) : v < g ? r = g < .01 ? (n = 0, i = .707106781) : (i = y / (n = Math.sqrt(g)), x / n) : v < .01 ? (n = i = .707106781, r = 0) : (i = _ / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, t), this
            }
            var b = Math.sqrt((d - u) * (d - u) + (l - p) * (l - p) + (h - s) * (h - s));
            return Math.abs(b) < .001 && (b = 1), this.x = (d - u) / b, this.y = (l - p) / b, this.z = (h - s) / b, this.w = Math.acos((o + c + f - 1) / 2), this
        }, min: function (e) {
            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
        }, max: function (e) {
            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
        }, clamp: function (e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
        }, clampScalar: function (e, t) {
            return void 0 === xu && (xu = new zu, bu = new zu), xu.set(e, e, e, e), bu.set(t, t, t, t), this.clamp(xu, bu)
        }, clampLength: function (e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }, roundToZero: function () {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }, dot: function (e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, setLength: function (e) {
            return this.normalize().multiplyScalar(e)
        }, lerp: function (e, t) {
            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
        }, lerpVectors: function (e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        }, equals: function (e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }, fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
        }, fromBufferAttribute: function (e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
        }
    }), Bu.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: Bu, isWebGLRenderTarget: !0, setSize: function (e, t) {
            this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), ((Hu.prototype = Object.create(Bu.prototype)).constructor = Hu).prototype.isWebGLRenderTargetCube = !0, ((Gu.prototype = Object.create(Du.prototype)).constructor = Gu).prototype.isDataTexture = !0, Object.assign(ju.prototype, {
        isBox3: !0, set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }, setFromArray: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) {
                var h = e[s], c = e[s + 1], u = e[s + 2];
                h < t && (t = h), c < i && (i = c), u < n && (n = u), r < h && (r = h), a < c && (a = c), o < u && (o = u)
            }
            return this.min.set(t, i, n), this.max.set(r, a, o), this
        }, setFromBufferAttribute: function (e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) {
                var h = e.getX(s), c = e.getY(s), u = e.getZ(s);
                h < t && (t = h), c < i && (i = c), u < n && (n = u), r < h && (r = h), a < c && (a = c), o < u && (o = u)
            }
            return this.min.set(t, i, n), this.max.set(r, a, o), this
        }, setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        }, setFromCenterAndSize: (Au = new yu, function (e, t) {
            var i = Au.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
        }), setFromObject: function (e) {
            return this.makeEmpty(), this.expandByObject(e)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }, makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }, getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new yu), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new yu), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }, expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        }, expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        }, expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }, expandByObject: function () {
            var r, a, o, s = new yu;

            function t(e) {
                var t = e.geometry;
                if (void 0 !== t) if (t.isGeometry) {
                    var i = t.vertices;
                    for (a = 0, o = i.length; a < o; a++) s.copy(i[a]), s.applyMatrix4(e.matrixWorld), r.expandByPoint(s)
                } else if (t.isBufferGeometry) {
                    var n = t.attributes.position;
                    if (void 0 !== n) for (a = 0, o = n.count; a < o; a++) s.fromBufferAttribute(n, a).applyMatrix4(e.matrixWorld), r.expandByPoint(s)
                }
            }

            return function (e) {
                return r = this, e.updateMatrixWorld(!0), e.traverse(t), this
            }
        }(), containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }, containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }, getParameter: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new yu), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }, intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }, intersectsSphere: (Eu = new yu, function (e) {
            return this.clampPoint(e.center, Eu), Eu.distanceToSquared(e.center) <= e.radius * e.radius
        }), intersectsPlane: function (e) {
            var t, i;
            return i = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
        }, intersectsTriangle: function () {
            var s = new yu, l = new yu, h = new yu, i = new yu, n = new yu, r = new yu, c = new yu, a = new yu,
                u = new yu, o = new yu;

            function p(e) {
                var t, i;
                for (t = 0, i = e.length - 3; t <= i; t += 3) {
                    c.fromArray(e, t);
                    var n = u.x * Math.abs(c.x) + u.y * Math.abs(c.y) + u.z * Math.abs(c.z), r = s.dot(c), a = l.dot(c),
                        o = h.dot(c);
                    if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n) return !1
                }
                return !0
            }

            return function (e) {
                if (this.isEmpty()) return !1;
                this.getCenter(a), u.subVectors(this.max, a), s.subVectors(e.a, a), l.subVectors(e.b, a), h.subVectors(e.c, a), i.subVectors(l, s), n.subVectors(h, l), r.subVectors(s, h);
                var t = [0, -i.z, i.y, 0, -n.z, n.y, 0, -r.z, r.y, i.z, 0, -i.x, n.z, 0, -n.x, r.z, 0, -r.x, -i.y, i.x, 0, -n.y, n.x, 0, -r.y, r.x, 0];
                return !!p(t) && (!!p(t = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (o.crossVectors(i, n), p(t = [o.x, o.y, o.z])))
            }
        }(), clampPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new yu), t.copy(e).clamp(this.min, this.max)
        }, distanceToPoint: (Su = new yu, function (e) {
            return Su.copy(e).clamp(this.min, this.max).sub(e).length()
        }), getBoundingSphere: (Tu = new yu, function (e) {
            return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new Vu), this.getCenter(e.center), e.radius = .5 * this.getSize(Tu).length(), e
        }), intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
        }, union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }, applyMatrix4: (wu = [new yu, new yu, new yu, new yu, new yu, new yu, new yu, new yu], function (e) {
            return this.isEmpty() || (wu[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), wu[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), wu[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), wu[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), wu[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), wu[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), wu[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), wu[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(wu)), this
        }), translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        }, equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(Vu.prototype, {
        set: function (e, t) {
            return this.center.copy(e), this.radius = t, this
        }, setFromPoints: (Mu = new ju, function (e, t) {
            var i = this.center;
            void 0 !== t ? i.copy(t) : Mu.setFromPoints(e).getCenter(i);
            for (var n = 0, r = 0, a = e.length; r < a; r++) n = Math.max(n, i.distanceToSquared(e[r]));
            return this.radius = Math.sqrt(n), this
        }), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.center.copy(e.center), this.radius = e.radius, this
        }, empty: function () {
            return this.radius <= 0
        }, containsPoint: function (e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }, distanceToPoint: function (e) {
            return e.distanceTo(this.center) - this.radius
        }, intersectsSphere: function (e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }, intersectsBox: function (e) {
            return e.intersectsSphere(this)
        }, intersectsPlane: function (e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }, clampPoint: function (e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new yu), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
        }, getBoundingBox: function (e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new ju), e.set(this.center, this.center), e.expandByScalar(this.radius), e
        }, applyMatrix4: function (e) {
            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
        }, translate: function (e) {
            return this.center.add(e), this
        }, equals: function (e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }), Object.assign(Xu.prototype, {
        set: function (e, t) {
            return this.normal.copy(e), this.constant = t, this
        }, setComponents: function (e, t, i, n) {
            return this.normal.set(e, t, i), this.constant = n, this
        }, setFromNormalAndCoplanarPoint: function (e, t) {
            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
        }, setFromCoplanarPoints: (Iu = new yu, Ru = new yu, function (e, t, i) {
            var n = Iu.subVectors(i, t).cross(Ru.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(n, e), this
        }), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.normal.copy(e.normal), this.constant = e.constant, this
        }, normalize: function () {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e), this.constant *= e, this
        }, negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        }, distanceToPoint: function (e) {
            return this.normal.dot(e) + this.constant
        }, distanceToSphere: function (e) {
            return this.distanceToPoint(e.center) - e.radius
        }, projectPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new yu), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        }, intersectLine: (Cu = new yu, function (e, t) {
            void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new yu);
            var i = e.delta(Cu), n = this.normal.dot(i);
            if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0;
            var r = -(e.start.dot(this.normal) + this.constant) / n;
            return r < 0 || 1 < r ? void 0 : t.copy(i).multiplyScalar(r).add(e.start)
        }), intersectsLine: function (e) {
            var t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
            return t < 0 && 0 < i || i < 0 && 0 < t
        }, intersectsBox: function (e) {
            return e.intersectsPlane(this)
        }, intersectsSphere: function (e) {
            return e.intersectsPlane(this)
        }, coplanarPoint: function (e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new yu), e.copy(this.normal).multiplyScalar(-this.constant)
        }, applyMatrix4: (Pu = new yu, Lu = new _u, function (e, t) {
            var i = t || Lu.getNormalMatrix(e), n = this.coplanarPoint(Pu).applyMatrix4(e),
                r = this.normal.applyMatrix3(i).normalize();
            return this.constant = -n.dot(r), this
        }), translate: function (e) {
            return this.constant -= e.dot(this.normal), this
        }, equals: function (e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }), Object.assign(Wu.prototype, {
        set: function (e, t, i, n, r, a) {
            var o = this.planes;
            return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            for (var t = this.planes, i = 0; i < 6; i++) t[i].copy(e.planes[i]);
            return this
        }, setFromMatrix: function (e) {
            var t = this.planes, i = e.elements, n = i[0], r = i[1], a = i[2], o = i[3], s = i[4], l = i[5], h = i[6],
                c = i[7], u = i[8], p = i[9], d = i[10], f = i[11], m = i[12], g = i[13], v = i[14], y = i[15];
            return t[0].setComponents(o - n, c - s, f - u, y - m).normalize(), t[1].setComponents(o + n, c + s, f + u, y + m).normalize(), t[2].setComponents(o + r, c + l, f + p, y + g).normalize(), t[3].setComponents(o - r, c - l, f - p, y - g).normalize(), t[4].setComponents(o - a, c - h, f - d, y - v).normalize(), t[5].setComponents(o + a, c + h, f + d, y + v).normalize(), this
        }, intersectsObject: (Nu = new Vu, function (e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(), Nu.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Nu)
        }), intersectsSprite: (Fu = new Vu, function (e) {
            return Fu.center.set(0, 0, 0), Fu.radius = .7071067811865476, Fu.applyMatrix4(e.matrixWorld), this.intersectsSphere(Fu)
        }), intersectsSphere: function (e) {
            for (var t = this.planes, i = e.center, n = -e.radius, r = 0; r < 6; r++) {
                if (t[r].distanceToPoint(i) < n) return !1
            }
            return !0
        }, intersectsBox: (Ou = new yu, function (e) {
            for (var t = this.planes, i = 0; i < 6; i++) {
                var n = t[i];
                if (Ou.x = 0 < n.normal.x ? e.max.x : e.min.x, Ou.y = 0 < n.normal.y ? e.max.y : e.min.y, Ou.z = 0 < n.normal.z ? e.max.z : e.min.z, n.distanceToPoint(Ou) < 0) return !1
            }
            return !0
        }), containsPoint: function (e) {
            for (var t = this.planes, i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
            return !0
        }
    });
    var Yu, qu, Qu, Zu = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "\nvec3 transformed = vec3( position );\n",
        beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
        bsdfs: "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
        encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n",
        background_vert: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
        cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
        equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n"
    }, Ju = {
        merge: function (e) {
            for (var t = {}, i = 0; i < e.length; i++) {
                var n = this.clone(e[i]);
                for (var r in n) t[r] = n[r]
            }
            return t
        }, clone: function (e) {
            var t = {};
            for (var i in e) for (var n in t[i] = {}, e[i]) {
                var r = e[i][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r
            }
            return t
        }
    }, Ku = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };

    function $u(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }

    Object.assign($u.prototype, {
        isColor: !0, r: 1, g: 1, b: 1, set: function (e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
        }, setScalar: function (e) {
            return this.r = e, this.g = e, this.b = e, this
        }, setHex: function (e) {
            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
        }, setRGB: function (e, t, i) {
            return this.r = e, this.g = t, this.b = i, this
        }, setHSL: function () {
            function a(e, t, i) {
                return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
            }

            return function (e, t, i) {
                if (e = fu.euclideanModulo(e, 1), t = fu.clamp(t, 0, 1), i = fu.clamp(i, 0, 1), 0 === t) this.r = this.g = this.b = i; else {
                    var n = i <= .5 ? i * (1 + t) : i + t - i * t, r = 2 * i - n;
                    this.r = a(r, n, e + 1 / 3), this.g = a(r, n, e), this.b = a(r, n, e - 1 / 3)
                }
                return this
            }
        }(), setStyle: function (t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }

            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n, r = i[1], a = i[2];
                switch (r) {
                    case"rgb":
                    case"rgba":
                        if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this;
                        if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this;
                        break;
                    case"hsl":
                    case"hsla":
                        if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                            var o = parseFloat(n[1]) / 360, s = parseInt(n[2], 10) / 100, l = parseInt(n[3], 10) / 100;
                            return e(n[5]), this.setHSL(o, s, l)
                        }
                }
            } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                var h, c = (h = i[1]).length;
                if (3 === c) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                if (6 === c) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
            }
            t && 0 < t.length && (void 0 !== (h = Ku[t]) ? this.setHex(h) : console.warn("THREE.Color: Unknown color " + t));
            return this
        }, clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        }, copy: function (e) {
            return this.r = e.r, this.g = e.g, this.b = e.b, this
        }, copyGammaToLinear: function (e, t) {
            return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
        }, copyLinearToGamma: function (e, t) {
            void 0 === t && (t = 2);
            var i = 0 < t ? 1 / t : 1;
            return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this
        }, convertGammaToLinear: function (e) {
            return this.copyGammaToLinear(this, e), this
        }, convertLinearToGamma: function (e) {
            return this.copyLinearToGamma(this, e), this
        }, copySRGBToLinear: function () {
            function t(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            return function (e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(), copyLinearToSRGB: function () {
            function t(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }

            return function (e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(), convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        }, convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        }, getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }, getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }, getHSL: function (e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {h: 0, s: 0, l: 0});
            var t, i, n = this.r, r = this.g, a = this.b, o = Math.max(n, r, a), s = Math.min(n, r, a), l = (s + o) / 2;
            if (s === o) i = t = 0; else {
                var h = o - s;
                switch (i = l <= .5 ? h / (o + s) : h / (2 - o - s), o) {
                    case n:
                        t = (r - a) / h + (r < a ? 6 : 0);
                        break;
                    case r:
                        t = (a - n) / h + 2;
                        break;
                    case a:
                        t = (n - r) / h + 4
                }
                t /= 6
            }
            return e.h = t, e.s = i, e.l = l, e
        }, getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }, offsetHSL: (Qu = {}, function (e, t, i) {
            return this.getHSL(Qu), Qu.h += e, Qu.s += t, Qu.l += i, this.setHSL(Qu.h, Qu.s, Qu.l), this
        }), add: function (e) {
            return this.r += e.r, this.g += e.g, this.b += e.b, this
        }, addColors: function (e, t) {
            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
        }, addScalar: function (e) {
            return this.r += e, this.g += e, this.b += e, this
        }, sub: function (e) {
            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
        }, multiply: function (e) {
            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
        }, multiplyScalar: function (e) {
            return this.r *= e, this.g *= e, this.b *= e, this
        }, lerp: function (e, t) {
            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
        }, lerpHSL: (Yu = {h: 0, s: 0, l: 0}, qu = {h: 0, s: 0, l: 0}, function (e, t) {
            this.getHSL(Yu), e.getHSL(qu);
            var i = fu.lerp(Yu.h, qu.h, t), n = fu.lerp(Yu.s, qu.s, t), r = fu.lerp(Yu.l, qu.l, t);
            return this.setHSL(i, n, r), this
        }), equals: function (e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }, fromArray: function (e, t) {
            return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
        }, toJSON: function () {
            return this.getHex()
        }
    });
    var ep, tp, ip = {
        common: {
            diffuse: {value: new $u(15658734)},
            opacity: {value: 1},
            map: {value: null},
            uvTransform: {value: new _u},
            alphaMap: {value: null}
        },
        specularmap: {specularMap: {value: null}},
        envmap: {
            envMap: {value: null},
            flipEnvMap: {value: -1},
            reflectivity: {value: 1},
            refractionRatio: {value: .98},
            maxMipLevel: {value: 0}
        },
        aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
        lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
        emissivemap: {emissiveMap: {value: null}},
        bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
        normalmap: {normalMap: {value: null}, normalScale: {value: new mu(1, 1)}},
        displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
        roughnessmap: {roughnessMap: {value: null}},
        metalnessmap: {metalnessMap: {value: null}},
        gradientmap: {gradientMap: {value: null}},
        fog: {
            fogDensity: {value: 25e-5}, fogNear: {value: 1}, fogFar: {value: 2e3}, fogColor: {value: new $u(16777215)}
        },
        lights: {
            ambientLightColor: {value: []},
            directionalLights: {
                value: [],
                properties: {direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}}
            },
            directionalShadowMap: {value: []},
            directionalShadowMatrix: {value: []},
            spotLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {value: []},
            spotShadowMatrix: {value: []},
            pointLights: {
                value: [], properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {value: []},
            pointShadowMatrix: {value: []},
            hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
            rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}
        },
        points: {
            diffuse: {value: new $u(15658734)},
            opacity: {value: 1},
            size: {value: 1},
            scale: {value: 1},
            map: {value: null},
            uvTransform: {value: new _u}
        },
        sprite: {
            diffuse: {value: new $u(15658734)},
            opacity: {value: 1},
            center: {value: new mu(.5, .5)},
            rotation: {value: 0},
            map: {value: null},
            uvTransform: {value: new _u}
        }
    }, np = {
        basic: {
            uniforms: Ju.merge([ip.common, ip.specularmap, ip.envmap, ip.aomap, ip.lightmap, ip.fog]),
            vertexShader: Zu.meshbasic_vert,
            fragmentShader: Zu.meshbasic_frag
        },
        lambert: {
            uniforms: Ju.merge([ip.common, ip.specularmap, ip.envmap, ip.aomap, ip.lightmap, ip.emissivemap, ip.fog, ip.lights, {emissive: {value: new $u(0)}}]),
            vertexShader: Zu.meshlambert_vert,
            fragmentShader: Zu.meshlambert_frag
        },
        phong: {
            uniforms: Ju.merge([ip.common, ip.specularmap, ip.envmap, ip.aomap, ip.lightmap, ip.emissivemap, ip.bumpmap, ip.normalmap, ip.displacementmap, ip.gradientmap, ip.fog, ip.lights, {
                emissive: {value: new $u(0)}, specular: {value: new $u(1118481)}, shininess: {value: 30}
            }]), vertexShader: Zu.meshphong_vert, fragmentShader: Zu.meshphong_frag
        },
        standard: {
            uniforms: Ju.merge([ip.common, ip.envmap, ip.aomap, ip.lightmap, ip.emissivemap, ip.bumpmap, ip.normalmap, ip.displacementmap, ip.roughnessmap, ip.metalnessmap, ip.fog, ip.lights, {
                emissive: {value: new $u(0)},
                roughness: {value: .5},
                metalness: {value: .5},
                envMapIntensity: {value: 1}
            }]), vertexShader: Zu.meshphysical_vert, fragmentShader: Zu.meshphysical_frag
        },
        matcap: {
            uniforms: Ju.merge([ip.common, ip.bumpmap, ip.normalmap, ip.displacementmap, ip.fog, {matcap: {value: null}}]),
            vertexShader: Zu.meshmatcap_vert,
            fragmentShader: Zu.meshmatcap_frag
        },
        points: {uniforms: Ju.merge([ip.points, ip.fog]), vertexShader: Zu.points_vert, fragmentShader: Zu.points_frag},
        dashed: {
            uniforms: Ju.merge([ip.common, ip.fog, {
                scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}
            }]), vertexShader: Zu.linedashed_vert, fragmentShader: Zu.linedashed_frag
        },
        depth: {
            uniforms: Ju.merge([ip.common, ip.displacementmap]),
            vertexShader: Zu.depth_vert,
            fragmentShader: Zu.depth_frag
        },
        normal: {
            uniforms: Ju.merge([ip.common, ip.bumpmap, ip.normalmap, ip.displacementmap, {opacity: {value: 1}}]),
            vertexShader: Zu.normal_vert,
            fragmentShader: Zu.normal_frag
        },
        sprite: {uniforms: Ju.merge([ip.sprite, ip.fog]), vertexShader: Zu.sprite_vert, fragmentShader: Zu.sprite_frag},
        background: {
            uniforms: {t2D: {value: null}}, vertexShader: Zu.background_vert, fragmentShader: Zu.background_frag
        },
        cube: {
            uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
            vertexShader: Zu.cube_vert,
            fragmentShader: Zu.cube_frag
        },
        equirect: {
            uniforms: {tEquirect: {value: null}}, vertexShader: Zu.equirect_vert, fragmentShader: Zu.equirect_frag
        },
        distanceRGBA: {
            uniforms: Ju.merge([ip.common, ip.displacementmap, {
                referencePosition: {value: new yu}, nearDistance: {value: 1}, farDistance: {value: 1e3}
            }]), vertexShader: Zu.distanceRGBA_vert, fragmentShader: Zu.distanceRGBA_frag
        },
        shadow: {
            uniforms: Ju.merge([ip.lights, ip.fog, {color: {value: new $u(0)}, opacity: {value: 1}}]),
            vertexShader: Zu.shadow_vert,
            fragmentShader: Zu.shadow_frag
        }
    };

    function rp() {
        var i = null, n = !1, r = null;

        function a(e, t) {
            !1 !== n && (r(e, t), i.requestAnimationFrame(a))
        }

        return {
            start: function () {
                !0 !== n && null !== r && (i.requestAnimationFrame(a), n = !0)
            }, stop: function () {
                n = !1
            }, setAnimationLoop: function (e) {
                r = e
            }, setContext: function (e) {
                i = e
            }
        }
    }

    function ap(l) {
        var h = new WeakMap;
        return {
            get: function (e) {
                return e.isInterleavedBufferAttribute && (e = e.data), h.get(e)
            }, remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var t = h.get(e);
                t && (l.deleteBuffer(t.buffer), h.delete(e))
            }, update: function (e, t) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var i, n, r, a, o, s = h.get(e);
                void 0 === s ? h.set(e, function (e, t) {
                    var i = e.array, n = e.dynamic ? l.DYNAMIC_DRAW : l.STATIC_DRAW, r = l.createBuffer();
                    l.bindBuffer(t, r), l.bufferData(t, i, n), e.onUploadCallback();
                    var a = l.FLOAT;
                    return i instanceof Float32Array ? a = l.FLOAT : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = l.UNSIGNED_SHORT : i instanceof Int16Array ? a = l.SHORT : i instanceof Uint32Array ? a = l.UNSIGNED_INT : i instanceof Int32Array ? a = l.INT : i instanceof Int8Array ? a = l.BYTE : i instanceof Uint8Array && (a = l.UNSIGNED_BYTE), {
                        buffer: r, type: a, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version
                    }
                }(e, t)) : s.version < e.version && (i = s.buffer, r = t, a = (n = e).array, o = n.updateRange, l.bindBuffer(r, i), !1 === n.dynamic ? l.bufferData(r, a, l.STATIC_DRAW) : -1 === o.count ? l.bufferSubData(r, 0, a) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (l.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), s.version = e.version)
            }
        }
    }

    function op(e, t, i, n, r, a) {
        this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new yu, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new $u, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0
    }

    function sp(e, t, i, n) {
        this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || sp.DefaultOrder
    }

    function lp() {
        this.mask = 1
    }

    np.physical = {
        uniforms: Ju.merge([np.standard.uniforms, {clearCoat: {value: 0}, clearCoatRoughness: {value: 0}}]),
        vertexShader: Zu.meshphysical_vert,
        fragmentShader: Zu.meshphysical_frag
    }, Object.assign(op.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }), sp.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], sp.DefaultOrder = "XYZ", Object.defineProperties(sp.prototype, {
        x: {
            get: function () {
                return this._x
            }, set: function (e) {
                this._x = e, this.onChangeCallback()
            }
        }, y: {
            get: function () {
                return this._y
            }, set: function (e) {
                this._y = e, this.onChangeCallback()
            }
        }, z: {
            get: function () {
                return this._z
            }, set: function (e) {
                this._z = e, this.onChangeCallback()
            }
        }, order: {
            get: function () {
                return this._order
            }, set: function (e) {
                this._order = e, this.onChangeCallback()
            }
        }
    }), Object.assign(sp.prototype, {
        isEuler: !0, set: function (e, t, i, n) {
            return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        }, clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }, copy: function (e) {
            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
        }, setFromRotationMatrix: function (e, t, i) {
            var n = fu.clamp, r = e.elements, a = r[0], o = r[4], s = r[8], l = r[1], h = r[5], c = r[9], u = r[2],
                p = r[6], d = r[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-c, d), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)), Math.abs(c) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-u, d), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, h))) : "YZX" === t ? (this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-c, h), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-c, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this
        }, setFromQuaternion: (tp = new gu, function (e, t, i) {
            return tp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(tp, t, i)
        }), setFromVector3: function (e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        }, reorder: (ep = new vu, function (e) {
            return ep.setFromEuler(this), this.setFromQuaternion(ep, e)
        }), equals: function (e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }, fromArray: function (e) {
            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
        }, toArray: function (e, t) {
            return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
        }, toVector3: function (e) {
            return e ? e.set(this._x, this._y, this._z) : new yu(this._x, this._y, this._z)
        }, onChange: function (e) {
            return this.onChangeCallback = e, this
        }, onChangeCallback: function () {
        }
    }), Object.assign(lp.prototype, {
        set: function (e) {
            this.mask = 1 << e | 0
        }, enable: function (e) {
            this.mask |= 1 << e | 0
        }, toggle: function (e) {
            this.mask ^= 1 << e | 0
        }, disable: function (e) {
            this.mask &= ~(1 << e | 0)
        }, test: function (e) {
            return 0 != (this.mask & e.mask)
        }
    });
    var hp, cp, up, pp, dp, fp, mp, gp, vp, yp, _p, xp, bp, wp, Tp, Sp, Ep, Ap, Mp = 0;

    function Pp() {
        Object.defineProperty(this, "id", {value: Mp++}), this.uuid = fu.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Pp.DefaultUp.clone();
        var e = new yu, t = new sp, i = new vu, n = new yu(1, 1, 1);
        t.onChange(function () {
            i.setFromEuler(t, !1)
        }), i.onChange(function () {
            t.setFromQuaternion(i, void 0, !1)
        }), Object.defineProperties(this, {
            position: {enumerable: !0, value: e},
            rotation: {enumerable: !0, value: t},
            quaternion: {enumerable: !0, value: i},
            scale: {enumerable: !0, value: n},
            modelViewMatrix: {value: new gu},
            normalMatrix: {value: new _u}
        }), this.matrix = new gu, this.matrixWorld = new gu, this.matrixAutoUpdate = Pp.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new lp, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    Pp.DefaultUp = new yu(0, 1, 0), Pp.DefaultMatrixAutoUpdate = !0, Pp.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: Pp, isObject3D: !0, onBeforeRender: function () {
        }, onAfterRender: function () {
        }, applyMatrix: function (e) {
            this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }, applyQuaternion: function (e) {
            return this.quaternion.premultiply(e), this
        }, setRotationFromAxisAngle: function (e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        }, setRotationFromEuler: function (e) {
            this.quaternion.setFromEuler(e, !0)
        }, setRotationFromMatrix: function (e) {
            this.quaternion.setFromRotationMatrix(e)
        }, setRotationFromQuaternion: function (e) {
            this.quaternion.copy(e)
        }, rotateOnAxis: (Ap = new vu, function (e, t) {
            return Ap.setFromAxisAngle(e, t), this.quaternion.multiply(Ap), this
        }), rotateOnWorldAxis: (Ep = new vu, function (e, t) {
            return Ep.setFromAxisAngle(e, t), this.quaternion.premultiply(Ep), this
        }), rotateX: (Sp = new yu(1, 0, 0), function (e) {
            return this.rotateOnAxis(Sp, e)
        }), rotateY: (Tp = new yu(0, 1, 0), function (e) {
            return this.rotateOnAxis(Tp, e)
        }), rotateZ: (wp = new yu(0, 0, 1), function (e) {
            return this.rotateOnAxis(wp, e)
        }), translateOnAxis: (bp = new yu, function (e, t) {
            return bp.copy(e).applyQuaternion(this.quaternion), this.position.add(bp.multiplyScalar(t)), this
        }), translateX: (xp = new yu(1, 0, 0), function (e) {
            return this.translateOnAxis(xp, e)
        }), translateY: (_p = new yu(0, 1, 0), function (e) {
            return this.translateOnAxis(_p, e)
        }), translateZ: (yp = new yu(0, 0, 1), function (e) {
            return this.translateOnAxis(yp, e)
        }), localToWorld: function (e) {
            return e.applyMatrix4(this.matrixWorld)
        }, worldToLocal: (vp = new gu, function (e) {
            return e.applyMatrix4(vp.getInverse(this.matrixWorld))
        }), lookAt: (dp = new vu, fp = new gu, mp = new yu, gp = new yu, function (e, t, i) {
            e.isVector3 ? mp.copy(e) : mp.set(e, t, i);
            var n = this.parent;
            this.updateWorldMatrix(!0, !1), gp.setFromMatrixPosition(this.matrixWorld), this.isCamera ? fp.lookAt(gp, mp, this.up) : fp.lookAt(mp, gp, this.up), this.quaternion.setFromRotationMatrix(fp), n && (fp.extractRotation(n.matrixWorld), dp.setFromRotationMatrix(fp), this.quaternion.premultiply(dp.inverse()))
        }), add: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                return this
            }
            return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({type: "added"}), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this
        }, remove: function (e) {
            if (1 < arguments.length) {
                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                return this
            }
            var i = this.children.indexOf(e);
            return -1 !== i && (e.parent = null, e.dispatchEvent({type: "removed"}), this.children.splice(i, 1)), this
        }, getObjectById: function (e) {
            return this.getObjectByProperty("id", e)
        }, getObjectByName: function (e) {
            return this.getObjectByProperty("name", e)
        }, getObjectByProperty: function (e, t) {
            if (this[e] === t) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r) return r
            }
        }, getWorldPosition: function (e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new yu), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
        }, getWorldQuaternion: (up = new yu, pp = new yu, function (e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new vu), this.updateMatrixWorld(!0), this.matrixWorld.decompose(up, e, pp), e
        }), getWorldScale: (hp = new yu, cp = new vu, function (e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new yu), this.updateMatrixWorld(!0), this.matrixWorld.decompose(hp, cp, e), e
        }), getWorldDirection: function (e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new yu), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        }, raycast: function () {
        }, traverse: function (e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e)
        }, traverseVisible: function (e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e)
            }
        }, traverseAncestors: function (e) {
            var t = this.parent;
            null !== t && (e(t), t.traverseAncestors(e))
        }, updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }, updateMatrixWorld: function (e) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1));
            for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e)
        }, updateWorldMatrix: function (e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(!1, !0)
        }, toJSON: function (i) {
            var e = void 0 === i || "string" == typeof i, t = {};
            e && (i = {geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}}, t.metadata = {
                version: 4.5, type: "Object", generator: "Object3D.toJSON"
            });
            var n = {};

            function r(e, t) {
                return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(i)), t.uuid
            }

            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                n.geometry = r(i.geometries, this.geometry);
                var a = this.geometry.parameters;
                if (void 0 !== a && void 0 !== a.shapes) {
                    var o = a.shapes;
                    if (Array.isArray(o)) for (var s = 0, l = o.length; s < l; s++) {
                        var h = o[s];
                        r(i.shapes, h)
                    } else r(i.shapes, o)
                }
            }
            if (void 0 !== this.material) if (Array.isArray(this.material)) {
                var c = [];
                for (s = 0, l = this.material.length; s < l; s++) c.push(r(i.materials, this.material[s]));
                n.material = c
            } else n.material = r(i.materials, this.material);
            if (0 < this.children.length) {
                n.children = [];
                for (s = 0; s < this.children.length; s++) n.children.push(this.children[s].toJSON(i).object)
            }
            if (e) {
                var u = m(i.geometries), p = m(i.materials), d = m(i.textures), f = m(i.images);
                o = m(i.shapes);
                0 < u.length && (t.geometries = u), 0 < p.length && (t.materials = p), 0 < d.length && (t.textures = d), 0 < f.length && (t.images = f), 0 < o.length && (t.shapes = o)
            }
            return t.object = n, t;

            function m(e) {
                var t = [];
                for (var i in e) {
                    var n = e[i];
                    delete n.metadata, t.push(n)
                }
                return t
            }
        }, clone: function (e) {
            return (new this.constructor).copy(this, e)
        }, copy: function (e, t) {
            if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (var i = 0; i < e.children.length; i++) {
                var n = e.children[i];
                this.add(n.clone())
            }
            return this
        }
    });
    var Lp, Cp, Ip, Rp, Op, Fp, Np, kp = 0;

    function Up() {
        Object.defineProperty(this, "id", {value: kp += 2}), this.uuid = fu.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Dp(e, t, i) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0, count: -1
        }, this.version = 0
    }

    function zp(e, t, i) {
        Dp.call(this, new Int8Array(e), t, i)
    }

    function Bp(e, t, i) {
        Dp.call(this, new Uint8Array(e), t, i)
    }

    function Hp(e, t, i) {
        Dp.call(this, new Uint8ClampedArray(e), t, i)
    }

    function Gp(e, t, i) {
        Dp.call(this, new Int16Array(e), t, i)
    }

    function jp(e, t, i) {
        Dp.call(this, new Uint16Array(e), t, i)
    }

    function Vp(e, t, i) {
        Dp.call(this, new Int32Array(e), t, i)
    }

    function Xp(e, t, i) {
        Dp.call(this, new Uint32Array(e), t, i)
    }

    function Wp(e, t, i) {
        Dp.call(this, new Float32Array(e), t, i)
    }

    function Yp(e, t, i) {
        Dp.call(this, new Float64Array(e), t, i)
    }

    function qp() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
    }

    function Qp(e) {
        if (0 === e.length) return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]);
        return t
    }

    Up.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: Up, isGeometry: !0, applyMatrix: function (e) {
            for (var t = (new _u).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) {
                this.vertices[i].applyMatrix4(e)
            }
            for (i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i];
                r.normal.applyMatrix3(t).normalize();
                for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
        }, rotateX: (Np = new gu, function (e) {
            return Np.makeRotationX(e), this.applyMatrix(Np), this
        }), rotateY: (Fp = new gu, function (e) {
            return Fp.makeRotationY(e), this.applyMatrix(Fp), this
        }), rotateZ: (Op = new gu, function (e) {
            return Op.makeRotationZ(e), this.applyMatrix(Op), this
        }), translate: (Rp = new gu, function (e, t, i) {
            return Rp.makeTranslation(e, t, i), this.applyMatrix(Rp), this
        }), scale: (Ip = new gu, function (e, t, i) {
            return Ip.makeScale(e, t, i), this.applyMatrix(Ip), this
        }), lookAt: (Cp = new Pp, function (e) {
            Cp.lookAt(e), Cp.updateMatrix(), this.applyMatrix(Cp.matrix)
        }), fromBufferGeometry: function (e) {
            var a = this, t = null !== e.index ? e.index.array : void 0, i = e.attributes, n = i.position.array,
                o = void 0 !== i.normal ? i.normal.array : void 0, s = void 0 !== i.color ? i.color.array : void 0,
                l = void 0 !== i.uv ? i.uv.array : void 0, h = void 0 !== i.uv2 ? i.uv2.array : void 0;
            void 0 !== h && (this.faceVertexUvs[1] = []);
            for (var c = [], u = [], p = [], r = 0, d = 0; r < n.length; r += 3, d += 2) a.vertices.push(new yu(n[r], n[r + 1], n[r + 2])), void 0 !== o && c.push(new yu(o[r], o[r + 1], o[r + 2])), void 0 !== s && a.colors.push(new $u(s[r], s[r + 1], s[r + 2])), void 0 !== l && u.push(new mu(l[d], l[d + 1])), void 0 !== h && p.push(new mu(h[d], h[d + 1]));

            function f(e, t, i, n) {
                var r = new op(e, t, i, void 0 !== o ? [c[e].clone(), c[t].clone(), c[i].clone()] : [], void 0 !== s ? [a.colors[e].clone(), a.colors[t].clone(), a.colors[i].clone()] : [], n);
                a.faces.push(r), void 0 !== l && a.faceVertexUvs[0].push([u[e].clone(), u[t].clone(), u[i].clone()]), void 0 !== h && a.faceVertexUvs[1].push([p[e].clone(), p[t].clone(), p[i].clone()])
            }

            var m = e.groups;
            if (0 < m.length) for (r = 0; r < m.length; r++) for (var g = m[r], v = g.start, y = (d = v, v + g.count); d < y; d += 3) void 0 !== t ? f(t[d], t[d + 1], t[d + 2], g.materialIndex) : f(d, d + 1, d + 2, g.materialIndex); else if (void 0 !== t) for (r = 0; r < t.length; r += 3) f(t[r], t[r + 1], t[r + 2]); else for (r = 0; r < n.length / 3; r += 3) f(r, r + 1, r + 2);
            return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
        }, center: (Lp = new yu, function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter(Lp).negate(), this.translate(Lp.x, Lp.y, Lp.z), this
        }), normalize: function () {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center, t = this.boundingSphere.radius, i = 0 === t ? 1 : 1 / t, n = new gu;
            return n.set(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1), this.applyMatrix(n), this
        }, computeFaceNormals: function () {
            for (var e = new yu, t = new yu, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i], a = this.vertices[r.a], o = this.vertices[r.b], s = this.vertices[r.c];
                e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), r.normal.copy(e)
            }
        }, computeVertexNormals: function (e) {
            var t, i, n, r, a, o;
            for (void 0 === e && (e = !0), o = new Array(this.vertices.length), t = 0, i = this.vertices.length; t < i; t++) o[t] = new yu;
            if (e) {
                var s, l, h, c = new yu, u = new yu;
                for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], s = this.vertices[a.a], l = this.vertices[a.b], h = this.vertices[a.c], c.subVectors(h, l), u.subVectors(s, l), c.cross(u), o[a.a].add(c), o[a.b].add(c), o[a.c].add(c)
            } else for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal);
            for (t = 0, i = this.vertices.length; t < i; t++) o[t].normalize();
            for (n = 0, r = this.faces.length; n < r; n++) {
                var p = (a = this.faces[n]).vertexNormals;
                3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeFlatVertexNormals: function () {
            var e, t, i;
            for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                var n = (i = this.faces[e]).vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeMorphNormals: function () {
            var e, t, i, n, r;
            for (i = 0, n = this.faces.length; i < n; i++) for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
            var a = new Up;
            for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                if (!this.morphNormals[e]) {
                    this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                    var o = this.morphNormals[e].faceNormals, s = this.morphNormals[e].vertexNormals;
                    for (i = 0, n = this.faces.length; i < n; i++) l = new yu, h = {
                        a: new yu, b: new yu, c: new yu
                    }, o.push(l), s.push(h)
                }
                var l, h, c = this.morphNormals[e];
                for (a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], l = c.faceNormals[i], h = c.vertexNormals[i], l.copy(r.normal), h.a.copy(r.vertexNormals[0]), h.b.copy(r.vertexNormals[1]), h.c.copy(r.vertexNormals[2])
            }
            for (i = 0, n = this.faces.length; i < n; i++) (r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ju), this.boundingBox.setFromPoints(this.vertices)
        }, computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new Vu), this.boundingSphere.setFromPoints(this.vertices)
        }, merge: function (e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length, a = this.vertices, o = e.vertices, s = this.faces, l = e.faces,
                    h = this.faceVertexUvs[0], c = e.faceVertexUvs[0], u = this.colors, p = e.colors;
                void 0 === i && (i = 0), void 0 !== t && (n = (new _u).getNormalMatrix(t));
                for (var d = 0, f = o.length; d < f; d++) {
                    var m = o[d].clone();
                    void 0 !== t && m.applyMatrix4(t), a.push(m)
                }
                for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
                for (d = 0, f = l.length; d < f; d++) {
                    var g, v, y, _ = l[d], x = _.vertexNormals, b = _.vertexColors;
                    (g = new op(_.a + r, _.b + r, _.c + r)).normal.copy(_.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                    for (var w = 0, T = x.length; w < T; w++) v = x[w].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                    g.color.copy(_.color);
                    for (w = 0, T = b.length; w < T; w++) y = b[w], g.vertexColors.push(y.clone());
                    g.materialIndex = _.materialIndex + i, s.push(g)
                }
                for (d = 0, f = c.length; d < f; d++) {
                    var S = c[d], E = [];
                    if (void 0 !== S) {
                        for (w = 0, T = S.length; w < T; w++) E.push(S[w].clone());
                        h.push(E)
                    }
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        }, mergeMesh: function (e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        }, mergeVertices: function () {
            var e, t, i, n, r, a, o, s, l = {}, h = [], c = [], u = Math.pow(10, 4);
            for (i = 0, n = this.vertices.length; i < n; i++) e = this.vertices[i], void 0 === l[t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u)] ? (l[t] = i, h.push(this.vertices[i]), c[i] = h.length - 1) : c[i] = c[l[t]];
            var p = [];
            for (i = 0, n = this.faces.length; i < n; i++) {
                (r = this.faces[i]).a = c[r.a], r.b = c[r.b], r.c = c[r.c], a = [r.a, r.b, r.c];
                for (var d = 0; d < 3; d++) if (a[d] === a[(d + 1) % 3]) {
                    p.push(i);
                    break
                }
            }
            for (i = p.length - 1; 0 <= i; i--) {
                var f = p[i];
                for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1)
            }
            var m = this.vertices.length - h.length;
            return this.vertices = h, m
        }, setFromPoints: function (e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new yu(n.x, n.y, n.z || 0))
            }
            return this
        }, sortFacesByMaterialIndex: function () {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
            e.sort(function (e, t) {
                return e.materialIndex - t.materialIndex
            });
            var n, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1];
            a && a.length === t && (n = []), o && o.length === t && (r = []);
            for (i = 0; i < t; i++) {
                var s = e[i]._id;
                n && n.push(a[s]), r && r.push(o[s])
            }
            n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r)
        }, toJSON: function () {
            var e = {metadata: {version: 4.5, type: "Geometry", generator: "Geometry.toJSON"}};
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var i in t) void 0 !== t[i] && (e[i] = t[i]);
                return e
            }
            for (var n = [], r = 0; r < this.vertices.length; r++) {
                var a = this.vertices[r];
                n.push(a.x, a.y, a.z)
            }
            var o = [], s = [], l = {}, h = [], c = {}, u = [], p = {};
            for (r = 0; r < this.faces.length; r++) {
                var d = this.faces[r], f = void 0 !== this.faceVertexUvs[0][r], m = 0 < d.normal.length(),
                    g = 0 < d.vertexNormals.length, v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                    y = 0 < d.vertexColors.length, _ = 0;
                if (_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_ = T(_, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, y), o.push(_), o.push(d.a, d.b, d.c), o.push(d.materialIndex), f) {
                    var x = this.faceVertexUvs[0][r];
                    o.push(A(x[0]), A(x[1]), A(x[2]))
                }
                if (m && o.push(S(d.normal)), g) {
                    var b = d.vertexNormals;
                    o.push(S(b[0]), S(b[1]), S(b[2]))
                }
                if (v && o.push(E(d.color)), y) {
                    var w = d.vertexColors;
                    o.push(E(w[0]), E(w[1]), E(w[2]))
                }
            }

            function T(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }

            function S(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t]
            }

            function E(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 !== c[t] || (c[t] = h.length, h.push(e.getHex())), c[t]
            }

            function A(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 !== p[t] || (p[t] = u.length / 2, u.push(e.x, e.y)), p[t]
            }

            return e.data = {}, e.data.vertices = n, e.data.normals = s, 0 < h.length && (e.data.colors = h), 0 < u.length && (e.data.uvs = [u]), e.data.faces = o, e
        }, clone: function () {
            return (new Up).copy(this)
        }, copy: function (e) {
            var t, i, n, r, a, o;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var s = e.vertices;
            for (t = 0, i = s.length; t < i; t++) this.vertices.push(s[t].clone());
            var l = e.colors;
            for (t = 0, i = l.length; t < i; t++) this.colors.push(l[t].clone());
            var h = e.faces;
            for (t = 0, i = h.length; t < i; t++) this.faces.push(h[t].clone());
            for (t = 0, i = e.faceVertexUvs.length; t < i; t++) {
                var c = e.faceVertexUvs[t];
                for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), n = 0, r = c.length; n < r; n++) {
                    var u = c[n], p = [];
                    for (a = 0, o = u.length; a < o; a++) {
                        var d = u[a];
                        p.push(d.clone())
                    }
                    this.faceVertexUvs[t].push(p)
                }
            }
            var f = e.morphTargets;
            for (t = 0, i = f.length; t < i; t++) {
                var m = {};
                if (m.name = f[t].name, void 0 !== f[t].vertices) for (m.vertices = [], n = 0, r = f[t].vertices.length; n < r; n++) m.vertices.push(f[t].vertices[n].clone());
                if (void 0 !== f[t].normals) for (m.normals = [], n = 0, r = f[t].normals.length; n < r; n++) m.normals.push(f[t].normals[n].clone());
                this.morphTargets.push(m)
            }
            var g = e.morphNormals;
            for (t = 0, i = g.length; t < i; t++) {
                var v = {};
                if (void 0 !== g[t].vertexNormals) for (v.vertexNormals = [], n = 0, r = g[t].vertexNormals.length; n < r; n++) {
                    var y = g[t].vertexNormals[n], _ = {};
                    _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_)
                }
                if (void 0 !== g[t].faceNormals) for (v.faceNormals = [], n = 0, r = g[t].faceNormals.length; n < r; n++) v.faceNormals.push(g[t].faceNormals[n].clone());
                this.morphNormals.push(v)
            }
            var x = e.skinWeights;
            for (t = 0, i = x.length; t < i; t++) this.skinWeights.push(x[t].clone());
            var b = e.skinIndices;
            for (t = 0, i = b.length; t < i; t++) this.skinIndices.push(b[t].clone());
            var w = e.lineDistances;
            for (t = 0, i = w.length; t < i; t++) this.lineDistances.push(w[t]);
            var T = e.boundingBox;
            null !== T && (this.boundingBox = T.clone());
            var S = e.boundingSphere;
            return null !== S && (this.boundingSphere = S.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), Object.defineProperty(Dp.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(Dp.prototype, {
        isBufferAttribute: !0, onUploadCallback: function () {
        }, setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
        }, setDynamic: function (e) {
            return this.dynamic = e, this
        }, copy: function (e) {
            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
        }, copyAt: function (e, t, i) {
            e *= this.itemSize, i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        }, copyArray: function (e) {
            return this.array.set(e), this
        }, copyColorsArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new $u), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b
            }
            return this
        }, copyVector2sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new mu), t[i++] = a.x, t[i++] = a.y
            }
            return this
        }, copyVector3sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new yu), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z
            }
            return this
        }, copyVector4sArray: function (e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new zu), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z, t[i++] = a.w
            }
            return this
        }, set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        }, getX: function (e) {
            return this.array[e * this.itemSize]
        }, setX: function (e, t) {
            return this.array[e * this.itemSize] = t, this
        }, getY: function (e) {
            return this.array[e * this.itemSize + 1]
        }, setY: function (e, t) {
            return this.array[e * this.itemSize + 1] = t, this
        }, getZ: function (e) {
            return this.array[e * this.itemSize + 2]
        }, setZ: function (e, t) {
            return this.array[e * this.itemSize + 2] = t, this
        }, getW: function (e) {
            return this.array[e * this.itemSize + 3]
        }, setW: function (e, t) {
            return this.array[e * this.itemSize + 3] = t, this
        }, setXY: function (e, t, i) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
        }, setXYZ: function (e, t, i, n) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this
        }, setXYZW: function (e, t, i, n, r) {
            return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this
        }, onUpload: function (e) {
            return this.onUploadCallback = e, this
        }, clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), (zp.prototype = Object.create(Dp.prototype)).constructor = zp, (Bp.prototype = Object.create(Dp.prototype)).constructor = Bp, (Hp.prototype = Object.create(Dp.prototype)).constructor = Hp, (Gp.prototype = Object.create(Dp.prototype)).constructor = Gp, (jp.prototype = Object.create(Dp.prototype)).constructor = jp, (Vp.prototype = Object.create(Dp.prototype)).constructor = Vp, (Xp.prototype = Object.create(Dp.prototype)).constructor = Xp, (Wp.prototype = Object.create(Dp.prototype)).constructor = Wp, (Yp.prototype = Object.create(Dp.prototype)).constructor = Yp, Object.assign(qp.prototype, {
        computeGroups: function (e) {
            for (var t, i = [], n = void 0, r = e.faces, a = 0; a < r.length; a++) {
                var o = r[a];
                o.materialIndex !== n && (n = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), t = {
                    start: 3 * a, materialIndex: n
                })
            }
            void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), this.groups = i
        }, fromGeometry: function (e) {
            var t, i = e.faces, n = e.vertices, r = e.faceVertexUvs, a = r[0] && 0 < r[0].length,
                o = r[1] && 0 < r[1].length, s = e.morphTargets, l = s.length;
            if (0 < l) {
                t = [];
                for (var h = 0; h < l; h++) t[h] = {name: s[h].name, data: []};
                this.morphTargets.position = t
            }
            var c, u = e.morphNormals, p = u.length;
            if (0 < p) {
                c = [];
                for (h = 0; h < p; h++) c[h] = {name: u[h].name, data: []};
                this.morphTargets.normal = c
            }
            var d = e.skinIndices, f = e.skinWeights, m = d.length === n.length, g = f.length === n.length;
            0 < n.length && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
            for (h = 0; h < i.length; h++) {
                var v = i[h];
                this.vertices.push(n[v.a], n[v.b], n[v.c]);
                var y = v.vertexNormals;
                if (3 === y.length) this.normals.push(y[0], y[1], y[2]); else {
                    var _ = v.normal;
                    this.normals.push(_, _, _)
                }
                var x, b = v.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]); else {
                    var w = v.color;
                    this.colors.push(w, w, w)
                }
                if (!0 === a) void 0 !== (x = r[0][h]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new mu, new mu, new mu));
                if (!0 === o) void 0 !== (x = r[1][h]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new mu, new mu, new mu));
                for (var T = 0; T < l; T++) {
                    var S = s[T].vertices;
                    t[T].data.push(S[v.a], S[v.b], S[v.c])
                }
                for (T = 0; T < p; T++) {
                    var E = u[T].vertexNormals[h];
                    c[T].data.push(E.a, E.b, E.c)
                }
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
        }
    });
    var Zp, Jp, Kp, $p, ed, td, id, nd, rd, ad, od = 1;

    function sd() {
        Object.defineProperty(this, "id", {value: od += 2}), this.uuid = fu.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0, count: 1 / 0
        }, this.userData = {}
    }

    function ld(e, t, i, n, r, a) {
        Up.call(this), this.type = "BoxGeometry", this.parameters = {
            width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a
        }, this.fromBufferGeometry(new hd(e, t, i, n, r, a)), this.mergeVertices()
    }

    function hd(e, t, i, n, r, a) {
        sd.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a
        };
        var L = this;
        e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1;
        var C = [], I = [], R = [], O = [], F = 0, N = 0;

        function o(e, t, i, n, r, a, o, s, l, h, c) {
            var u, p, d = a / l, f = o / h, m = a / 2, g = o / 2, v = s / 2, y = l + 1, _ = h + 1, x = 0, b = 0,
                w = new yu;
            for (p = 0; p < _; p++) {
                var T = p * f - g;
                for (u = 0; u < y; u++) {
                    var S = u * d - m;
                    w[e] = S * n, w[t] = T * r, w[i] = v, I.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[i] = 0 < s ? 1 : -1, R.push(w.x, w.y, w.z), O.push(u / l), O.push(1 - p / h), x += 1
                }
            }
            for (p = 0; p < h; p++) for (u = 0; u < l; u++) {
                var E = F + u + y * p, A = F + u + y * (p + 1), M = F + (u + 1) + y * (p + 1), P = F + (u + 1) + y * p;
                C.push(E, A, P), C.push(A, M, P), b += 6
            }
            L.addGroup(N, b, c), N += b, F += x
        }

        o("z", "y", "x", -1, -1, i, t, e, a, r, 0), o("z", "y", "x", 1, -1, i, t, -e, a, r, 1), o("x", "z", "y", 1, 1, e, i, t, n, a, 2), o("x", "z", "y", 1, -1, e, i, -t, n, a, 3), o("x", "y", "z", 1, -1, e, t, i, n, r, 4), o("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(C), this.addAttribute("position", new Wp(I, 3)), this.addAttribute("normal", new Wp(R, 3)), this.addAttribute("uv", new Wp(O, 2))
    }

    function cd(e, t, i, n) {
        Up.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: e, height: t, widthSegments: i, heightSegments: n
        }, this.fromBufferGeometry(new ud(e, t, i, n)), this.mergeVertices()
    }

    function ud(e, t, i, n) {
        sd.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: e, height: t, widthSegments: i, heightSegments: n
        };
        var r, a, o = (e = e || 1) / 2, s = (t = t || 1) / 2, l = Math.floor(i) || 1, h = Math.floor(n) || 1, c = l + 1,
            u = h + 1, p = e / l, d = t / h, f = [], m = [], g = [], v = [];
        for (a = 0; a < u; a++) {
            var y = a * d - s;
            for (r = 0; r < c; r++) {
                var _ = r * p - o;
                m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - a / h)
            }
        }
        for (a = 0; a < h; a++) for (r = 0; r < l; r++) {
            var x = r + c * a, b = r + c * (a + 1), w = r + 1 + c * (a + 1), T = r + 1 + c * a;
            f.push(x, b, T), f.push(b, w, T)
        }
        this.setIndex(f), this.addAttribute("position", new Wp(m, 3)), this.addAttribute("normal", new Wp(g, 3)), this.addAttribute("uv", new Wp(v, 2))
    }

    sd.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: sd, isBufferGeometry: !0, getIndex: function () {
            return this.index
        }, setIndex: function (e) {
            Array.isArray(e) ? this.index = new (65535 < Qp(e) ? Xp : jp)(e, 1) : this.index = e
        }, addAttribute: function (e, t) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? ("index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t)) : this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new Dp(t, arguments[2])))
        }, getAttribute: function (e) {
            return this.attributes[e]
        }, removeAttribute: function (e) {
            return delete this.attributes[e], this
        }, addGroup: function (e, t, i) {
            this.groups.push({start: e, count: t, materialIndex: void 0 !== i ? i : 0})
        }, clearGroups: function () {
            this.groups = []
        }, setDrawRange: function (e, t) {
            this.drawRange.start = e, this.drawRange.count = t
        }, applyMatrix: function (e) {
            var t = this.attributes.position;
            void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
            var i = this.attributes.normal;
            void 0 !== i && ((new _u).getNormalMatrix(e).applyToBufferAttribute(i), i.needsUpdate = !0);
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }, rotateX: (ad = new gu, function (e) {
            return ad.makeRotationX(e), this.applyMatrix(ad), this
        }), rotateY: (rd = new gu, function (e) {
            return rd.makeRotationY(e), this.applyMatrix(rd), this
        }), rotateZ: (nd = new gu, function (e) {
            return nd.makeRotationZ(e), this.applyMatrix(nd), this
        }), translate: (id = new gu, function (e, t, i) {
            return id.makeTranslation(e, t, i), this.applyMatrix(id), this
        }), scale: (td = new gu, function (e, t, i) {
            return td.makeScale(e, t, i), this.applyMatrix(td), this
        }), lookAt: (ed = new Pp, function (e) {
            ed.lookAt(e), ed.updateMatrix(), this.applyMatrix(ed.matrix)
        }), center: ($p = new yu, function () {
            return this.computeBoundingBox(), this.boundingBox.getCenter($p).negate(), this.translate($p.x, $p.y, $p.z), this
        }), setFromObject: function (e) {
            var t = e.geometry;
            if (e.isPoints || e.isLine) {
                var i = new Wp(3 * t.vertices.length, 3), n = new Wp(3 * t.colors.length, 3);
                if (this.addAttribute("position", i.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                    var r = new Wp(t.lineDistances.length, 1);
                    this.addAttribute("lineDistance", r.copyArray(t.lineDistances))
                }
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
            } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
            return this
        }, setFromPoints: function (e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new Wp(t, 3)), this
        }, updateFromObject: function (e) {
            var t, i = e.geometry;
            if (e.isMesh) {
                var n = i.__directGeometry;
                if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n
            }
            return !0 === i.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(i.vertices), t.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(i.normals), t.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(i.colors), t.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(i.uvs), t.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(i.lineDistances), t.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(e.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this
        }, fromGeometry: function (e) {
            return e.__directGeometry = (new qp).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
        }, fromDirectGeometry: function (e) {
            var t = new Float32Array(3 * e.vertices.length);
            if (this.addAttribute("position", new Dp(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) {
                var i = new Float32Array(3 * e.normals.length);
                this.addAttribute("normal", new Dp(i, 3).copyVector3sArray(e.normals))
            }
            if (0 < e.colors.length) {
                var n = new Float32Array(3 * e.colors.length);
                this.addAttribute("color", new Dp(n, 3).copyColorsArray(e.colors))
            }
            if (0 < e.uvs.length) {
                var r = new Float32Array(2 * e.uvs.length);
                this.addAttribute("uv", new Dp(r, 2).copyVector2sArray(e.uvs))
            }
            if (0 < e.uvs2.length) {
                var a = new Float32Array(2 * e.uvs2.length);
                this.addAttribute("uv2", new Dp(a, 2).copyVector2sArray(e.uvs2))
            }
            for (var o in this.groups = e.groups, e.morphTargets) {
                for (var s = [], l = e.morphTargets[o], h = 0, c = l.length; h < c; h++) {
                    var u = l[h], p = new Wp(3 * u.data.length, 3);
                    p.name = u.name, s.push(p.copyVector3sArray(u.data))
                }
                this.morphAttributes[o] = s
            }
            if (0 < e.skinIndices.length) {
                var d = new Wp(4 * e.skinIndices.length, 4);
                this.addAttribute("skinIndex", d.copyVector4sArray(e.skinIndices))
            }
            if (0 < e.skinWeights.length) {
                var f = new Wp(4 * e.skinWeights.length, 4);
                this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
            }
            return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new ju);
            var e = this.attributes.position;
            void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }, computeBoundingSphere: (Jp = new ju, Kp = new yu, function () {
            null === this.boundingSphere && (this.boundingSphere = new Vu);
            var e = this.attributes.position;
            if (e) {
                var t = this.boundingSphere.center;
                Jp.setFromBufferAttribute(e), Jp.getCenter(t);
                for (var i = 0, n = 0, r = e.count; n < r; n++) Kp.x = e.getX(n), Kp.y = e.getY(n), Kp.z = e.getZ(n), i = Math.max(i, t.distanceToSquared(Kp));
                this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }), computeFaceNormals: function () {
        }, computeVertexNormals: function () {
            var e = this.index, t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal) this.addAttribute("normal", new Dp(new Float32Array(i.length), 3)); else for (var n = t.normal.array, r = 0, a = n.length; r < a; r++) n[r] = 0;
                var o, s, l, h = t.normal.array, c = new yu, u = new yu, p = new yu, d = new yu, f = new yu;
                if (e) {
                    var m = e.array;
                    for (r = 0, a = e.count; r < a; r += 3) o = 3 * m[r + 0], s = 3 * m[r + 1], l = 3 * m[r + 2], c.fromArray(i, o), u.fromArray(i, s), p.fromArray(i, l), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), h[o] += d.x, h[o + 1] += d.y, h[o + 2] += d.z, h[s] += d.x, h[s + 1] += d.y, h[s + 2] += d.z, h[l] += d.x, h[l + 1] += d.y, h[l + 2] += d.z
                } else for (r = 0, a = i.length; r < a; r += 9) c.fromArray(i, r), u.fromArray(i, r + 3), p.fromArray(i, r + 6), d.subVectors(p, u), f.subVectors(c, u), d.cross(f), h[r] = d.x, h[r + 1] = d.y, h[r + 2] = d.z, h[r + 3] = d.x, h[r + 4] = d.y, h[r + 5] = d.z, h[r + 6] = d.x, h[r + 7] = d.y, h[r + 8] = d.z;
                this.normalizeNormals(), t.normal.needsUpdate = !0
            }
        }, merge: function (e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i = this.attributes;
                for (var n in i) if (void 0 !== e.attributes[n]) for (var r = i[n].array, a = e.attributes[n], o = a.array, s = 0, l = a.itemSize * t; s < o.length; s++, l++) r[l] = o[s];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        }, normalizeNormals: (Zp = new yu, function () {
            for (var e = this.attributes.normal, t = 0, i = e.count; t < i; t++) Zp.x = e.getX(t), Zp.y = e.getY(t), Zp.z = e.getZ(t), Zp.normalize(), e.setXYZ(t, Zp.x, Zp.y, Zp.z)
        }), toNonIndexed: function () {
            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e = new sd, t = this.index.array, i = this.attributes;
            for (var n in i) {
                for (var r = i[n], a = r.array, o = r.itemSize, s = new a.constructor(t.length * o), l = 0, h = 0, c = 0, u = t.length; c < u; c++) {
                    l = t[c] * o;
                    for (var p = 0; p < o; p++) s[h++] = a[l++]
                }
                e.addAttribute(n, new Dp(s, o))
            }
            var d = this.groups;
            for (c = 0, u = d.length; c < u; c++) {
                var f = d[c];
                e.addGroup(f.start, f.count, f.materialIndex)
            }
            return e
        }, toJSON: function () {
            var e = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) {
                var t = this.parameters;
                for (var i in t) void 0 !== t[i] && (e[i] = t[i]);
                return e
            }
            e.data = {attributes: {}};
            var n = this.index;
            if (null !== n) {
                var r = Array.prototype.slice.call(n.array);
                e.data.index = {type: n.array.constructor.name, array: r}
            }
            var a = this.attributes;
            for (var i in a) {
                var o = a[i];
                r = Array.prototype.slice.call(o.array);
                e.data.attributes[i] = {
                    itemSize: o.itemSize, type: o.array.constructor.name, array: r, normalized: o.normalized
                }
            }
            var s = this.groups;
            0 < s.length && (e.data.groups = JSON.parse(JSON.stringify(s)));
            var l = this.boundingSphere;
            return null !== l && (e.data.boundingSphere = {center: l.center.toArray(), radius: l.radius}), e
        }, clone: function () {
            return (new sd).copy(this)
        }, copy: function (e) {
            var t, i, n;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
            var r = e.index;
            null !== r && this.setIndex(r.clone());
            var a = e.attributes;
            for (t in a) {
                var o = a[t];
                this.addAttribute(t, o.clone())
            }
            var s = e.morphAttributes;
            for (t in s) {
                var l = [], h = s[t];
                for (i = 0, n = h.length; i < n; i++) l.push(h[i].clone());
                this.morphAttributes[t] = l
            }
            var c = e.groups;
            for (i = 0, n = c.length; i < n; i++) {
                var u = c[i];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            var p = e.boundingBox;
            null !== p && (this.boundingBox = p.clone());
            var d = e.boundingSphere;
            return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), (ld.prototype = Object.create(Up.prototype)).constructor = ld, (hd.prototype = Object.create(sd.prototype)).constructor = hd, (cd.prototype = Object.create(Up.prototype)).constructor = cd, (ud.prototype = Object.create(sd.prototype)).constructor = ud;
    var pd, dd, fd, md, gd, vd, yd, _d, xd, bd, wd, Td, Sd, Ed, Ad, Md, Pd, Ld, Cd, Id, Rd, Od, Fd, Nd, kd, Ud = 0;

    function Dd() {
        Object.defineProperty(this, "id", {value: Ud++}), this.uuid = fu.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = ph, this.side = sh, this.flatShading = !1, this.vertexColors = ch, this.opacity = 1, this.transparent = !1, this.blendSrc = Ah, this.blendDst = Mh, this.blendEquation = vh, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = kh, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function zd(e) {
        Dd.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
            derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1], uv: [0, 0], uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
    }

    function Bd(e, t) {
        this.origin = void 0 !== e ? e : new yu, this.direction = void 0 !== t ? t : new yu
    }

    function Hd(e, t, i) {
        this.a = void 0 !== e ? e : new yu, this.b = void 0 !== t ? t : new yu, this.c = void 0 !== i ? i : new yu
    }

    function Gd(e) {
        Dd.call(this), this.type = "MeshBasicMaterial", this.color = new $u(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
    }

    function jd(e, t) {
        Pp.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new sd, this.material = void 0 !== t ? t : new Gd({color: 16777215 * Math.random()}), this.drawMode = iu, this.updateMorphTargets()
    }

    function Vd(a, i, o, n) {
        var s, l, h = new $u(0), c = 0;

        function u(e, t) {
            i.buffers.color.setClear(e.r, e.g, e.b, t, n)
        }

        return {
            getClearColor: function () {
                return h
            }, setClearColor: function (e, t) {
                h.set(e), u(h, c = void 0 !== t ? t : 1)
            }, getClearAlpha: function () {
                return c
            }, setClearAlpha: function (e) {
                u(h, c = e)
            }, render: function (e, t, i, n) {
                var r = t.background;
                null === r ? u(h, c) : r && r.isColor && (u(r, 1), n = !0), (a.autoClear || n) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), r && r.isCubeTexture ? (void 0 === l && ((l = new jd(new hd(1, 1, 1), new zd({
                    uniforms: Ju.clone(np.cube.uniforms),
                    vertexShader: np.cube.vertexShader,
                    fragmentShader: np.cube.fragmentShader,
                    side: lh,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, o.update(l)), l.material.uniforms.tCube.value = r, e.push(l, l.geometry, l.material, 0, null)) : r && r.isTexture && (void 0 === s && ((s = new jd(new ud(2, 2), new zd({
                    uniforms: Ju.clone(np.background.uniforms),
                    vertexShader: np.background.vertexShader,
                    fragmentShader: np.background.fragmentShader,
                    side: sh,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"), o.update(s)), s.material.uniforms.t2D.value = r, e.push(s, s.geometry, s.material, 0, null))
            }
        }
    }

    function Xd(r, a, o, s) {
        var l;
        this.setMode = function (e) {
            l = e
        }, this.render = function (e, t) {
            r.drawArrays(l, e, t), o.update(t, l)
        }, this.renderInstances = function (e, t, i) {
            var n;
            if (s.isWebGL2) n = r; else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            n[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](l, t, i, e.maxInstancedCount), o.update(i, l, e.maxInstancedCount)
        }
    }

    function Wd(t, i, e) {
        var n;

        function r(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision) return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision && 0 < t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
        }

        var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
            o = void 0 !== e.precision ? e.precision : "highp", s = r(o);
        s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
        var l = !0 === e.logarithmicDepthBuffer, h = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            c = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), u = t.getParameter(t.MAX_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), d = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), m = t.getParameter(t.MAX_VARYING_VECTORS),
            g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), v = 0 < c, y = a || !!i.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function () {
                if (void 0 !== n) return n;
                var e = i.get("EXT_texture_filter_anisotropic");
                return n = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: r,
            precision: o,
            logarithmicDepthBuffer: l,
            maxTextures: h,
            maxVertexTextures: c,
            maxTextureSize: u,
            maxCubemapSize: p,
            maxAttributes: d,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y
        }
    }

    function Yd() {
        var c = this, u = null, p = 0, d = !1, f = !1, m = new Xu, g = new _u, v = {value: null, needsUpdate: !1};

        function y() {
            v.value !== u && (v.value = u, v.needsUpdate = 0 < p), c.numPlanes = p, c.numIntersection = 0
        }

        function _(e, t, i, n) {
            var r = null !== e ? e.length : 0, a = null;
            if (0 !== r) {
                if (a = v.value, !0 !== n || null === a) {
                    var o = i + 4 * r, s = t.matrixWorldInverse;
                    g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
                    for (var l = 0, h = i; l !== r; ++l, h += 4) m.copy(e[l]).applyMatrix4(s, g), m.normal.toArray(a, h), a[h + 3] = m.constant
                }
                v.value = a, v.needsUpdate = !0
            }
            return c.numPlanes = r, a
        }

        this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t, i) {
            var n = 0 !== e.length || t || 0 !== p || d;
            return d = t, u = _(e, i, 0), p = e.length, n
        }, this.beginShadows = function () {
            f = !0, _(null)
        }, this.endShadows = function () {
            f = !1, y()
        }, this.setState = function (e, t, i, n, r, a) {
            if (!d || null === e || 0 === e.length || f && !i) f ? _(null) : y(); else {
                var o = f ? 0 : p, s = 4 * o, l = r.clippingState || null;
                v.value = l, l = _(e, n, s, a);
                for (var h = 0; h !== s; ++h) l[h] = u[h];
                r.clippingState = l, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += o
            }
        }
    }

    function qd(i) {
        var n = {};
        return {
            get: function (e) {
                if (void 0 !== n[e]) return n[e];
                var t;
                switch (e) {
                    case"WEBGL_depth_texture":
                        t = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case"EXT_texture_filter_anisotropic":
                        t = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case"WEBGL_compressed_texture_s3tc":
                        t = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case"WEBGL_compressed_texture_pvrtc":
                        t = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        t = i.getExtension(e)
                }
                return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), n[e] = t
            }
        }
    }

    function Qd(u, p, a) {
        var o = {}, d = {};

        function s(e) {
            var t = e.target, i = o[t.id];
            for (var n in null !== i.index && p.remove(i.index), i.attributes) p.remove(i.attributes[n]);
            t.removeEventListener("dispose", s), delete o[t.id];
            var r = d[i.id];
            r && (p.remove(r), delete d[i.id]), a.memory.geometries--
        }

        return {
            get: function (e, t) {
                var i = o[t.id];
                return i || (t.addEventListener("dispose", s), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new sd).setFromObject(e)), i = t._bufferGeometry), o[t.id] = i, a.memory.geometries++, i)
            }, update: function (e) {
                var t = e.index, i = e.attributes;
                for (var n in null !== t && p.update(t, u.ELEMENT_ARRAY_BUFFER), i) p.update(i[n], u.ARRAY_BUFFER);
                var r = e.morphAttributes;
                for (var n in r) for (var a = r[n], o = 0, s = a.length; o < s; o++) p.update(a[o], u.ARRAY_BUFFER)
            }, getWireframeAttribute: function (e) {
                var t = d[e.id];
                if (t) return t;
                var i, n = [], r = e.index, a = e.attributes;
                if (null !== r) for (var o = 0, s = (i = r.array).length; o < s; o += 3) {
                    var l = i[o + 0], h = i[o + 1], c = i[o + 2];
                    n.push(l, h, h, c, c, l)
                } else for (o = 0, s = (i = a.position.array).length / 3 - 1; o < s; o += 3) l = o + 0, h = o + 1, c = o + 2, n.push(l, h, h, c, c, l);
                return t = new (65535 < Qp(n) ? Xp : jp)(n, 1), p.update(t, u.ELEMENT_ARRAY_BUFFER), d[e.id] = t
            }
        }
    }

    function Zd(r, a, o, s) {
        var l, h, c;
        this.setMode = function (e) {
            l = e
        }, this.setIndex = function (e) {
            h = e.type, c = e.bytesPerElement
        }, this.render = function (e, t) {
            r.drawElements(l, t, h, e * c), o.update(t, l)
        }, this.renderInstances = function (e, t, i) {
            var n;
            if (s.isWebGL2) n = r; else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            n[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](l, i, h, t * c, e.maxInstancedCount), o.update(i, l, e.maxInstancedCount)
        }
    }

    function Jd(n) {
        var r = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
        return {
            memory: {geometries: 0, textures: 0}, render: r, programs: null, autoReset: !0, reset: function () {
                r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
            }, update: function (e, t, i) {
                switch (i = i || 1, r.calls++, t) {
                    case n.TRIANGLES:
                        r.triangles += i * (e / 3);
                        break;
                    case n.TRIANGLE_STRIP:
                    case n.TRIANGLE_FAN:
                        r.triangles += i * (e - 2);
                        break;
                    case n.LINES:
                        r.lines += i * (e / 2);
                        break;
                    case n.LINE_STRIP:
                        r.lines += i * (e - 1);
                        break;
                    case n.LINE_LOOP:
                        r.lines += i * e;
                        break;
                    case n.POINTS:
                        r.points += i * e;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                }
            }
        }
    }

    function Kd(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }

    function $d(d) {
        var f = {}, m = new Float32Array(8);
        return {
            update: function (e, t, i, n) {
                var r = e.morphTargetInfluences, a = r.length, o = f[t.id];
                if (void 0 === o) {
                    o = [];
                    for (var s = 0; s < a; s++) o[s] = [s, 0];
                    f[t.id] = o
                }
                var l = i.morphTargets && t.morphAttributes.position, h = i.morphNormals && t.morphAttributes.normal;
                for (s = 0; s < a; s++) 0 !== (c = o[s])[1] && (l && t.removeAttribute("morphTarget" + s), h && t.removeAttribute("morphNormal" + s));
                for (s = 0; s < a; s++) (c = o[s])[0] = s, c[1] = r[s];
                for (o.sort(Kd), s = 0; s < 8; s++) {
                    var c;
                    if (c = o[s]) {
                        var u = c[0], p = c[1];
                        if (p) {
                            l && t.addAttribute("morphTarget" + s, l[u]), h && t.addAttribute("morphNormal" + s, h[u]), m[s] = p;
                            continue
                        }
                    }
                    m[s] = 0
                }
                n.getUniforms().setValue(d, "morphTargetInfluences", m)
            }
        }
    }

    function ef(r, a) {
        var o = {};
        return {
            update: function (e) {
                var t = a.render.frame, i = e.geometry, n = r.get(e, i);
                return o[n.id] !== t && (i.isGeometry && n.updateFromObject(e), r.update(n), o[n.id] = t), n
            }, dispose: function () {
                o = {}
            }
        }
    }

    function tf(e, t, i, n, r, a, o, s, l, h) {
        Du.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : Qh, i, n, r, a, o, s, l, h), this.flipY = !1
    }

    function nf(e, t, i, n) {
        Du.call(this, null), this.image = {
            data: e, width: t, height: i, depth: n
        }, this.magFilter = ac, this.minFilter = ac, this.generateMipmaps = !1, this.flipY = !1
    }

    Dd.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: Dd, isMaterial: !0, onBeforeCompile: function () {
        }, setValues: function (e) {
            if (void 0 !== e) for (var t in e) {
                var i = e[t];
                if (void 0 !== i) if ("shading" !== t) {
                    var n = this[t];
                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = "overdraw" === t ? Number(i) : i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i; else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
            }
        }, toJSON: function (e) {
            var t = void 0 === e || "string" == typeof e;
            t && (e = {textures: {}, images: {}});
            var i = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};

            function n(e) {
                var t = [];
                for (var i in e) {
                    var n = e[i];
                    delete n.metadata, t.push(n)
                }
                return t
            }

            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ph && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== sh && (i.side = this.side), this.vertexColors !== ch && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) {
                var r = n(e.textures), a = n(e.images);
                0 < r.length && (i.textures = r), 0 < a.length && (i.images = a)
            }
            return i
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes, i = null;
            if (null !== t) {
                var n = t.length;
                i = new Array(n);
                for (var r = 0; r !== n; ++r) i[r] = t[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), ((zd.prototype = Object.create(Dd.prototype)).constructor = zd).prototype.isShaderMaterial = !0, zd.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ju.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
    }, zd.prototype.toJSON = function (e) {
        var t = Dd.prototype.toJSON.call(this, e);
        for (var i in t.uniforms = {}, this.uniforms) {
            var n = this.uniforms[i].value;
            n.isTexture ? t.uniforms[i] = {type: "t", value: n.toJSON(e).uuid} : n.isColor ? t.uniforms[i] = {
                type: "c", value: n.getHex()
            } : n.isVector2 ? t.uniforms[i] = {
                type: "v2", value: n.toArray()
            } : n.isVector3 ? t.uniforms[i] = {
                type: "v3", value: n.toArray()
            } : n.isVector4 ? t.uniforms[i] = {
                type: "v4", value: n.toArray()
            } : n.isMatrix4 ? t.uniforms[i] = {type: "m4", value: n.toArray()} : t.uniforms[i] = {value: n}
        }
        return 0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
    }, Object.assign(Bd.prototype, {
        set: function (e, t) {
            return this.origin.copy(e), this.direction.copy(t), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
        }, at: function (e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new yu), t.copy(this.direction).multiplyScalar(e).add(this.origin)
        }, lookAt: function (e) {
            return this.direction.copy(e).sub(this.origin).normalize(), this
        }, recast: (wd = new yu, function (e) {
            return this.origin.copy(this.at(e, wd)), this
        }), closestPointToPoint: function (e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new yu), t.subVectors(e, this.origin);
            var i = t.dot(this.direction);
            return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin)
        }, distanceToPoint: function (e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }, distanceSqToPoint: (bd = new yu, function (e) {
            var t = bd.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (bd.copy(this.direction).multiplyScalar(t).add(this.origin), bd.distanceToSquared(e))
        }), distanceSqToSegment: (yd = new yu, _d = new yu, xd = new yu, function (e, t, i, n) {
            yd.copy(e).add(t).multiplyScalar(.5), _d.copy(t).sub(e).normalize(), xd.copy(this.origin).sub(yd);
            var r, a, o, s, l = .5 * e.distanceTo(t), h = -this.direction.dot(_d), c = xd.dot(this.direction),
                u = -xd.dot(_d), p = xd.lengthSq(), d = Math.abs(1 - h * h);
            if (0 < d) if (a = h * c - u, s = l * d, 0 <= (r = h * u - c)) if (-s <= a) if (a <= s) {
                var f = 1 / d;
                o = (r *= f) * (r + h * (a *= f) + 2 * c) + a * (h * r + a + 2 * u) + p
            } else a = l, o = -(r = Math.max(0, -(h * a + c))) * r + a * (a + 2 * u) + p; else a = -l, o = -(r = Math.max(0, -(h * a + c))) * r + a * (a + 2 * u) + p; else o = a <= -s ? -(r = Math.max(0, -(-h * l + c))) * r + (a = 0 < r ? -l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + p : a <= s ? (r = 0, (a = Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + p) : -(r = Math.max(0, -(h * l + c))) * r + (a = 0 < r ? l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + p; else a = 0 < h ? -l : l, o = -(r = Math.max(0, -(h * a + c))) * r + a * (a + 2 * u) + p;
            return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(_d).multiplyScalar(a).add(yd), o
        }), intersectSphere: (vd = new yu, function (e, t) {
            vd.subVectors(e.center, this.origin);
            var i = vd.dot(this.direction), n = vd.dot(vd) - i * i, r = e.radius * e.radius;
            if (r < n) return null;
            var a = Math.sqrt(r - n), o = i - a, s = i + a;
            return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
        }), intersectsSphere: function (e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }, distanceToPlane: function (e) {
            var t = e.normal.dot(this.direction);
            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            var i = -(this.origin.dot(e.normal) + e.constant) / t;
            return 0 <= i ? i : null
        }, intersectPlane: function (e, t) {
            var i = this.distanceToPlane(e);
            return null === i ? null : this.at(i, t)
        }, intersectsPlane: function (e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        }, intersectBox: function (e, t) {
            var i, n, r, a, o, s, l = 1 / this.direction.x, h = 1 / this.direction.y, c = 1 / this.direction.z,
                u = this.origin;
            return n = 0 <= l ? (i = (e.min.x - u.x) * l, (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, (e.min.x - u.x) * l), (a = 0 <= h ? (r = (e.min.y - u.y) * h, (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h, (e.min.y - u.y) * h)) < i || n < r ? null : ((i < r || i != i) && (i = r), (a < n || n != n) && (n = a), (s = 0 <= c ? (o = (e.min.z - u.z) * c, (e.max.z - u.z) * c) : (o = (e.max.z - u.z) * c, (e.min.z - u.z) * c)) < i || n < o ? null : ((i < o || i != i) && (i = o), (s < n || n != n) && (n = s), n < 0 ? null : this.at(0 <= i ? i : n, t)))
        }, intersectsBox: (gd = new yu, function (e) {
            return null !== this.intersectBox(e, gd)
        }), intersectTriangle: (pd = new yu, dd = new yu, fd = new yu, md = new yu, function (e, t, i, n, r) {
            dd.subVectors(t, e), fd.subVectors(i, e), md.crossVectors(dd, fd);
            var a, o = this.direction.dot(md);
            if (0 < o) {
                if (n) return null;
                a = 1
            } else {
                if (!(o < 0)) return null;
                a = -1, o = -o
            }
            pd.subVectors(this.origin, e);
            var s = a * this.direction.dot(fd.crossVectors(pd, fd));
            if (s < 0) return null;
            var l = a * this.direction.dot(dd.cross(pd));
            if (l < 0) return null;
            if (o < s + l) return null;
            var h = -a * pd.dot(md);
            return h < 0 ? null : this.at(h / o, r)
        }), applyMatrix4: function (e) {
            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
        }, equals: function (e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }), Object.assign(Hd, {
        getNormal: (Pd = new yu, function (e, t, i, n) {
            void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new yu), n.subVectors(i, t), Pd.subVectors(e, t), n.cross(Pd);
            var r = n.lengthSq();
            return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0)
        }), getBarycoord: (Ed = new yu, Ad = new yu, Md = new yu, function (e, t, i, n, r) {
            Ed.subVectors(n, t), Ad.subVectors(i, t), Md.subVectors(e, t);
            var a = Ed.dot(Ed), o = Ed.dot(Ad), s = Ed.dot(Md), l = Ad.dot(Ad), h = Ad.dot(Md), c = a * l - o * o;
            if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new yu), 0 === c) return r.set(-2, -1, -1);
            var u = 1 / c, p = (l * s - o * h) * u, d = (a * h - o * s) * u;
            return r.set(1 - p - d, d, p)
        }), containsPoint: (Sd = new yu, function (e, t, i, n) {
            return Hd.getBarycoord(e, t, i, n, Sd), 0 <= Sd.x && 0 <= Sd.y && Sd.x + Sd.y <= 1
        }), getUV: (Td = new yu, function (e, t, i, n, r, a, o, s) {
            return this.getBarycoord(e, t, i, n, Td), s.set(0, 0), s.addScaledVector(r, Td.x), s.addScaledVector(a, Td.y), s.addScaledVector(o, Td.z), s
        })
    }), Object.assign(Hd.prototype, {
        set: function (e, t, i) {
            return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
        },
        setFromPointsAndIndices: function (e, t, i, n) {
            return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (e) {
            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
        },
        getArea: (Nd = new yu, kd = new yu, function () {
            return Nd.subVectors(this.c, this.b), kd.subVectors(this.a, this.b), .5 * Nd.cross(kd).length()
        }),
        getMidpoint: function (e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new yu), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function (e) {
            return Hd.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function (e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new yu), e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function (e, t) {
            return Hd.getBarycoord(e, this.a, this.b, this.c, t)
        },
        containsPoint: function (e) {
            return Hd.containsPoint(e, this.a, this.b, this.c)
        },
        getUV: function (e, t, i, n, r) {
            return Hd.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        intersectsBox: function (e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: (Ld = new yu, Cd = new yu, Id = new yu, Rd = new yu, Od = new yu, Fd = new yu, function (e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new yu);
            var i, n, r = this.a, a = this.b, o = this.c;
            Ld.subVectors(a, r), Cd.subVectors(o, r), Rd.subVectors(e, r);
            var s = Ld.dot(Rd), l = Cd.dot(Rd);
            if (s <= 0 && l <= 0) return t.copy(r);
            Od.subVectors(e, a);
            var h = Ld.dot(Od), c = Cd.dot(Od);
            if (0 <= h && c <= h) return t.copy(a);
            var u = s * c - h * l;
            if (u <= 0 && 0 <= s && h <= 0) return i = s / (s - h), t.copy(r).addScaledVector(Ld, i);
            Fd.subVectors(e, o);
            var p = Ld.dot(Fd), d = Cd.dot(Fd);
            if (0 <= d && p <= d) return t.copy(o);
            var f = p * l - s * d;
            if (f <= 0 && 0 <= l && d <= 0) return n = l / (l - d), t.copy(r).addScaledVector(Cd, n);
            var m = h * d - p * c;
            if (m <= 0 && 0 <= c - h && 0 <= p - d) return Id.subVectors(o, a), n = (c - h) / (c - h + (p - d)), t.copy(a).addScaledVector(Id, n);
            var g = 1 / (m + f + u);
            return i = f * g, n = u * g, t.copy(r).addScaledVector(Ld, i).addScaledVector(Cd, n)
        }),
        equals: function (e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }), ((Gd.prototype = Object.create(Dd.prototype)).constructor = Gd).prototype.isMeshBasicMaterial = !0, Gd.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
    }, jd.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: jd, isMesh: !0, setDrawMode: function (e) {
            this.drawMode = e
        }, copy: function (e) {
            return Pp.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
        }, updateMorphTargets: function () {
            var e, t, i, n = this.geometry;
            if (n.isBufferGeometry) {
                var r = n.morphAttributes, a = Object.keys(r);
                if (0 < a.length) {
                    var o = r[a[0]];
                    if (void 0 !== o) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) i = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
                }
            } else {
                var s = n.morphTargets;
                if (void 0 !== s && 0 < s.length) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++) i = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e
            }
        }, raycast: function () {
            var z = new gu, B = new Bd, H = new Vu, G = new yu, j = new yu, V = new yu, X = new yu, W = new yu,
                Y = new yu, q = new mu, Q = new mu, Z = new mu, J = new yu, h = new yu;

            function K(e, t, i, n, r, a, o, s) {
                if (null === (t.side === lh ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, t.side !== hh, s))) return null;
                h.copy(s), h.applyMatrix4(e.matrixWorld);
                var l = i.ray.origin.distanceTo(h);
                return l < i.near || l > i.far ? null : {distance: l, point: h.clone(), object: e}
            }

            function $(e, t, i, n, r, a, o, s, l) {
                G.fromBufferAttribute(r, o), j.fromBufferAttribute(r, s), V.fromBufferAttribute(r, l);
                var h = K(e, t, i, n, G, j, V, J);
                if (h) {
                    a && (q.fromBufferAttribute(a, o), Q.fromBufferAttribute(a, s), Z.fromBufferAttribute(a, l), h.uv = Hd.getUV(J, G, j, V, q, Q, Z, new mu));
                    var c = new op(o, s, l);
                    Hd.getNormal(G, j, V, c.normal), h.face = c
                }
                return h
            }

            return function (e, t) {
                var i, n = this.geometry, r = this.material, a = this.matrixWorld;
                if (void 0 !== r && (null === n.boundingSphere && n.computeBoundingSphere(), H.copy(n.boundingSphere), H.applyMatrix4(a), !1 !== e.ray.intersectsSphere(H) && (z.getInverse(a), B.copy(e.ray).applyMatrix4(z), null === n.boundingBox || !1 !== B.intersectsBox(n.boundingBox)))) if (n.isBufferGeometry) {
                    var o, s, l, h, c, u, p, d, f, m = n.index, g = n.attributes.position, v = n.attributes.uv,
                        y = n.groups, _ = n.drawRange;
                    if (null !== m) if (Array.isArray(r)) for (h = 0, u = y.length; h < u; h++) for (f = r[(d = y[h]).materialIndex], c = Math.max(d.start, _.start), p = Math.min(d.start + d.count, _.start + _.count); c < p; c += 3) o = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (i = $(this, f, e, B, g, v, o, s, l)) && (i.faceIndex = Math.floor(c / 3), t.push(i)); else for (h = Math.max(0, _.start), u = Math.min(m.count, _.start + _.count); h < u; h += 3) o = m.getX(h), s = m.getX(h + 1), l = m.getX(h + 2), (i = $(this, r, e, B, g, v, o, s, l)) && (i.faceIndex = Math.floor(h / 3), t.push(i)); else if (void 0 !== g) if (Array.isArray(r)) for (h = 0, u = y.length; h < u; h++) for (f = r[(d = y[h]).materialIndex], c = Math.max(d.start, _.start), p = Math.min(d.start + d.count, _.start + _.count); c < p; c += 3) (i = $(this, f, e, B, g, v, o = c, s = c + 1, l = c + 2)) && (i.faceIndex = Math.floor(c / 3), t.push(i)); else for (h = Math.max(0, _.start), u = Math.min(g.count, _.start + _.count); h < u; h += 3) (i = $(this, r, e, B, g, v, o = h, s = h + 1, l = h + 2)) && (i.faceIndex = Math.floor(h / 3), t.push(i))
                } else if (n.isGeometry) {
                    var x, b, w, T, S = Array.isArray(r), E = n.vertices, A = n.faces, M = n.faceVertexUvs[0];
                    0 < M.length && (T = M);
                    for (var P = 0, L = A.length; P < L; P++) {
                        var C = A[P], I = S ? r[C.materialIndex] : r;
                        if (void 0 !== I) {
                            if (x = E[C.a], b = E[C.b], w = E[C.c], !0 === I.morphTargets) {
                                var R = n.morphTargets, O = this.morphTargetInfluences;
                                G.set(0, 0, 0), j.set(0, 0, 0), V.set(0, 0, 0);
                                for (var F = 0, N = R.length; F < N; F++) {
                                    var k = O[F];
                                    if (0 !== k) {
                                        var U = R[F].vertices;
                                        G.addScaledVector(X.subVectors(U[C.a], x), k), j.addScaledVector(W.subVectors(U[C.b], b), k), V.addScaledVector(Y.subVectors(U[C.c], w), k)
                                    }
                                }
                                G.add(x), j.add(b), V.add(w), x = G, b = j, w = V
                            }
                            if (i = K(this, I, e, B, x, b, w, J)) {
                                if (T && T[P]) {
                                    var D = T[P];
                                    q.copy(D[0]), Q.copy(D[1]), Z.copy(D[2]), i.uv = Hd.getUV(J, x, b, w, q, Q, Z, new mu)
                                }
                                i.face = C, i.faceIndex = P, t.push(i)
                            }
                        }
                    }
                }
            }
        }(), clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), ((tf.prototype = Object.create(Du.prototype)).constructor = tf).prototype.isCubeTexture = !0, Object.defineProperty(tf.prototype, "images", {
        get: function () {
            return this.image
        }, set: function (e) {
            this.image = e
        }
    }), ((nf.prototype = Object.create(Du.prototype)).constructor = nf).prototype.isDataTexture3D = !0;
    var rf = new Du, af = new nf, of = new tf;

    function sf() {
        this.seq = [], this.map = {}
    }

    var lf = [], hf = [], cf = new Float32Array(16), uf = new Float32Array(9), pf = new Float32Array(4);

    function df(e, t, i) {
        var n = e[0];
        if (n <= 0 || 0 < n) return e;
        var r = t * i, a = lf[r];
        if (void 0 === a && (a = new Float32Array(r), lf[r] = a), 0 !== t) {
            n.toArray(a, 0);
            for (var o = 1, s = 0; o !== t; ++o) s += i, e[o].toArray(a, s)
        }
        return a
    }

    function ff(e, t) {
        if (e.length !== t.length) return !1;
        for (var i = 0, n = e.length; i < n; i++) if (e[i] !== t[i]) return !1;
        return !0
    }

    function mf(e, t) {
        for (var i = 0, n = t.length; i < n; i++) e[i] = t[i]
    }

    function gf(e, t) {
        var i = hf[t];
        void 0 === i && (i = new Int32Array(t), hf[t] = i);
        for (var n = 0; n !== t; ++n) i[n] = e.allocTextureUnit();
        return i
    }

    function vf(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t)
    }

    function yf(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t)
    }

    function _f(e, t) {
        var i = this.cache;
        if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else {
            if (ff(i, t)) return;
            e.uniform2fv(this.addr, t), mf(i, t)
        }
    }

    function xf(e, t) {
        var i = this.cache;
        if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b); else {
            if (ff(i, t)) return;
            e.uniform3fv(this.addr, t), mf(i, t)
        }
    }

    function bf(e, t) {
        var i = this.cache;
        if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else {
            if (ff(i, t)) return;
            e.uniform4fv(this.addr, t), mf(i, t)
        }
    }

    function wf(e, t) {
        var i = this.cache, n = t.elements;
        if (void 0 === n) {
            if (ff(i, t)) return;
            e.uniformMatrix2fv(this.addr, !1, t), mf(i, t)
        } else {
            if (ff(i, n)) return;
            pf.set(n), e.uniformMatrix2fv(this.addr, !1, pf), mf(i, n)
        }
    }

    function Tf(e, t) {
        var i = this.cache, n = t.elements;
        if (void 0 === n) {
            if (ff(i, t)) return;
            e.uniformMatrix3fv(this.addr, !1, t), mf(i, t)
        } else {
            if (ff(i, n)) return;
            uf.set(n), e.uniformMatrix3fv(this.addr, !1, uf), mf(i, n)
        }
    }

    function Sf(e, t) {
        var i = this.cache, n = t.elements;
        if (void 0 === n) {
            if (ff(i, t)) return;
            e.uniformMatrix4fv(this.addr, !1, t), mf(i, t)
        } else {
            if (ff(i, n)) return;
            cf.set(n), e.uniformMatrix4fv(this.addr, !1, cf), mf(i, n)
        }
    }

    function Ef(e, t, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(t || rf, r)
    }

    function Af(e, t, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || af, r)
    }

    function Mf(e, t, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(t || of, r)
    }

    function Pf(e, t) {
        var i = this.cache;
        ff(i, t) || (e.uniform2iv(this.addr, t), mf(i, t))
    }

    function Lf(e, t) {
        var i = this.cache;
        ff(i, t) || (e.uniform3iv(this.addr, t), mf(i, t))
    }

    function Cf(e, t) {
        var i = this.cache;
        ff(i, t) || (e.uniform4iv(this.addr, t), mf(i, t))
    }

    function If(e, t) {
        var i = this.cache;
        ff(i, t) || (e.uniform1fv(this.addr, t), mf(i, t))
    }

    function Rf(e, t) {
        var i = this.cache;
        ff(i, t) || (e.uniform1iv(this.addr, t), mf(i, t))
    }

    function Of(e, t) {
        var i = this.cache, n = df(t, this.size, 2);
        ff(i, n) || (e.uniform2fv(this.addr, n), this.updateCache(n))
    }

    function Ff(e, t) {
        var i = this.cache, n = df(t, this.size, 3);
        ff(i, n) || (e.uniform3fv(this.addr, n), this.updateCache(n))
    }

    function Nf(e, t) {
        var i = this.cache, n = df(t, this.size, 4);
        ff(i, n) || (e.uniform4fv(this.addr, n), this.updateCache(n))
    }

    function kf(e, t) {
        var i = this.cache, n = df(t, this.size, 4);
        ff(i, n) || (e.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n))
    }

    function Uf(e, t) {
        var i = this.cache, n = df(t, this.size, 9);
        ff(i, n) || (e.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n))
    }

    function Df(e, t) {
        var i = this.cache, n = df(t, this.size, 16);
        ff(i, n) || (e.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n))
    }

    function zf(e, t, i) {
        var n = this.cache, r = t.length, a = gf(i, r);
        !1 === ff(n, a) && (e.uniform1iv(this.addr, a), mf(n, a));
        for (var o = 0; o !== r; ++o) i.setTexture2D(t[o] || rf, a[o])
    }

    function Bf(e, t, i) {
        var n = this.cache, r = t.length, a = gf(i, r);
        !1 === ff(n, a) && (e.uniform1iv(this.addr, a), mf(n, a));
        for (var o = 0; o !== r; ++o) i.setTextureCube(t[o] || of, a[o])
    }

    function Hf(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return vf;
                case 35664:
                    return _f;
                case 35665:
                    return xf;
                case 35666:
                    return bf;
                case 35674:
                    return wf;
                case 35675:
                    return Tf;
                case 35676:
                    return Sf;
                case 35678:
                case 36198:
                    return Ef;
                case 35679:
                    return Af;
                case 35680:
                    return Mf;
                case 5124:
                case 35670:
                    return yf;
                case 35667:
                case 35671:
                    return Pf;
                case 35668:
                case 35672:
                    return Lf;
                case 35669:
                case 35673:
                    return Cf
            }
        }(t.type)
    }

    function Gf(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function (e) {
            switch (e) {
                case 5126:
                    return If;
                case 35664:
                    return Of;
                case 35665:
                    return Ff;
                case 35666:
                    return Nf;
                case 35674:
                    return kf;
                case 35675:
                    return Uf;
                case 35676:
                    return Df;
                case 35678:
                    return zf;
                case 35680:
                    return Bf;
                case 5124:
                case 35670:
                    return Rf;
                case 35667:
                case 35671:
                    return Pf;
                case 35668:
                case 35672:
                    return Lf;
                case 35669:
                case 35673:
                    return Cf
            }
        }(t.type)
    }

    function jf(e) {
        this.id = e, sf.call(this)
    }

    Gf.prototype.updateCache = function (e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), mf(t, e)
    }, jf.prototype.setValue = function (e, t, i) {
        for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
            var o = n[r];
            o.setValue(e, t[o.id], i)
        }
    };
    var Vf = /([\w\d_]+)(\])?(\[|\.)?/g;

    function Xf(e, t) {
        e.seq.push(t), e.map[t.id] = t
    }

    function Wf(e, t, i) {
        var n = e.name, r = n.length;
        for (Vf.lastIndex = 0; ;) {
            var a = Vf.exec(n), o = Vf.lastIndex, s = a[1], l = "]" === a[2], h = a[3];
            if (l && (s |= 0), void 0 === h || "[" === h && o + 2 === r) {
                Xf(i, void 0 === h ? new Hf(s, e, t) : new Gf(s, e, t));
                break
            }
            var c = i.map[s];
            void 0 === c && Xf(i, c = new jf(s)), i = c
        }
    }

    function Yf(e, t, i) {
        sf.call(this), this.renderer = i;
        for (var n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
            var a = e.getActiveUniform(t, r);
            Wf(a, e.getUniformLocation(t, a.name), this)
        }
    }

    function qf(e, t, i) {
        var n = e.createShader(t);
        return e.shaderSource(n, i), e.compileShader(n), !1 === e.getShaderParameter(n, e.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", t === e.VERTEX_SHADER ? "vertex" : "fragment", e.getShaderInfoLog(n), function (e) {
            for (var t = e.split("\n"), i = 0; i < t.length; i++) t[i] = i + 1 + ": " + t[i];
            return t.join("\n")
        }(i)), n
    }

    Yf.prototype.setValue = function (e, t, i) {
        var n = this.map[t];
        void 0 !== n && n.setValue(e, i, this.renderer)
    }, Yf.prototype.setOptional = function (e, t, i) {
        var n = t[i];
        void 0 !== n && this.setValue(e, i, n)
    }, Yf.upload = function (e, t, i, n) {
        for (var r = 0, a = t.length; r !== a; ++r) {
            var o = t[r], s = i[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, n)
        }
    }, Yf.seqWithValue = function (e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var a = e[n];
            a.id in t && i.push(a)
        }
        return i
    };
    var Qf = 0;

    function Zf(e) {
        switch (e) {
            case nu:
                return ["Linear", "( value )"];
            case ru:
                return ["sRGB", "( value )"];
            case ou:
                return ["RGBE", "( value )"];
            case su:
                return ["RGBM", "( value, 7.0 )"];
            case lu:
                return ["RGBM", "( value, 16.0 )"];
            case hu:
                return ["RGBD", "( value, 256.0 )"];
            case au:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw new Error("unsupported encoding: " + e)
        }
    }

    function Jf(e, t) {
        var i = Zf(t);
        return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }"
    }

    function Kf(e) {
        return "" !== e
    }

    function $f(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }

    function em(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }

    function tm(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (e, t) {
            var i = Zu[t];
            if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">");
            return tm(i)
        })
    }

    function im(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (e, t, i, n) {
            for (var r = "", a = parseInt(t); a < parseInt(i); a++) r += n.replace(/\[ i \]/g, "[ " + a + " ]");
            return r
        })
    }

    function nm(e, t, i, n, r, a, o) {
        var s = e.context, l = n.defines, h = r.vertexShader, c = r.fragmentShader, u = "SHADOWMAP_TYPE_BASIC";
        a.shadowMapType === ah ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === oh && (u = "SHADOWMAP_TYPE_PCF_SOFT");
        var p = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", f = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap) {
            switch (n.envMap.mapping) {
                case Qh:
                case Zh:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                case ec:
                case tc:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case Jh:
                case Kh:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                case $h:
                    p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case Zh:
                case Kh:
                    d = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case Hh:
                    f = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case Gh:
                    f = "ENVMAP_BLENDING_MIX";
                    break;
                case jh:
                    f = "ENVMAP_BLENDING_ADD"
            }
        }
        var m, g, v, y, _, x, b, w, T = 0 < e.gammaFactor ? e.gammaFactor : 1,
            S = o.isWebGL2 ? "" : (m = n.extensions, g = a, v = t, [(m = m || {}).derivatives || g.envMapCubeUV || g.bumpMap || g.normalMap && !g.objectSpaceNormalMap || g.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (m.fragDepth || g.logarithmicDepthBuffer) && v.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", m.drawBuffers && v.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (m.shaderTextureLOD || g.envMap) && v.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Kf).join("\n")),
            E = function (e) {
                var t = [];
                for (var i in e) {
                    var n = e[i];
                    !1 !== n && t.push("#define " + i + " " + n)
                }
                return t.join("\n")
            }(l), A = s.createProgram();
        if (n.isRawShaderMaterial ? (0 < (y = [E].filter(Kf).join("\n")).length && (y += "\n"), 0 < (_ = [S, E].filter(Kf).join("\n")).length && (_ += "\n")) : (y = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, E, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + T, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Kf).join("\n"), _ = [S, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, E, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + T, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== Vh ? "#define TONE_MAPPING" : "", a.toneMapping !== Vh ? Zu.tonemapping_pars_fragment : "", a.toneMapping !== Vh ? function (e, t) {
            var i;
            switch (t) {
                case Xh:
                    i = "Linear";
                    break;
                case Wh:
                    i = "Reinhard";
                    break;
                case Yh:
                    i = "Uncharted2";
                    break;
                case qh:
                    i = "OptimizedCineon";
                    break;
                default:
                    throw new Error("unsupported toneMapping: " + t)
            }
            return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
        }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? Zu.encodings_pars_fragment : "", a.mapEncoding ? Jf("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? Jf("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? Jf("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? Jf("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (x = "linearToOutputTexel", b = a.outputEncoding, w = Zf(b), "vec4 " + x + "( vec4 value ) { return LinearTo" + w[0] + w[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Kf).join("\n")), h = em(h = $f(h = tm(h), a), a), c = em(c = $f(c = tm(c), a), a), h = im(h), c = im(c), o.isWebGL2 && !n.isRawShaderMaterial) {
            var M = !1, P = /^\s*#version\s+300\s+es\s*\n/;
            n.isShaderMaterial && null !== h.match(P) && null !== c.match(P) && (M = !0, h = h.replace(P, ""), c = c.replace(P, "")), y = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y, _ = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + _
        }
        var L = y + h, C = _ + c, I = qf(s, s.VERTEX_SHADER, L), R = qf(s, s.FRAGMENT_SHADER, C);
        s.attachShader(A, I), s.attachShader(A, R), void 0 !== n.index0AttributeName ? s.bindAttribLocation(A, 0, n.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(A, 0, "position"), s.linkProgram(A);
        var O, F, N = s.getProgramInfoLog(A).trim(), k = s.getShaderInfoLog(I).trim(), U = s.getShaderInfoLog(R).trim(),
            D = !0, z = !0;
        return !1 === s.getProgramParameter(A, s.LINK_STATUS) ? (D = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "gl.VALIDATE_STATUS", s.getProgramParameter(A, s.VALIDATE_STATUS), "gl.getProgramInfoLog", N, k, U)) : "" !== N ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", N) : "" !== k && "" !== U || (z = !1), z && (this.diagnostics = {
            runnable: D,
            material: n,
            programLog: N,
            vertexShader: {log: k, prefix: y},
            fragmentShader: {log: U, prefix: _}
        }), s.deleteShader(I), s.deleteShader(R), this.getUniforms = function () {
            return void 0 === O && (O = new Yf(s, A, e)), O
        }, this.getAttributes = function () {
            return void 0 === F && (F = function (e, t) {
                for (var i = {}, n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), r = 0; r < n; r++) {
                    var a = e.getActiveAttrib(t, r).name;
                    i[a] = e.getAttribLocation(t, a)
                }
                return i
            }(s, A)), F
        }, this.destroy = function () {
            s.deleteProgram(A), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            }, attributes: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = r.name, this.id = Qf++, this.code = i, this.usedTimes = 1, this.program = A, this.vertexShader = I, this.fragmentShader = R, this
    }

    function rm(u, l, p) {
        var h = [], d = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

        function f(e, t) {
            var i;
            return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding) : i = nu, i === nu && t && (i = au), i
        }

        this.getParameters = function (e, t, i, n, r, a, o) {
            var s = d[e.type], l = o.isSkinnedMesh ? function (e) {
                var t = e.skeleton.bones;
                if (p.floatVertexTextures) return 1024;
                var i = p.maxVertexUniforms, n = Math.floor((i - 20) / 4), r = Math.min(n, t.length);
                return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r
            }(o) : 0, h = p.precision;
            null !== e.precision && (h = p.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", h, "instead.");
            var c = u.getRenderTarget();
            return {
                shaderID: s,
                precision: h,
                supportsVertexTextures: p.vertexTextures,
                outputEncoding: f(c ? c.texture : null, u.gammaOutput),
                map: !!e.map,
                mapEncoding: f(e.map, u.gammaInput),
                matcap: !!e.matcap,
                matcapEncoding: f(e.matcap, u.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: f(e.envMap, u.gammaInput),
                envMapCubeUV: !!e.envMap && (e.envMap.mapping === ec || e.envMap.mapping === tc),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: f(e.emissiveMap, u.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: e.normalMapType === du,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!n,
                useFog: e.fog,
                fogExp: n && n.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: p.logarithmicDepthBuffer,
                skinning: e.skinning && 0 < l,
                maxBones: l,
                useVertexTexture: p.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: u.maxMorphTargets,
                maxMorphNormals: u.maxMorphNormals,
                numDirLights: t.directional.length,
                numPointLights: t.point.length,
                numSpotLights: t.spot.length,
                numRectAreaLights: t.rectArea.length,
                numHemiLights: t.hemi.length,
                numClippingPlanes: r,
                numClipIntersection: a,
                dithering: e.dithering,
                shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
                shadowMapType: u.shadowMap.type,
                toneMapping: u.toneMapping,
                physicallyCorrectLights: u.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: e.side === hh,
                flipSided: e.side === lh,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }, this.getProgramCode = function (e, t) {
            var i = [];
            if (t.shaderID ? i.push(t.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines) for (var n in e.defines) i.push(n), i.push(e.defines[n]);
            for (var r = 0; r < a.length; r++) i.push(t[a[r]]);
            return i.push(e.onBeforeCompile.toString()), i.push(u.gammaOutput), i.join()
        }, this.acquireProgram = function (e, t, i, n) {
            for (var r, a = 0, o = h.length; a < o; a++) {
                var s = h[a];
                if (s.code === n) {
                    ++(r = s).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new nm(u, l, n, e, t, i, p), h.push(r)), r
        }, this.releaseProgram = function (e) {
            if (0 == --e.usedTimes) {
                var t = h.indexOf(e);
                h[t] = h[h.length - 1], h.pop(), e.destroy()
            }
        }, this.programs = h
    }

    function am() {
        var n = new WeakMap;
        return {
            get: function (e) {
                var t = n.get(e);
                return void 0 === t && (t = {}, n.set(e, t)), t
            }, remove: function (e) {
                n.delete(e)
            }, update: function (e, t, i) {
                n.get(e)[t] = i
            }, dispose: function () {
                n = new WeakMap
            }
        }
    }

    function om(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }

    function sm(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }

    function lm() {
        var o = [], s = 0, l = [], h = [];
        return {
            opaque: l, transparent: h, init: function () {
                s = 0, l.length = 0, h.length = 0
            }, push: function (e, t, i, n, r) {
                var a = o[s];
                void 0 === a ? (a = {
                    id: e.id,
                    object: e,
                    geometry: t,
                    material: i,
                    program: i.program,
                    renderOrder: e.renderOrder,
                    z: n,
                    group: r
                }, o[s] = a) : (a.id = e.id, a.object = e, a.geometry = t, a.material = i, a.program = i.program, a.renderOrder = e.renderOrder, a.z = n, a.group = r), (!0 === i.transparent ? h : l).push(a), s++
            }, sort: function () {
                1 < l.length && l.sort(om), 1 < h.length && h.sort(sm)
            }
        }
    }

    function hm() {
        var r = {};
        return {
            get: function (e, t) {
                var i = e.id + "," + t.id, n = r[i];
                return void 0 === n && (n = new lm, r[i] = n), n
            }, dispose: function () {
                r = {}
            }
        }
    }

    function cm() {
        var i = {};
        return {
            get: function (e) {
                if (void 0 !== i[e.id]) return i[e.id];
                var t;
                switch (e.type) {
                    case"DirectionalLight":
                        t = {
                            direction: new yu,
                            color: new $u,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new mu
                        };
                        break;
                    case"SpotLight":
                        t = {
                            position: new yu,
                            direction: new yu,
                            color: new $u,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new mu
                        };
                        break;
                    case"PointLight":
                        t = {
                            position: new yu,
                            color: new $u,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new mu,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case"HemisphereLight":
                        t = {direction: new yu, skyColor: new $u, groundColor: new $u};
                        break;
                    case"RectAreaLight":
                        t = {color: new $u, position: new yu, halfWidth: new yu, halfHeight: new yu}
                }
                return i[e.id] = t
            }
        }
    }

    var um, pm, dm, fm, mm, gm, vm, ym, _m, xm, bm, wm, Tm, Sm, Em, Am, Mm = 0;

    function Pm() {
        var b = new cm, w = {
            id: Mm++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, T = new yu, S = new gu, E = new gu;
        return {
            setup: function (e, t, i) {
                for (var n = 0, r = 0, a = 0, o = 0, s = 0, l = 0, h = 0, c = 0, u = i.matrixWorldInverse, p = 0, d = e.length; p < d; p++) {
                    var f = e[p], m = f.color, g = f.intensity, v = f.distance,
                        y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
                    if (f.isAmbientLight) n += m.r * g, r += m.g * g, a += m.b * g; else if (f.isDirectionalLight) {
                        if ((x = b.get(f)).color.copy(f.color).multiplyScalar(f.intensity), x.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), x.direction.sub(T), x.direction.transformDirection(u), x.shadow = f.castShadow, f.castShadow) {
                            var _ = f.shadow;
                            x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize
                        }
                        w.directionalShadowMap[o] = y, w.directionalShadowMatrix[o] = f.shadow.matrix, w.directional[o] = x, o++
                    } else if (f.isSpotLight) (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(u), x.color.copy(m).multiplyScalar(g), x.distance = v, x.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), x.direction.sub(T), x.direction.transformDirection(u), x.coneCos = Math.cos(f.angle), x.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)), x.decay = f.decay, x.shadow = f.castShadow, f.castShadow && (_ = f.shadow, x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize), w.spotShadowMap[l] = y, w.spotShadowMatrix[l] = f.shadow.matrix, w.spot[l] = x, l++; else if (f.isRectAreaLight) (x = b.get(f)).color.copy(m).multiplyScalar(g), x.position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(u), E.identity(), S.copy(f.matrixWorld), S.premultiply(u), E.extractRotation(S), x.halfWidth.set(.5 * f.width, 0, 0), x.halfHeight.set(0, .5 * f.height, 0), x.halfWidth.applyMatrix4(E), x.halfHeight.applyMatrix4(E), w.rectArea[h] = x, h++; else if (f.isPointLight) (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld), x.position.applyMatrix4(u), x.color.copy(f.color).multiplyScalar(f.intensity), x.distance = f.distance, x.decay = f.decay, x.shadow = f.castShadow, f.castShadow && (_ = f.shadow, x.shadowBias = _.bias, x.shadowRadius = _.radius, x.shadowMapSize = _.mapSize, x.shadowCameraNear = _.camera.near, x.shadowCameraFar = _.camera.far), w.pointShadowMap[s] = y, w.pointShadowMatrix[s] = f.shadow.matrix, w.point[s] = x, s++; else if (f.isHemisphereLight) {
                        var x;
                        (x = b.get(f)).direction.setFromMatrixPosition(f.matrixWorld), x.direction.transformDirection(u), x.direction.normalize(), x.skyColor.copy(f.color).multiplyScalar(g), x.groundColor.copy(f.groundColor).multiplyScalar(g), w.hemi[c] = x, c++
                    }
                }
                w.ambient[0] = n, w.ambient[1] = r, w.ambient[2] = a, w.directional.length = o, w.spot.length = l, w.rectArea.length = h, w.point.length = s, w.hemi.length = c, w.hash.stateID = w.id, w.hash.directionalLength = o, w.hash.pointLength = s, w.hash.spotLength = l, w.hash.rectAreaLength = h, w.hash.hemiLength = c, w.hash.shadowsLength = t.length
            }, state: w
        }
    }

    function Lm() {
        var t = new Pm, i = [], n = [];
        return {
            init: function () {
                i.length = 0, n.length = 0
            }, state: {lightsArray: i, shadowsArray: n, lights: t}, setupLights: function (e) {
                t.setup(i, n, e)
            }, pushLight: function (e) {
                i.push(e)
            }, pushShadow: function (e) {
                n.push(e)
            }
        }
    }

    function Cm() {
        var n = {};
        return {
            get: function (e, t) {
                var i;
                return void 0 === n[e.id] ? (i = new Lm, n[e.id] = {}, n[e.id][t.id] = i) : void 0 === n[e.id][t.id] ? (i = new Lm, n[e.id][t.id] = i) : i = n[e.id][t.id], i
            }, dispose: function () {
                n = {}
            }
        }
    }

    function Im(e) {
        Dd.call(this), this.type = "MeshDepthMaterial", this.depthPacking = cu, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
    }

    function Rm(e) {
        Dd.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new yu, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e)
    }

    function Om(_, m, e) {
        for (var x = new Wu, b = new gu, w = new mu, T = new mu(e, e), S = new yu, E = new yu, v = 1, y = 2, t = 1 + (v | y), A = new Array(t), M = new Array(t), P = {}, L = {
            0: lh, 1: sh, 2: hh
        }, C = [new yu(1, 0, 0), new yu(-1, 0, 0), new yu(0, 0, 1), new yu(0, 0, -1), new yu(0, 1, 0), new yu(0, -1, 0)], I = [new yu(0, 1, 0), new yu(0, 1, 0), new yu(0, 1, 0), new yu(0, 1, 0), new yu(0, 0, 1), new yu(0, 0, -1)], R = [new zu, new zu, new zu, new zu, new zu, new zu], i = 0; i !== t; ++i) {
            var n = 0 != (i & v), r = 0 != (i & y), a = new Im({depthPacking: uu, morphTargets: n, skinning: r});
            A[i] = a;
            var o = new Rm({morphTargets: n, skinning: r});
            M[i] = o
        }
        var O = this;

        function g(e, t, i, n, r, a) {
            var o = e.geometry, s = null, l = A, h = e.customDepthMaterial;
            if (i && (l = M, h = e.customDistanceMaterial), h) s = h; else {
                var c = !1;
                t.morphTargets && (o && o.isBufferGeometry ? c = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o.isGeometry && (c = o.morphTargets && 0 < o.morphTargets.length)), e.isSkinnedMesh && !1 === t.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                var u = e.isSkinnedMesh && t.skinning, p = 0;
                c && (p |= v), u && (p |= y), s = l[p]
            }
            if (_.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) {
                var d = s.uuid, f = t.uuid, m = P[d];
                void 0 === m && (m = {}, P[d] = m);
                var g = m[f];
                void 0 === g && (g = s.clone(), m[f] = g), s = g
            }
            return s.visible = t.visible, s.wireframe = t.wireframe, s.side = null != t.shadowSide ? t.shadowSide : L[t.side], s.clipShadows = t.clipShadows, s.clippingPlanes = t.clippingPlanes, s.clipIntersection = t.clipIntersection, s.wireframeLinewidth = t.wireframeLinewidth, s.linewidth = t.linewidth, i && s.isMeshDistanceMaterial && (s.referencePosition.copy(n), s.nearDistance = r, s.farDistance = a), s
        }

        function F(e, t, i, n) {
            if (!1 !== e.visible) {
                if (e.layers.test(t.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || x.intersectsObject(e))) {
                    e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld);
                    var r = m.update(e), a = e.material;
                    if (Array.isArray(a)) for (var o = r.groups, s = 0, l = o.length; s < l; s++) {
                        var h = o[s], c = a[h.materialIndex];
                        if (c && c.visible) {
                            var u = g(e, c, n, E, i.near, i.far);
                            _.renderBufferDirect(i, null, r, u, e, h)
                        }
                    } else if (a.visible) {
                        u = g(e, a, n, E, i.near, i.far);
                        _.renderBufferDirect(i, null, r, u, e, null)
                    }
                }
                for (var p = e.children, d = 0, f = p.length; d < f; d++) F(p[d], t, i, n)
            }
        }

        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ah, this.render = function (e, t, i) {
            if (!1 !== O.enabled && (!1 !== O.autoUpdate || !1 !== O.needsUpdate) && 0 !== e.length) {
                var n, r = _.context, a = _.state;
                a.disable(r.BLEND), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
                for (var o = 0, s = e.length; o < s; o++) {
                    var l = e[o], h = l.shadow, c = l && l.isPointLight;
                    if (void 0 !== h) {
                        var u = h.camera;
                        if (w.copy(h.mapSize), w.min(T), c) {
                            var p = w.x, d = w.y;
                            R[0].set(2 * p, d, p, d), R[1].set(0, d, p, d), R[2].set(3 * p, d, p, d), R[3].set(p, d, p, d), R[4].set(3 * p, 0, p, d), R[5].set(p, 0, p, d), w.x *= 4, w.y *= 2
                        }
                        if (null === h.map) {
                            var f = {minFilter: ac, magFilter: ac, format: Ec};
                            h.map = new Bu(w.x, w.y, f), h.map.texture.name = l.name + ".shadowMap", u.updateProjectionMatrix()
                        }
                        h.isSpotLightShadow && h.update(l);
                        var m = h.map, g = h.matrix;
                        E.setFromMatrixPosition(l.matrixWorld), u.position.copy(E), c ? (n = 6, g.makeTranslation(-E.x, -E.y, -E.z)) : (n = 1, S.setFromMatrixPosition(l.target.matrixWorld), u.lookAt(S), u.updateMatrixWorld(), g.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), g.multiply(u.projectionMatrix), g.multiply(u.matrixWorldInverse)), _.setRenderTarget(m), _.clear();
                        for (var v = 0; v < n; v++) {
                            if (c) {
                                S.copy(u.position), S.add(C[v]), u.up.copy(I[v]), u.lookAt(S), u.updateMatrixWorld();
                                var y = R[v];
                                a.viewport(y)
                            }
                            b.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), x.setFromMatrix(b), F(t, i, u, c)
                        }
                    } else console.warn("THREE.WebGLShadowMap:", l, "has no shadow.")
                }
                O.needsUpdate = !1
            }
        }
    }

    function Fm(c, i, l, n) {
        var r = new function () {
                var t = !1, a = new zu, i = null, o = new zu(0, 0, 0, 0);
                return {
                    setMask: function (e) {
                        i === e || t || (c.colorMask(e, e, e, e), i = e)
                    }, setLocked: function (e) {
                        t = e
                    }, setClear: function (e, t, i, n, r) {
                        !0 === r && (e *= n, t *= n, i *= n), a.set(e, t, i, n), !1 === o.equals(a) && (c.clearColor(e, t, i, n), o.copy(a))
                    }, reset: function () {
                        t = !1, i = null, o.set(-1, 0, 0, 0)
                    }
                }
            }, a = new function () {
                var t = !1, i = null, n = null, r = null;
                return {
                    setTest: function (e) {
                        e ? z(c.DEPTH_TEST) : B(c.DEPTH_TEST)
                    }, setMask: function (e) {
                        i === e || t || (c.depthMask(e), i = e)
                    }, setFunc: function (e) {
                        if (n !== e) {
                            if (e) switch (e) {
                                case Oh:
                                    c.depthFunc(c.NEVER);
                                    break;
                                case Fh:
                                    c.depthFunc(c.ALWAYS);
                                    break;
                                case Nh:
                                    c.depthFunc(c.LESS);
                                    break;
                                case kh:
                                    c.depthFunc(c.LEQUAL);
                                    break;
                                case Uh:
                                    c.depthFunc(c.EQUAL);
                                    break;
                                case Dh:
                                    c.depthFunc(c.GEQUAL);
                                    break;
                                case zh:
                                    c.depthFunc(c.GREATER);
                                    break;
                                case Bh:
                                    c.depthFunc(c.NOTEQUAL);
                                    break;
                                default:
                                    c.depthFunc(c.LEQUAL)
                            } else c.depthFunc(c.LEQUAL);
                            n = e
                        }
                    }, setLocked: function (e) {
                        t = e
                    }, setClear: function (e) {
                        r !== e && (c.clearDepth(e), r = e)
                    }, reset: function () {
                        t = !1, r = n = i = null
                    }
                }
            }, t = new function () {
                var t = !1, i = null, n = null, r = null, a = null, o = null, s = null, l = null, h = null;
                return {
                    setTest: function (e) {
                        e ? z(c.STENCIL_TEST) : B(c.STENCIL_TEST)
                    }, setMask: function (e) {
                        i === e || t || (c.stencilMask(e), i = e)
                    }, setFunc: function (e, t, i) {
                        n === e && r === t && a === i || (c.stencilFunc(e, t, i), n = e, r = t, a = i)
                    }, setOp: function (e, t, i) {
                        o === e && s === t && l === i || (c.stencilOp(e, t, i), o = e, s = t, l = i)
                    }, setLocked: function (e) {
                        t = e
                    }, setClear: function (e) {
                        h !== e && (c.clearStencil(e), h = e)
                    }, reset: function () {
                        t = !1, h = l = s = o = a = r = n = i = null
                    }
                }
            }, e = c.getParameter(c.MAX_VERTEX_ATTRIBS), o = new Uint8Array(e), s = new Uint8Array(e),
            h = new Uint8Array(e), u = {}, p = null, d = null, f = null, m = null, g = null, v = null, y = null,
            _ = null, x = null, b = null, w = !1, T = null, S = null, E = null, A = null, M = null,
            P = c.getParameter(c.MAX_COMBINED_TEXTURE_IMAGE_UNITS), L = !1, C = 0, I = c.getParameter(c.VERSION);
        -1 !== I.indexOf("WebGL") ? (C = parseFloat(/^WebGL\ ([0-9])/.exec(I)[1]), L = 1 <= C) : -1 !== I.indexOf("OpenGL ES") && (C = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(I)[1]), L = 2 <= C);
        var R = null, O = {}, F = new zu, N = new zu;

        function k(e, t, i) {
            var n = new Uint8Array(4), r = c.createTexture();
            c.bindTexture(e, r), c.texParameteri(e, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(e, c.TEXTURE_MAG_FILTER, c.NEAREST);
            for (var a = 0; a < i; a++) c.texImage2D(t + a, 0, c.RGBA, 1, 1, 0, c.RGBA, c.UNSIGNED_BYTE, n);
            return r
        }

        var U = {};

        function D(e, t) {
            (o[e] = 1, 0 === s[e] && (c.enableVertexAttribArray(e), s[e] = 1), h[e] !== t) && ((n.isWebGL2 ? c : i.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), h[e] = t)
        }

        function z(e) {
            !0 !== u[e] && (c.enable(e), u[e] = !0)
        }

        function B(e) {
            !1 !== u[e] && (c.disable(e), u[e] = !1)
        }

        function H(e, t, i, n, r, a, o, s) {
            if (e !== uh) {
                if (f || (z(c.BLEND), f = !0), e === gh) r = r || t, a = a || i, o = o || n, t === g && r === _ || (c.blendEquationSeparate(l.convert(t), l.convert(r)), g = t, _ = r), i === v && n === y && a === x && o === b || (c.blendFuncSeparate(l.convert(i), l.convert(n), l.convert(a), l.convert(o)), v = i, y = n, x = a, b = o), m = e, w = null; else if (e !== m || s !== w) {
                    if (g === vh && _ === vh || (c.blendEquation(c.FUNC_ADD), _ = g = vh), s) switch (e) {
                        case ph:
                            c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
                            break;
                        case dh:
                            c.blendFunc(c.ONE, c.ONE);
                            break;
                        case fh:
                            c.blendFuncSeparate(c.ZERO, c.ZERO, c.ONE_MINUS_SRC_COLOR, c.ONE_MINUS_SRC_ALPHA);
                            break;
                        case mh:
                            c.blendFuncSeparate(c.ZERO, c.SRC_COLOR, c.ZERO, c.SRC_ALPHA);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case ph:
                            c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
                            break;
                        case dh:
                            c.blendFunc(c.SRC_ALPHA, c.ONE);
                            break;
                        case fh:
                            c.blendFunc(c.ZERO, c.ONE_MINUS_SRC_COLOR);
                            break;
                        case mh:
                            c.blendFunc(c.ZERO, c.SRC_COLOR);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    b = x = y = v = null, m = e, w = s
                }
            } else f && (B(c.BLEND), f = !1)
        }

        function G(e) {
            T !== e && (e ? c.frontFace(c.CW) : c.frontFace(c.CCW), T = e)
        }

        function j(e) {
            e !== ih ? (z(c.CULL_FACE), e !== S && (e === nh ? c.cullFace(c.BACK) : e === rh ? c.cullFace(c.FRONT) : c.cullFace(c.FRONT_AND_BACK))) : B(c.CULL_FACE), S = e
        }

        function V(e, t, i) {
            e ? (z(c.POLYGON_OFFSET_FILL), A === t && M === i || (c.polygonOffset(t, i), A = t, M = i)) : B(c.POLYGON_OFFSET_FILL)
        }

        function X(e) {
            void 0 === e && (e = c.TEXTURE0 + P - 1), R !== e && (c.activeTexture(e), R = e)
        }

        return U[c.TEXTURE_2D] = k(c.TEXTURE_2D, c.TEXTURE_2D, 1), U[c.TEXTURE_CUBE_MAP] = k(c.TEXTURE_CUBE_MAP, c.TEXTURE_CUBE_MAP_POSITIVE_X, 6), r.setClear(0, 0, 0, 1), a.setClear(1), t.setClear(0), z(c.DEPTH_TEST), a.setFunc(kh), G(!1), j(nh), z(c.CULL_FACE), H(uh), {
            buffers: {color: r, depth: a, stencil: t}, initAttributes: function () {
                for (var e = 0, t = o.length; e < t; e++) o[e] = 0
            }, enableAttribute: function (e) {
                D(e, 0)
            }, enableAttributeAndDivisor: D, disableUnusedAttributes: function () {
                for (var e = 0, t = s.length; e !== t; ++e) s[e] !== o[e] && (c.disableVertexAttribArray(e), s[e] = 0)
            }, enable: z, disable: B, getCompressedTextureFormats: function () {
                if (null === p && (p = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get("WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") || i.get("WEBGL_compressed_texture_astc"))) for (var e = c.getParameter(c.COMPRESSED_TEXTURE_FORMATS), t = 0; t < e.length; t++) p.push(e[t]);
                return p
            }, useProgram: function (e) {
                return d !== e && (c.useProgram(e), d = e, !0)
            }, setBlending: H, setMaterial: function (e, t) {
                e.side === hh ? B(c.CULL_FACE) : z(c.CULL_FACE);
                var i = e.side === lh;
                t && (i = !i), G(i), e.blending === ph && !1 === e.transparent ? H(uh) : H(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite), V(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            }, setFlipSided: G, setCullFace: j, setLineWidth: function (e) {
                e !== E && (L && c.lineWidth(e), E = e)
            }, setPolygonOffset: V, setScissorTest: function (e) {
                e ? z(c.SCISSOR_TEST) : B(c.SCISSOR_TEST)
            }, activeTexture: X, bindTexture: function (e, t) {
                null === R && X();
                var i = O[R];
                void 0 === i && (i = {
                    type: void 0, texture: void 0
                }, O[R] = i), i.type === e && i.texture === t || (c.bindTexture(e, t || U[e]), i.type = e, i.texture = t)
            }, compressedTexImage2D: function () {
                try {
                    c.compressedTexImage2D.apply(c, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, texImage2D: function () {
                try {
                    c.texImage2D.apply(c, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, texImage3D: function () {
                try {
                    c.texImage3D.apply(c, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            }, scissor: function (e) {
                !1 === F.equals(e) && (c.scissor(e.x, e.y, e.z, e.w), F.copy(e))
            }, viewport: function (e) {
                !1 === N.equals(e) && (c.viewport(e.x, e.y, e.z, e.w), N.copy(e))
            }, reset: function () {
                for (var e = 0; e < s.length; e++) 1 === s[e] && (c.disableVertexAttribArray(e), s[e] = 0);
                u = {}, O = {}, S = T = m = d = R = p = null, r.reset(), a.reset(), t.reset()
            }
        }
    }

    function Nm(g, r, v, y, _, x, b) {
        var m, s = {};

        function w(e, t) {
            if (e.width > t || e.height > t) {
                if ("data" in e) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + e.width + "x" + e.height + ").");
                var i = t / Math.max(e.width, e.height),
                    n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                return n.width = Math.floor(e.width * i), n.height = Math.floor(e.height * i), n.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, n.width, n.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + n.width + "x" + n.height), n
            }
            return e
        }

        function T(e) {
            return fu.isPowerOfTwo(e.width) && fu.isPowerOfTwo(e.height)
        }

        function S(e, t) {
            return e.generateMipmaps && t && e.minFilter !== ac && e.minFilter !== lc
        }

        function E(e, t, i, n) {
            g.generateMipmap(e), y.get(t).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
        }

        function A(e, t) {
            if (!_.isWebGL2) return e;
            if (e === g.RED) {
                if (t === g.FLOAT) return g.R32F;
                if (t === g.HALF_FLOAT) return g.R16F;
                if (t === g.UNSIGNED_BYTE) return g.R8
            }
            if (e === g.RGB) {
                if (t === g.FLOAT) return g.RGB32F;
                if (t === g.HALF_FLOAT) return g.RGB16F;
                if (t === g.UNSIGNED_BYTE) return g.RGB8
            }
            if (e === g.RGBA) {
                if (t === g.FLOAT) return g.RGBA32F;
                if (t === g.HALF_FLOAT) return g.RGBA16F;
                if (t === g.UNSIGNED_BYTE) return g.RGBA8
            }
            return e
        }

        function a(e) {
            return e === ac || e === oc || e === sc ? g.NEAREST : g.LINEAR
        }

        function M(e) {
            var t = e.target;
            t.removeEventListener("dispose", M), function (e) {
                var t = y.get(e);
                if (e.image && t.__image__webglTextureCube) g.deleteTexture(t.__image__webglTextureCube); else {
                    if (void 0 === t.__webglInit) return;
                    g.deleteTexture(t.__webglTexture)
                }
                y.remove(e)
            }(t), t.isVideoTexture && delete s[t.id], b.memory.textures--
        }

        function o(e) {
            var t = e.target;
            t.removeEventListener("dispose", o), function (e) {
                var t = y.get(e), i = y.get(e.texture);
                if (!e) return;
                void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLRenderTargetCube) for (var n = 0; n < 6; n++) g.deleteFramebuffer(t.__webglFramebuffer[n]), t.__webglDepthbuffer && g.deleteRenderbuffer(t.__webglDepthbuffer[n]); else g.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && g.deleteRenderbuffer(t.__webglDepthbuffer);
                y.remove(e.texture), y.remove(e)
            }(t), b.memory.textures--
        }

        function l(e, t) {
            var i, n, r, a = y.get(e);
            if (e.isVideoTexture && (n = (i = e).id, r = b.render.frame, s[n] !== r && (s[n] = r, i.update())), 0 < e.version && a.__version !== e.version) {
                var o = e.image;
                if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                    if (!1 !== o.complete) return void h(a, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            v.activeTexture(g.TEXTURE0 + t), v.bindTexture(g.TEXTURE_2D, a.__webglTexture)
        }

        function P(e, t, i) {
            var n;
            if (i ? (g.texParameteri(e, g.TEXTURE_WRAP_S, x.convert(t.wrapS)), g.texParameteri(e, g.TEXTURE_WRAP_T, x.convert(t.wrapT)), g.texParameteri(e, g.TEXTURE_MAG_FILTER, x.convert(t.magFilter)), g.texParameteri(e, g.TEXTURE_MIN_FILTER, x.convert(t.minFilter))) : (g.texParameteri(e, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(e, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), t.wrapS === nc && t.wrapT === nc || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), g.texParameteri(e, g.TEXTURE_MAG_FILTER, a(t.magFilter)), g.texParameteri(e, g.TEXTURE_MIN_FILTER, a(t.minFilter)), t.minFilter !== ac && t.minFilter !== lc && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), n = r.get("EXT_texture_filter_anisotropic")) {
                if (t.type === vc && null === r.get("OES_texture_float_linear")) return;
                if (t.type === yc && null === (_.isWebGL2 || r.get("OES_texture_half_float_linear"))) return;
                (1 < t.anisotropy || y.get(t).__currentAnisotropy) && (g.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, _.getMaxAnisotropy())), y.get(t).__currentAnisotropy = t.anisotropy)
            }
        }

        function h(e, t, i) {
            var n;
            n = t.isDataTexture3D ? g.TEXTURE_3D : g.TEXTURE_2D, void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", M), e.__webglTexture = g.createTexture(), b.memory.textures++), v.activeTexture(g.TEXTURE0 + i), v.bindTexture(n, e.__webglTexture), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, t.flipY), g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), g.pixelStorei(g.UNPACK_ALIGNMENT, t.unpackAlignment);
            var r, a, o = w(t.image, _.maxTextureSize);
            a = t, _.isWebGL2 || a.wrapS === nc && a.wrapT === nc && (a.minFilter === ac || a.minFilter === lc) || !1 !== T(o) || (o = (r = o) instanceof HTMLImageElement || r instanceof HTMLCanvasElement || r instanceof ImageBitmap ? (void 0 === m && (m = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), m.width = fu.floorPowerOfTwo(r.width), m.height = fu.floorPowerOfTwo(r.height), m.getContext("2d").drawImage(r, 0, 0, m.width, m.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + r.width + "x" + r.height + "). Resized to " + m.width + "x" + m.height), m) : r);
            var s = T(o), l = x.convert(t.format), h = x.convert(t.type), c = A(l, h);
            P(n, t, s);
            var u, p = t.mipmaps;
            if (t.isDepthTexture) {
                if (c = g.DEPTH_COMPONENT, t.type === vc) {
                    if (!_.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    c = g.DEPTH_COMPONENT32F
                } else _.isWebGL2 && (c = g.DEPTH_COMPONENT16);
                t.format === Pc && c === g.DEPTH_COMPONENT && t.type !== fc && t.type !== gc && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = fc, h = x.convert(t.type)), t.format === Lc && (c = g.DEPTH_STENCIL, t.type !== wc && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = wc, h = x.convert(t.type))), v.texImage2D(g.TEXTURE_2D, 0, c, o.width, o.height, 0, l, h, null)
            } else if (t.isDataTexture) if (0 < p.length && s) {
                for (var d = 0, f = p.length; d < f; d++) u = p[d], v.texImage2D(g.TEXTURE_2D, d, c, u.width, u.height, 0, l, h, u.data);
                t.generateMipmaps = !1, e.__maxMipLevel = p.length - 1
            } else v.texImage2D(g.TEXTURE_2D, 0, c, o.width, o.height, 0, l, h, o.data), e.__maxMipLevel = 0; else if (t.isCompressedTexture) {
                for (d = 0, f = p.length; d < f; d++) u = p[d], t.format !== Ec && t.format !== Sc ? -1 < v.getCompressedTextureFormats().indexOf(l) ? v.compressedTexImage2D(g.TEXTURE_2D, d, c, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v.texImage2D(g.TEXTURE_2D, d, c, u.width, u.height, 0, l, h, u.data);
                e.__maxMipLevel = p.length - 1
            } else if (t.isDataTexture3D) v.texImage3D(g.TEXTURE_3D, 0, c, o.width, o.height, o.depth, 0, l, h, o.data), e.__maxMipLevel = 0; else if (0 < p.length && s) {
                for (d = 0, f = p.length; d < f; d++) u = p[d], v.texImage2D(g.TEXTURE_2D, d, c, l, h, u);
                t.generateMipmaps = !1, e.__maxMipLevel = p.length - 1
            } else v.texImage2D(g.TEXTURE_2D, 0, c, l, h, o), e.__maxMipLevel = 0;
            S(t, s) && E(g.TEXTURE_2D, t, o.width, o.height), e.__version = t.version, t.onUpdate && t.onUpdate(t)
        }

        function c(e, t, i, n) {
            var r = x.convert(t.texture.format), a = x.convert(t.texture.type), o = A(r, a);
            v.texImage2D(n, 0, o, t.width, t.height, 0, r, a, null), g.bindFramebuffer(g.FRAMEBUFFER, e), g.framebufferTexture2D(g.FRAMEBUFFER, i, n, y.get(t.texture).__webglTexture, 0), g.bindFramebuffer(g.FRAMEBUFFER, null)
        }

        function u(e, t) {
            g.bindRenderbuffer(g.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (g.renderbufferStorage(g.RENDERBUFFER, g.DEPTH_COMPONENT16, t.width, t.height), g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (g.renderbufferStorage(g.RENDERBUFFER, g.DEPTH_STENCIL, t.width, t.height), g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_STENCIL_ATTACHMENT, g.RENDERBUFFER, e)) : g.renderbufferStorage(g.RENDERBUFFER, g.RGBA4, t.width, t.height), g.bindRenderbuffer(g.RENDERBUFFER, null)
        }

        function p(e) {
            var t = y.get(e), i = !0 === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                !function (e, t) {
                    if (t && t.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                    if (g.bindFramebuffer(g.FRAMEBUFFER, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    y.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), l(t.depthTexture, 0);
                    var i = y.get(t.depthTexture).__webglTexture;
                    if (t.depthTexture.format === Pc) g.framebufferTexture2D(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.TEXTURE_2D, i, 0); else {
                        if (t.depthTexture.format !== Lc) throw new Error("Unknown depthTexture format");
                        g.framebufferTexture2D(g.FRAMEBUFFER, g.DEPTH_STENCIL_ATTACHMENT, g.TEXTURE_2D, i, 0)
                    }
                }(t.__webglFramebuffer, e)
            } else if (i) {
                t.__webglDepthbuffer = [];
                for (var n = 0; n < 6; n++) g.bindFramebuffer(g.FRAMEBUFFER, t.__webglFramebuffer[n]), t.__webglDepthbuffer[n] = g.createRenderbuffer(), u(t.__webglDepthbuffer[n], e)
            } else g.bindFramebuffer(g.FRAMEBUFFER, t.__webglFramebuffer), t.__webglDepthbuffer = g.createRenderbuffer(), u(t.__webglDepthbuffer, e);
            g.bindFramebuffer(g.FRAMEBUFFER, null)
        }

        this.setTexture2D = l, this.setTexture3D = function (e, t) {
            var i = y.get(e);
            0 < e.version && i.__version !== e.version ? h(i, e, t) : (v.activeTexture(g.TEXTURE0 + t), v.bindTexture(g.TEXTURE_3D, i.__webglTexture))
        }, this.setTextureCube = function (e, t) {
            var i = y.get(e);
            if (6 === e.image.length) if (0 < e.version && i.__version !== e.version) {
                i.__image__webglTextureCube || (e.addEventListener("dispose", M), i.__image__webglTextureCube = g.createTexture(), b.memory.textures++), v.activeTexture(g.TEXTURE0 + t), v.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube), g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, e.flipY);
                for (var n = e && e.isCompressedTexture, r = e.image[0] && e.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = n || r ? r ? e.image[o].image : e.image[o] : w(e.image[o], _.maxCubemapSize);
                var s = a[0], l = T(s), h = x.convert(e.format), c = x.convert(e.type), u = A(h, c);
                for (P(g.TEXTURE_CUBE_MAP, e, l), o = 0; o < 6; o++) if (n) for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++) p = d[f], e.format !== Ec && e.format !== Sc ? -1 < v.getCompressedTextureFormats().indexOf(h) ? v.compressedTexImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X + o, f, u, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X + o, f, u, p.width, p.height, 0, h, c, p.data); else r ? v.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, u, a[o].width, a[o].height, 0, h, c, a[o].data) : v.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, u, h, c, a[o]);
                i.__maxMipLevel = n ? d.length - 1 : 0, S(e, l) && E(g.TEXTURE_CUBE_MAP, e, s.width, s.height), i.__version = e.version, e.onUpdate && e.onUpdate(e)
            } else v.activeTexture(g.TEXTURE0 + t), v.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube)
        }, this.setTextureCubeDynamic = function (e, t) {
            v.activeTexture(g.TEXTURE0 + t), v.bindTexture(g.TEXTURE_CUBE_MAP, y.get(e).__webglTexture)
        }, this.setupRenderTarget = function (e) {
            var t = y.get(e), i = y.get(e.texture);
            e.addEventListener("dispose", o), i.__webglTexture = g.createTexture(), b.memory.textures++;
            var n = !0 === e.isWebGLRenderTargetCube, r = T(e);
            if (n) {
                t.__webglFramebuffer = [];
                for (var a = 0; a < 6; a++) t.__webglFramebuffer[a] = g.createFramebuffer()
            } else t.__webglFramebuffer = g.createFramebuffer();
            if (n) {
                for (v.bindTexture(g.TEXTURE_CUBE_MAP, i.__webglTexture), P(g.TEXTURE_CUBE_MAP, e.texture, r), a = 0; a < 6; a++) c(t.__webglFramebuffer[a], e, g.COLOR_ATTACHMENT0, g.TEXTURE_CUBE_MAP_POSITIVE_X + a);
                S(e.texture, r) && E(g.TEXTURE_CUBE_MAP, e.texture, e.width, e.height), v.bindTexture(g.TEXTURE_CUBE_MAP, null)
            } else v.bindTexture(g.TEXTURE_2D, i.__webglTexture), P(g.TEXTURE_2D, e.texture, r), c(t.__webglFramebuffer, e, g.COLOR_ATTACHMENT0, g.TEXTURE_2D), S(e.texture, r) && E(g.TEXTURE_2D, e.texture, e.width, e.height), v.bindTexture(g.TEXTURE_2D, null);
            e.depthBuffer && p(e)
        }, this.updateRenderTargetMipmap = function (e) {
            var t = e.texture;
            if (S(t, T(e))) {
                var i = e.isWebGLRenderTargetCube ? g.TEXTURE_CUBE_MAP : g.TEXTURE_2D, n = y.get(t).__webglTexture;
                v.bindTexture(i, n), E(i, t, e.width, e.height), v.bindTexture(i, null)
            }
        }
    }

    function km(i, n, r) {
        return {
            convert: function (e) {
                var t;
                if (e === ic) return i.REPEAT;
                if (e === nc) return i.CLAMP_TO_EDGE;
                if (e === rc) return i.MIRRORED_REPEAT;
                if (e === ac) return i.NEAREST;
                if (e === oc) return i.NEAREST_MIPMAP_NEAREST;
                if (e === sc) return i.NEAREST_MIPMAP_LINEAR;
                if (e === lc) return i.LINEAR;
                if (e === hc) return i.LINEAR_MIPMAP_NEAREST;
                if (e === cc) return i.LINEAR_MIPMAP_LINEAR;
                if (e === uc) return i.UNSIGNED_BYTE;
                if (e === _c) return i.UNSIGNED_SHORT_4_4_4_4;
                if (e === xc) return i.UNSIGNED_SHORT_5_5_5_1;
                if (e === bc) return i.UNSIGNED_SHORT_5_6_5;
                if (e === pc) return i.BYTE;
                if (e === dc) return i.SHORT;
                if (e === fc) return i.UNSIGNED_SHORT;
                if (e === mc) return i.INT;
                if (e === gc) return i.UNSIGNED_INT;
                if (e === vc) return i.FLOAT;
                if (e === yc) {
                    if (r.isWebGL2) return i.HALF_FLOAT;
                    if (null !== (t = n.get("OES_texture_half_float"))) return t.HALF_FLOAT_OES
                }
                if (e === Tc) return i.ALPHA;
                if (e === Sc) return i.RGB;
                if (e === Ec) return i.RGBA;
                if (e === Ac) return i.LUMINANCE;
                if (e === Mc) return i.LUMINANCE_ALPHA;
                if (e === Pc) return i.DEPTH_COMPONENT;
                if (e === Lc) return i.DEPTH_STENCIL;
                if (e === Cc) return i.RED;
                if (e === vh) return i.FUNC_ADD;
                if (e === yh) return i.FUNC_SUBTRACT;
                if (e === _h) return i.FUNC_REVERSE_SUBTRACT;
                if (e === wh) return i.ZERO;
                if (e === Th) return i.ONE;
                if (e === Sh) return i.SRC_COLOR;
                if (e === Eh) return i.ONE_MINUS_SRC_COLOR;
                if (e === Ah) return i.SRC_ALPHA;
                if (e === Mh) return i.ONE_MINUS_SRC_ALPHA;
                if (e === Ph) return i.DST_ALPHA;
                if (e === Lh) return i.ONE_MINUS_DST_ALPHA;
                if (e === Ch) return i.DST_COLOR;
                if (e === Ih) return i.ONE_MINUS_DST_COLOR;
                if (e === Rh) return i.SRC_ALPHA_SATURATE;
                if ((e === Ic || e === Rc || e === Oc || e === Fc) && null !== (t = n.get("WEBGL_compressed_texture_s3tc"))) {
                    if (e === Ic) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (e === Rc) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (e === Oc) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (e === Fc) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((e === Nc || e === kc || e === Uc || e === Dc) && null !== (t = n.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (e === Nc) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (e === kc) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (e === Uc) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (e === Dc) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (e === zc && null !== (t = n.get("WEBGL_compressed_texture_etc1"))) return t.COMPRESSED_RGB_ETC1_WEBGL;
                if ((e === Bc || e === Hc || e === Gc || e === jc || e === Vc || e === Xc || e === Wc || e === Yc || e === qc || e === Qc || e === Zc || e === Jc || e === Kc || e === $c) && null !== (t = n.get("WEBGL_compressed_texture_astc"))) return e;
                if (e === xh || e === bh) {
                    if (r.isWebGL2) {
                        if (e === xh) return i.MIN;
                        if (e === bh) return i.MAX
                    }
                    if (null !== (t = n.get("EXT_blend_minmax"))) {
                        if (e === xh) return t.MIN_EXT;
                        if (e === bh) return t.MAX_EXT
                    }
                }
                if (e === wc) {
                    if (r.isWebGL2) return i.UNSIGNED_INT_24_8;
                    if (null !== (t = n.get("WEBGL_depth_texture"))) return t.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function Um() {
        Pp.call(this), this.type = "Group"
    }

    function Dm() {
        Pp.call(this), this.type = "Camera", this.matrixWorldInverse = new gu, this.projectionMatrix = new gu, this.projectionMatrixInverse = new gu
    }

    function zm(e, t, i, n) {
        Dm.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function Bm(e) {
        zm.call(this), this.cameras = e || []
    }

    function Hm(n) {
        var r = this, l = null, h = null, c = null, u = [], p = new gu, d = new gu, f = "stage";
        "undefined" != typeof window && "VRFrameData" in window && (h = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", e, !1));
        var m = new gu, g = new vu, v = new yu, y = new zm;
        y.bounds = new zu(0, 0, .5, 1), y.layers.enable(1);
        var _ = new zm;
        _.bounds = new zu(.5, 0, .5, 1), _.layers.enable(2);
        var a, o, x = new Bm([y, _]);

        function s() {
            return null !== l && !0 === l.isPresenting
        }

        function e() {
            if (s()) {
                var e = l.getEyeParameters("left"), t = e.renderWidth, i = e.renderHeight;
                o = n.getPixelRatio(), a = n.getSize(), n.setDrawingBufferSize(2 * t, i, 1), T.start()
            } else r.enabled && n.setDrawingBufferSize(a.width, a.height, o), T.stop()
        }

        x.layers.enable(1), x.layers.enable(2);
        var b = [];

        function w(e) {
            for (var t = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = t.length; i < r; i++) {
                var a = t[i];
                if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
                    if (n === e) return a;
                    n++
                }
            }
        }

        this.enabled = !1, this.getController = function (e) {
            var t = u[e];
            return void 0 === t && ((t = new Um).matrixAutoUpdate = !1, t.visible = !1, u[e] = t), t
        }, this.getDevice = function () {
            return l
        }, this.setDevice = function (e) {
            void 0 !== e && (l = e), T.setContext(e)
        }, this.setFrameOfReferenceType = function (e) {
            f = e
        }, this.setPoseTarget = function (e) {
            void 0 !== e && (c = e)
        }, this.getCamera = function (e) {
            var t = "stage" === f ? 1.6 : 0;
            if (null === l) return e.position.set(0, t, 0), e;
            if (l.depthNear = e.near, l.depthFar = e.far, l.getFrameData(h), "stage" === f) {
                var i = l.stageParameters;
                i ? p.fromArray(i.sittingToStandingTransform) : p.makeTranslation(0, t, 0)
            }
            var n = h.pose, r = null !== c ? c : e;
            if (r.matrix.copy(p), r.matrix.decompose(r.position, r.quaternion, r.scale), null !== n.orientation && (g.fromArray(n.orientation), r.quaternion.multiply(g)), null !== n.position && (g.setFromRotationMatrix(p), v.fromArray(n.position), v.applyQuaternion(g), r.position.add(v)), r.updateMatrixWorld(), !1 === l.isPresenting) return e;
            y.near = e.near, _.near = e.near, y.far = e.far, _.far = e.far, x.matrixWorld.copy(e.matrixWorld), x.matrixWorldInverse.copy(e.matrixWorldInverse), y.matrixWorldInverse.fromArray(h.leftViewMatrix), _.matrixWorldInverse.fromArray(h.rightViewMatrix), d.getInverse(p), "stage" === f && (y.matrixWorldInverse.multiply(d), _.matrixWorldInverse.multiply(d));
            var a = r.parent;
            null !== a && (m.getInverse(a.matrixWorld), y.matrixWorldInverse.multiply(m), _.matrixWorldInverse.multiply(m)), y.matrixWorld.getInverse(y.matrixWorldInverse), _.matrixWorld.getInverse(_.matrixWorldInverse), y.projectionMatrix.fromArray(h.leftProjectionMatrix), _.projectionMatrix.fromArray(h.rightProjectionMatrix), x.projectionMatrix.copy(y.projectionMatrix);
            var o = l.getLayers();
            if (o.length) {
                var s = o[0];
                null !== s.leftBounds && 4 === s.leftBounds.length && y.bounds.fromArray(s.leftBounds), null !== s.rightBounds && 4 === s.rightBounds.length && _.bounds.fromArray(s.rightBounds)
            }
            return function () {
                for (var e = 0; e < u.length; e++) {
                    var t = u[e], i = w(e);
                    if (void 0 !== i && void 0 !== i.pose) {
                        if (null === i.pose) return;
                        var n = i.pose;
                        !1 === n.hasPosition && t.position.set(.2, -.6, -.05), null !== n.position && t.position.fromArray(n.position), null !== n.orientation && t.quaternion.fromArray(n.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(p), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0;
                        var r = "Daydream Controller" === i.id ? 0 : 1;
                        b[e] !== i.buttons[r].pressed && (b[e] = i.buttons[r].pressed, !0 === b[e] ? t.dispatchEvent({type: "selectstart"}) : (t.dispatchEvent({type: "selectend"}), t.dispatchEvent({type: "select"})))
                    } else t.visible = !1
                }
            }(), x
        }, this.getStandingMatrix = function () {
            return p
        }, this.isPresenting = s;
        var T = new rp;
        this.setAnimationLoop = function (e) {
            T.setAnimationLoop(e)
        }, this.submitFrame = function () {
            s() && l.submitFrame()
        }, this.dispose = function () {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e)
        }
    }

    function Gm(t) {
        var i = t.context, n = null, p = null, d = null, r = "stage", f = null, m = [], g = [];

        function o() {
            return null !== p && null !== d
        }

        var e = new zm;
        e.layers.enable(1), e.viewport = new zu;
        var a = new zm;
        a.layers.enable(2), a.viewport = new zu;
        var v = new Bm([e, a]);

        function s(e) {
            var t = m[g.indexOf(e.inputSource)];
            t && t.dispatchEvent({type: e.type})
        }

        function l() {
            t.setFramebuffer(null), c.stop()
        }

        function h(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
        }

        v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (e) {
            var t = m[e];
            return void 0 === t && ((t = new Um).matrixAutoUpdate = !1, t.visible = !1, m[e] = t), t
        }, this.getDevice = function () {
            return n
        }, this.setDevice = function (e) {
            void 0 !== e && (n = e), e instanceof XRDevice && i.setCompatibleXRDevice(e)
        }, this.setFrameOfReferenceType = function (e) {
            r = e
        }, this.setSession = function (e) {
            null !== (p = e) && (p.addEventListener("select", s), p.addEventListener("selectstart", s), p.addEventListener("selectend", s), p.addEventListener("end", l), p.baseLayer = new XRWebGLLayer(p, i), p.requestFrameOfReference(r).then(function (e) {
                d = e, t.setFramebuffer(p.baseLayer.framebuffer), c.setContext(p), c.start()
            }), g = p.getInputSources(), p.addEventListener("inputsourceschange", function () {
                g = p.getInputSources(), console.log(g)
            }))
        }, this.getCamera = function (e) {
            if (o()) {
                var t = e.parent, i = v.cameras;
                h(v, t);
                for (var n = 0; n < i.length; n++) h(i[n], t);
                e.matrixWorld.copy(v.matrixWorld);
                for (var r = e.children, a = (n = 0, r.length); n < a; n++) r[n].updateMatrixWorld(!0);
                return v
            }
            return e
        }, this.isPresenting = o;
        var y = null;
        var c = new rp;
        c.setAnimationLoop(function (e, t) {
            if (null !== (f = t.getDevicePose(d))) for (var i = p.baseLayer, n = t.views, r = 0; r < n.length; r++) {
                var a = n[r], o = i.getViewport(a), s = f.getViewMatrix(a), l = v.cameras[r];
                l.matrix.fromArray(s).getInverse(l.matrix), l.projectionMatrix.fromArray(a.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === r && (v.matrix.copy(l.matrix), v.projectionMatrix.copy(l.projectionMatrix))
            }
            for (r = 0; r < m.length; r++) {
                var h = m[r], c = g[r];
                if (c) {
                    var u = t.getInputPose(c, d);
                    if (null !== u) {
                        "targetRay" in u ? h.matrix.elements = u.targetRay.transformMatrix : "pointerMatrix" in u && (h.matrix.elements = u.pointerMatrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.visible = !0;
                        continue
                    }
                }
                h.visible = !1
            }
            y && y(e)
        }), this.setAnimationLoop = function (e) {
            y = e
        }, this.dispose = function () {
        }, this.getStandingMatrix = function () {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
        }, this.submitFrame = function () {
        }
    }

    function jm(e) {
        console.log("THREE.WebGLRenderer", "97");
        var n = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            t = void 0 !== e.context ? e.context : null, i = void 0 !== e.alpha && e.alpha,
            r = void 0 === e.depth || e.depth, a = void 0 === e.stencil || e.stencil,
            o = void 0 !== e.antialias && e.antialias, s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
            l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
            h = void 0 !== e.powerPreference ? e.powerPreference : "default", d = null, H = null;
        this.domElement = n, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Xh, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var G, T, j, V, c, X, u, S, E, f, y, p, m, g, A, M, P, v, W = this, _ = !1, x = null, b = null, w = null,
            Y = -1, L = {geometry: null, program: null, wireframe: !1}, q = null, C = null, I = new zu, R = new zu,
            O = null, Q = 0, F = n.width, Z = n.height, J = 1, N = new zu(0, 0, F, Z), k = new zu(0, 0, F, Z), U = !1,
            D = new Wu, K = new Yd, $ = !1, ee = !1, z = new gu, te = new yu;

        function B() {
            return null === b ? J : 1
        }

        try {
            var ie = {
                alpha: i,
                depth: r,
                stencil: a,
                antialias: o,
                premultipliedAlpha: s,
                preserveDrawingBuffer: l,
                powerPreference: h
            };
            if (n.addEventListener("webglcontextlost", oe, !1), n.addEventListener("webglcontextrestored", se, !1), null === (G = t || n.getContext("webgl", ie) || n.getContext("experimental-webgl", ie))) throw null !== n.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            void 0 === G.getShaderPrecisionFormat && (G.getShaderPrecisionFormat = function () {
                return {rangeMin: 1, rangeMax: 1, precision: 1}
            })
        } catch (e) {
            console.error("THREE.WebGLRenderer: " + e.message)
        }

        function ne() {
            T = new qd(G), (j = new Wd(G, T, e)).isWebGL2 || (T.get("WEBGL_depth_texture"), T.get("OES_texture_float"), T.get("OES_texture_half_float"), T.get("OES_texture_half_float_linear"), T.get("OES_standard_derivatives"), T.get("OES_element_index_uint"), T.get("ANGLE_instanced_arrays")), T.get("OES_texture_float_linear"), v = new km(G, T, j), (V = new Fm(G, T, v, j)).scissor(R.copy(k).multiplyScalar(J)), V.viewport(I.copy(N).multiplyScalar(J)), c = new Jd(G), X = new am, u = new Nm(G, T, V, X, j, v, c), S = new ap(G), E = new Qd(G, S, c), f = new ef(E, c), A = new $d(G), y = new rm(W, T, j), p = new hm, m = new Cm, g = new Vd(W, V, f, s), M = new Xd(G, T, c, j), P = new Zd(G, T, c, j), c.programs = y.programs, W.context = G, W.capabilities = j, W.extensions = T, W.properties = X, W.renderLists = p, W.state = V, W.info = c
        }

        ne();
        var re = null;
        "undefined" != typeof navigator && (re = "xr" in navigator ? new Gm(W) : new Hm(W)), this.vr = re;
        var ae = new Om(W, f, j.maxTextureSize);

        function oe(e) {
            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _ = !0
        }

        function se() {
            console.log("THREE.WebGLRenderer: Context Restored."), _ = !1, ne()
        }

        function le(e) {
            var t, i = e.target;
            i.removeEventListener("dispose", le), he(t = i), X.remove(t)
        }

        function he(e) {
            var t = X.get(e).program;
            (e.program = void 0) !== t && y.releaseProgram(t)
        }

        this.shadowMap = ae, this.getContext = function () {
            return G
        }, this.getContextAttributes = function () {
            return G.getContextAttributes()
        }, this.forceContextLoss = function () {
            var e = T.get("WEBGL_lose_context");
            e && e.loseContext()
        }, this.forceContextRestore = function () {
            var e = T.get("WEBGL_lose_context");
            e && e.restoreContext()
        }, this.getPixelRatio = function () {
            return J
        }, this.setPixelRatio = function (e) {
            void 0 !== e && (J = e, this.setSize(F, Z, !1))
        }, this.getSize = function () {
            return {width: F, height: Z}
        }, this.setSize = function (e, t, i) {
            re.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (F = e, Z = t, n.width = e * J, n.height = t * J, !1 !== i && (n.style.width = e + "px", n.style.height = t + "px"), this.setViewport(0, 0, e, t))
        }, this.getDrawingBufferSize = function () {
            return {width: F * J, height: Z * J}
        }, this.setDrawingBufferSize = function (e, t, i) {
            F = e, Z = t, J = i, n.width = e * i, n.height = t * i, this.setViewport(0, 0, e, t)
        }, this.getCurrentViewport = function () {
            return I
        }, this.setViewport = function (e, t, i, n) {
            N.set(e, Z - t - n, i, n), V.viewport(I.copy(N).multiplyScalar(J))
        }, this.setScissor = function (e, t, i, n) {
            k.set(e, Z - t - n, i, n), V.scissor(R.copy(k).multiplyScalar(J))
        }, this.setScissorTest = function (e) {
            V.setScissorTest(U = e)
        }, this.getClearColor = function () {
            return g.getClearColor()
        }, this.setClearColor = function () {
            g.setClearColor.apply(g, arguments)
        }, this.getClearAlpha = function () {
            return g.getClearAlpha()
        }, this.setClearAlpha = function () {
            g.setClearAlpha.apply(g, arguments)
        }, this.clear = function (e, t, i) {
            var n = 0;
            (void 0 === e || e) && (n |= G.COLOR_BUFFER_BIT), (void 0 === t || t) && (n |= G.DEPTH_BUFFER_BIT), (void 0 === i || i) && (n |= G.STENCIL_BUFFER_BIT), G.clear(n)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            n.removeEventListener("webglcontextlost", oe, !1), n.removeEventListener("webglcontextrestored", se, !1), p.dispose(), m.dispose(), X.dispose(), f.dispose(), re.dispose(), fe.stop()
        }, this.renderBufferImmediate = function (e, t) {
            V.initAttributes();
            var i = X.get(e);
            e.hasPositions && !i.position && (i.position = G.createBuffer()), e.hasNormals && !i.normal && (i.normal = G.createBuffer()), e.hasUvs && !i.uv && (i.uv = G.createBuffer()), e.hasColors && !i.color && (i.color = G.createBuffer());
            var n = t.getAttributes();
            e.hasPositions && (G.bindBuffer(G.ARRAY_BUFFER, i.position), G.bufferData(G.ARRAY_BUFFER, e.positionArray, G.DYNAMIC_DRAW), V.enableAttribute(n.position), G.vertexAttribPointer(n.position, 3, G.FLOAT, !1, 0, 0)), e.hasNormals && (G.bindBuffer(G.ARRAY_BUFFER, i.normal), G.bufferData(G.ARRAY_BUFFER, e.normalArray, G.DYNAMIC_DRAW), V.enableAttribute(n.normal), G.vertexAttribPointer(n.normal, 3, G.FLOAT, !1, 0, 0)), e.hasUvs && (G.bindBuffer(G.ARRAY_BUFFER, i.uv), G.bufferData(G.ARRAY_BUFFER, e.uvArray, G.DYNAMIC_DRAW), V.enableAttribute(n.uv), G.vertexAttribPointer(n.uv, 2, G.FLOAT, !1, 0, 0)), e.hasColors && (G.bindBuffer(G.ARRAY_BUFFER, i.color), G.bufferData(G.ARRAY_BUFFER, e.colorArray, G.DYNAMIC_DRAW), V.enableAttribute(n.color), G.vertexAttribPointer(n.color, 3, G.FLOAT, !1, 0, 0)), V.disableUnusedAttributes(), G.drawArrays(G.TRIANGLES, 0, e.count), e.count = 0
        }, this.renderBufferDirect = function (e, t, i, n, r, a) {
            var o = r.isMesh && r.normalMatrix.determinant() < 0;
            V.setMaterial(n, o);
            var s = ye(e, t, n, r), l = !1;
            L.geometry === i.id && L.program === s.id && L.wireframe === (!0 === n.wireframe) || (L.geometry = i.id, L.program = s.id, L.wireframe = !0 === n.wireframe, l = !0), r.morphTargetInfluences && (A.update(r, i, n, s), l = !0);
            var h, c = i.index, u = i.attributes.position, p = 1;
            !0 === n.wireframe && (c = E.getWireframeAttribute(i), p = 2);
            var d = M;
            null !== c && (h = S.get(c), (d = P).setIndex(h)), l && (!function (e, t, i) {
                if (i && i.isInstancedBufferGeometry & !j.isWebGL2 && null === T.get("ANGLE_instanced_arrays")) return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                V.initAttributes();
                var n = i.attributes, r = t.getAttributes(), a = e.defaultAttributeValues;
                for (var o in r) {
                    var s = r[o];
                    if (0 <= s) {
                        var l = n[o];
                        if (void 0 !== l) {
                            var h = l.normalized, c = l.itemSize, u = S.get(l);
                            if (void 0 === u) continue;
                            var p = u.buffer, d = u.type, f = u.bytesPerElement;
                            if (l.isInterleavedBufferAttribute) {
                                var m = l.data, g = m.stride, v = l.offset;
                                m && m.isInstancedInterleavedBuffer ? (V.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : V.enableAttribute(s), G.bindBuffer(G.ARRAY_BUFFER, p), G.vertexAttribPointer(s, c, d, h, g * f, v * f)
                            } else l.isInstancedBufferAttribute ? (V.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : V.enableAttribute(s), G.bindBuffer(G.ARRAY_BUFFER, p), G.vertexAttribPointer(s, c, d, h, 0, 0)
                        } else if (void 0 !== a) {
                            var y = a[o];
                            if (void 0 !== y) switch (y.length) {
                                case 2:
                                    G.vertexAttrib2fv(s, y);
                                    break;
                                case 3:
                                    G.vertexAttrib3fv(s, y);
                                    break;
                                case 4:
                                    G.vertexAttrib4fv(s, y);
                                    break;
                                default:
                                    G.vertexAttrib1fv(s, y)
                            }
                        }
                    }
                }
                V.disableUnusedAttributes()
            }(n, s, i), null !== c && G.bindBuffer(G.ELEMENT_ARRAY_BUFFER, h.buffer));
            var f = 1 / 0;
            null !== c ? f = c.count : void 0 !== u && (f = u.count);
            var m = i.drawRange.start * p, g = i.drawRange.count * p, v = null !== a ? a.start * p : 0,
                y = null !== a ? a.count * p : 1 / 0, _ = Math.max(m, v), x = Math.min(f, m + g, v + y) - 1,
                b = Math.max(0, x - _ + 1);
            if (0 !== b) {
                if (r.isMesh) if (!0 === n.wireframe) V.setLineWidth(n.wireframeLinewidth * B()), d.setMode(G.LINES); else switch (r.drawMode) {
                    case iu:
                        d.setMode(G.TRIANGLES);
                        break;
                    case 1:
                        d.setMode(G.TRIANGLE_STRIP);
                        break;
                    case 2:
                        d.setMode(G.TRIANGLE_FAN)
                } else if (r.isLine) {
                    var w = n.linewidth;
                    void 0 === w && (w = 1), V.setLineWidth(w * B()), r.isLineSegments ? d.setMode(G.LINES) : r.isLineLoop ? d.setMode(G.LINE_LOOP) : d.setMode(G.LINE_STRIP)
                } else r.isPoints ? d.setMode(G.POINTS) : r.isSprite && d.setMode(G.TRIANGLES);
                i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && d.renderInstances(i, _, b) : d.render(_, b)
            }
        }, this.compile = function (i, e) {
            (H = m.get(i, e)).init(), i.traverse(function (e) {
                e.isLight && (H.pushLight(e), e.castShadow && H.pushShadow(e))
            }), H.setupLights(e), i.traverse(function (e) {
                if (e.material) if (Array.isArray(e.material)) for (var t = 0; t < e.material.length; t++) ve(e.material[t], i.fog, e); else ve(e.material, i.fog, e)
            })
        };
        var ce = null;
        var ue, pe, de, fe = new rp;

        function me(e, t, i, n) {
            for (var r = 0, a = e.length; r < a; r++) {
                var o = e[r], s = o.object, l = o.geometry, h = void 0 === n ? o.material : n, c = o.group;
                if (i.isArrayCamera) for (var u = (C = i).cameras, p = 0, d = u.length; p < d; p++) {
                    var f = u[p];
                    if (s.layers.test(f.layers)) {
                        if ("viewport" in f) V.viewport(I.copy(f.viewport)); else {
                            var m = f.bounds, g = m.x * F, v = m.y * Z, y = m.z * F, _ = m.w * Z;
                            V.viewport(I.set(g, v, y, _).multiplyScalar(J))
                        }
                        H.setupLights(f), ge(s, t, f, l, h, c)
                    }
                } else C = null, ge(s, t, i, l, h, c)
            }
        }

        function ge(e, t, i, n, r, a) {
            if (e.onBeforeRender(W, t, i, n, r, a), H = m.get(t, C || i), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                V.setMaterial(r);
                var o = ye(i, t.fog, r, e);
                L.geometry = null, L.program = null, L.wireframe = !1, s = o, e.render(function (e) {
                    W.renderBufferImmediate(e, s)
                })
            } else W.renderBufferDirect(i, t.fog, n, r, e, a);
            var s;
            e.onAfterRender(W, t, i, n, r, a), H = m.get(t, C || i)
        }

        function ve(e, t, i) {
            var n = X.get(e), r = H.state.lights, a = H.state.shadowsArray, o = n.lightsHash, s = r.state.hash,
                l = y.getParameters(e, r.state, a, t, K.numPlanes, K.numIntersection, i), h = y.getProgramCode(e, l),
                c = n.program, u = !0;
            if (void 0 === c) e.addEventListener("dispose", le); else if (c.code !== h) he(e); else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, u = !1; else {
                if (void 0 !== l.shaderID) return;
                u = !1
            }
            if (u) {
                if (l.shaderID) {
                    var p = np[l.shaderID];
                    n.shader = {
                        name: e.type,
                        uniforms: Ju.clone(p.uniforms),
                        vertexShader: p.vertexShader,
                        fragmentShader: p.fragmentShader
                    }
                } else n.shader = {
                    name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader
                };
                e.onBeforeCompile(n.shader, W), h = y.getProgramCode(e, l), c = y.acquireProgram(e, n.shader, l, h), n.program = c, e.program = c
            }
            var d = c.getAttributes();
            if (e.morphTargets) for (var f = e.numSupportedMorphTargets = 0; f < W.maxMorphTargets; f++) 0 <= d["morphTarget" + f] && e.numSupportedMorphTargets++;
            if (e.morphNormals) for (f = e.numSupportedMorphNormals = 0; f < W.maxMorphNormals; f++) 0 <= d["morphNormal" + f] && e.numSupportedMorphNormals++;
            var m = n.shader.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = K.numPlanes, n.numIntersection = K.numIntersection, m.clippingPlanes = K.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, e.lights && (m.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
            var g = n.program.getUniforms(), v = Yf.seqWithValue(g.seq, m);
            n.uniformsList = v
        }

        function ye(e, t, i, n) {
            Q = 0;
            var r = X.get(i), a = H.state.lights, o = r.lightsHash, s = a.state.hash;
            if ($ && (ee || e !== q)) {
                var l = e === q && i.id === Y;
                K.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, l)
            }
            !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === K.numPlanes && r.numIntersection === K.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (ve(i, t, n), i.needsUpdate = !1);
            var h, c, u, p, d, f, m, g, v, y, _, x, b, w, T, S, E, A, M, P, L = !1, C = !1, I = !1, R = r.program,
                O = R.getUniforms(), F = r.shader.uniforms;
            if (V.useProgram(R.program) && (I = C = L = !0), i.id !== Y && (Y = i.id, C = !0), L || q !== e) {
                if (O.setValue(G, "projectionMatrix", e.projectionMatrix), j.logarithmicDepthBuffer && O.setValue(G, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), q !== e && (q = e, I = C = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) {
                    var N = O.map.cameraPosition;
                    void 0 !== N && N.setValue(G, te.setFromMatrixPosition(e.matrixWorld))
                }
                (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && O.setValue(G, "viewMatrix", e.matrixWorldInverse)
            }
            if (i.skinning) {
                O.setOptional(G, n, "bindMatrix"), O.setOptional(G, n, "bindMatrixInverse");
                var k = n.skeleton;
                if (k) {
                    var U = k.bones;
                    if (j.floatVertexTextures) {
                        if (void 0 === k.boneTexture) {
                            var D = Math.sqrt(4 * U.length);
                            D = fu.ceilPowerOfTwo(D), D = Math.max(D, 4);
                            var z = new Float32Array(D * D * 4);
                            z.set(k.boneMatrices);
                            var B = new Gu(z, D, D, Ec, vc);
                            B.needsUpdate = !0, k.boneMatrices = z, k.boneTexture = B, k.boneTextureSize = D
                        }
                        O.setValue(G, "boneTexture", k.boneTexture), O.setValue(G, "boneTextureSize", k.boneTextureSize)
                    } else O.setOptional(G, k, "boneMatrices")
                }
            }
            return C && (O.setValue(G, "toneMappingExposure", W.toneMappingExposure), O.setValue(G, "toneMappingWhitePoint", W.toneMappingWhitePoint), i.lights && (P = I, (M = F).ambientLightColor.needsUpdate = P, M.directionalLights.needsUpdate = P, M.pointLights.needsUpdate = P, M.spotLights.needsUpdate = P, M.rectAreaLights.needsUpdate = P, M.hemisphereLights.needsUpdate = P), t && i.fog && (A = t, (E = F).fogColor.value = A.color, A.isFog ? (E.fogNear.value = A.near, E.fogFar.value = A.far) : A.isFogExp2 && (E.fogDensity.value = A.density)), i.isMeshBasicMaterial ? _e(F, i) : i.isMeshLambertMaterial ? (_e(F, i), T = F, (S = i).emissiveMap && (T.emissiveMap.value = S.emissiveMap)) : i.isMeshPhongMaterial ? (_e(F, i), i.isMeshToonMaterial ? (xe(b = F, w = i), w.gradientMap && (b.gradientMap.value = w.gradientMap)) : xe(F, i)) : i.isMeshStandardMaterial ? (_e(F, i), i.isMeshPhysicalMaterial ? (be(_ = F, x = i), _.reflectivity.value = x.reflectivity, _.clearCoat.value = x.clearCoat, _.clearCoatRoughness.value = x.clearCoatRoughness) : be(F, i)) : i.isMeshMatcapMaterial ? (_e(F, i), function (e, t) {
                t.matcap && (e.matcap.value = t.matcap);
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === lh && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === lh && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(F, i)) : i.isMeshDepthMaterial ? (_e(F, i), v = F, (y = i).displacementMap && (v.displacementMap.value = y.displacementMap, v.displacementScale.value = y.displacementScale, v.displacementBias.value = y.displacementBias)) : i.isMeshDistanceMaterial ? (_e(F, i), function (e, t) {
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
            }(F, i)) : i.isMeshNormalMaterial ? (_e(F, i), function (e, t) {
                t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === lh && (e.bumpScale.value *= -1));
                t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === lh && e.normalScale.value.negate());
                t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
            }(F, i)) : i.isLineBasicMaterial ? (g = i, (m = F).diffuse.value = g.color, m.opacity.value = g.opacity, i.isLineDashedMaterial && (f = i, (d = F).dashSize.value = f.dashSize, d.totalSize.value = f.dashSize + f.gapSize, d.scale.value = f.scale)) : i.isPointsMaterial ? (p = i, (u = F).diffuse.value = p.color, u.opacity.value = p.opacity, u.size.value = p.size * J, u.scale.value = .5 * Z, u.map.value = p.map, null !== p.map && (!0 === p.map.matrixAutoUpdate && p.map.updateMatrix(), u.uvTransform.value.copy(p.map.matrix))) : i.isSpriteMaterial ? (c = i, (h = F).diffuse.value = c.color, h.opacity.value = c.opacity, h.rotation.value = c.rotation, h.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), h.uvTransform.value.copy(c.map.matrix))) : i.isShadowMaterial && (F.color.value = i.color, F.opacity.value = i.opacity), void 0 !== F.ltc_1 && (F.ltc_1.value = ip.LTC_1), void 0 !== F.ltc_2 && (F.ltc_2.value = ip.LTC_2), Yf.upload(G, r.uniformsList, F, W)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Yf.upload(G, r.uniformsList, F, W), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && O.setValue(G, "center", n.center), O.setValue(G, "modelViewMatrix", n.modelViewMatrix), O.setValue(G, "normalMatrix", n.normalMatrix), O.setValue(G, "modelMatrix", n.matrixWorld), R
        }

        function _e(e, t) {
            var i;
            e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = X.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix))
        }

        function xe(e, t) {
            e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === lh && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === lh && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
        }

        function be(e, t) {
            e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === lh && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === lh && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }

        fe.setAnimationLoop(function (e) {
            re.isPresenting() || ce && ce(e)
        }), "undefined" != typeof window && fe.setContext(window), this.setAnimationLoop = function (e) {
            ce = e, re.setAnimationLoop(e), fe.start()
        }, this.render = function (e, t, i, n) {
            if (t && t.isCamera) {
                if (!_) {
                    L.geometry = null, L.program = null, L.wireframe = !1, Y = -1, !(q = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), re.enabled && (t = re.getCamera(t)), (H = m.get(e, t)).init(), e.onBeforeRender(W, e, t, i), z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), D.setFromMatrix(z), ee = this.localClippingEnabled, $ = K.init(this.clippingPlanes, ee, t), (d = p.get(e, t)).init(), function e(t, i, n) {
                        if (!1 === t.visible) return;
                        var r = t.layers.test(i.layers);
                        if (r) if (t.isLight) H.pushLight(t), t.castShadow && H.pushShadow(t); else if (t.isSprite) {
                            if (!t.frustumCulled || D.intersectsSprite(t)) {
                                n && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                                var a = f.update(t), o = t.material;
                                d.push(t, a, o, te.z, null)
                            }
                        } else if (t.isImmediateRenderObject) n && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z), d.push(t, null, t.material, te.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || D.intersectsObject(t))) {
                            n && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                            var a = f.update(t), o = t.material;
                            if (Array.isArray(o)) for (var s = a.groups, l = 0, h = s.length; l < h; l++) {
                                var c = s[l], u = o[c.materialIndex];
                                u && u.visible && d.push(t, a, u, te.z, c)
                            } else o.visible && d.push(t, a, o, te.z, null)
                        }
                        var p = t.children;
                        for (var l = 0, h = p.length; l < h; l++) e(p[l], i, n)
                    }(e, t, W.sortObjects), !0 === W.sortObjects && d.sort(), $ && K.beginShadows();
                    var r = H.state.shadowsArray;
                    ae.render(r, e, t), H.setupLights(t), $ && K.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), g.render(d, e, t, n);
                    var a = d.opaque, o = d.transparent;
                    if (e.overrideMaterial) {
                        var s = e.overrideMaterial;
                        a.length && me(a, e, t, s), o.length && me(o, e, t, s)
                    } else a.length && me(a, e, t), o.length && me(o, e, t);
                    i && u.updateRenderTargetMipmap(i), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), e.onAfterRender(W, e, t), re.enabled && re.submitFrame(), H = d = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.allocTextureUnit = function () {
            var e = Q;
            return e >= j.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + j.maxTextures), Q += 1, e
        }, this.setTexture2D = (ue = !1, function (e, t) {
            e && e.isWebGLRenderTarget && (ue || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ue = !0), e = e.texture), u.setTexture2D(e, t)
        }), this.setTexture3D = function (e, t) {
            u.setTexture3D(e, t)
        }, this.setTexture = (pe = !1, function (e, t) {
            pe || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), pe = !0), u.setTexture2D(e, t)
        }), this.setTextureCube = (de = !1, function (e, t) {
            e && e.isWebGLRenderTargetCube && (de || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), de = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? u.setTextureCube(e, t) : u.setTextureCubeDynamic(e, t)
        }), this.setFramebuffer = function (e) {
            x = e
        }, this.getRenderTarget = function () {
            return b
        }, this.setRenderTarget = function (e) {
            (b = e) && void 0 === X.get(e).__webglFramebuffer && u.setupRenderTarget(e);
            var t = x, i = !1;
            if (e) {
                var n = X.get(e).__webglFramebuffer;
                e.isWebGLRenderTargetCube ? (t = n[e.activeCubeFace], i = !0) : t = n, I.copy(e.viewport), R.copy(e.scissor), O = e.scissorTest
            } else I.copy(N).multiplyScalar(J), R.copy(k).multiplyScalar(J), O = U;
            if (w !== t && (G.bindFramebuffer(G.FRAMEBUFFER, t), w = t), V.viewport(I), V.scissor(R), V.setScissorTest(O), i) {
                var r = X.get(e.texture);
                G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, r.__webglTexture, e.activeMipMapLevel)
            }
        }, this.readRenderTargetPixels = function (e, t, i, n, r, a) {
            if (e && e.isWebGLRenderTarget) {
                var o = X.get(e).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== w && (G.bindFramebuffer(G.FRAMEBUFFER, o), s = !0);
                    try {
                        var l = e.texture, h = l.format, c = l.type;
                        if (h !== Ec && v.convert(h) !== G.getParameter(G.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        if (!(c === uc || v.convert(c) === G.getParameter(G.IMPLEMENTATION_COLOR_READ_TYPE) || c === vc && (j.isWebGL2 || T.get("OES_texture_float") || T.get("WEBGL_color_buffer_float")) || c === yc && (j.isWebGL2 ? T.get("EXT_color_buffer_float") : T.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        G.checkFramebufferStatus(G.FRAMEBUFFER) === G.FRAMEBUFFER_COMPLETE ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && G.readPixels(t, i, n, r, v.convert(h), v.convert(c), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                    } finally {
                        s && G.bindFramebuffer(G.FRAMEBUFFER, w)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (e, t, i) {
            var n = t.image.width, r = t.image.height, a = v.convert(t.format);
            this.setTexture2D(t, 0), G.copyTexImage2D(G.TEXTURE_2D, i || 0, a, e.x, e.y, n, r, 0)
        }, this.copyTextureToTexture = function (e, t, i, n) {
            var r = t.image.width, a = t.image.height, o = v.convert(i.format), s = v.convert(i.type);
            this.setTexture2D(i, 0), t.isDataTexture ? G.texSubImage2D(G.TEXTURE_2D, n || 0, e.x, e.y, r, a, o, s, t.image.data) : G.texSubImage2D(G.TEXTURE_2D, n || 0, e.x, e.y, o, s, t.image)
        }
    }

    function Vm(e, t) {
        this.name = "", this.color = new $u(e), this.density = void 0 !== t ? t : 25e-5
    }

    function Xm(e, t, i) {
        this.name = "", this.color = new $u(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Wm() {
        Pp.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
    }

    function Ym(e, t) {
        this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
            offset: 0, count: -1
        }, this.version = 0
    }

    function qm(e, t, i, n) {
        this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n
    }

    function Qm(e) {
        Dd.call(this), this.type = "SpriteMaterial", this.color = new $u(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
    }

    function Zm(e) {
        if (Pp.call(this), this.type = "Sprite", void 0 === um) {
            um = new sd;
            var t = new Ym(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
            um.setIndex([0, 1, 2, 0, 2, 3]), um.addAttribute("position", new qm(t, 3, 0, !1)), um.addAttribute("uv", new qm(t, 2, 3, !1))
        }
        this.geometry = um, this.material = void 0 !== e ? e : new Qm, this.center = new mu(.5, .5)
    }

    function Jm() {
        Pp.call(this), this.type = "LOD", Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
    }

    function Km(e, t) {
        if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses(); else if (this.bones.length === t.length) this.boneInverses = t.slice(0); else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
            for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new gu)
        }
    }

    function $m() {
        Pp.call(this), this.type = "Bone"
    }

    function eg(e, t) {
        jd.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new gu, this.bindMatrixInverse = new gu;
        var i = new Km(this.initBones());
        this.bind(i, this.matrixWorld), this.normalizeSkinWeights()
    }

    function tg(e) {
        Dd.call(this), this.type = "LineBasicMaterial", this.color = new $u(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
    }

    function ig(e, t, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), Pp.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new sd, this.material = void 0 !== t ? t : new tg({color: 16777215 * Math.random()})
    }

    function ng(e, t) {
        ig.call(this, e, t), this.type = "LineSegments"
    }

    function rg(e, t) {
        ig.call(this, e, t), this.type = "LineLoop"
    }

    function ag(e) {
        Dd.call(this), this.type = "PointsMaterial", this.color = new $u(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e)
    }

    function og(e, t) {
        Pp.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new sd, this.material = void 0 !== t ? t : new ag({color: 16777215 * Math.random()})
    }

    function sg(e, t, i, n, r, a, o, s, l) {
        Du.call(this, e, t, i, n, r, a, o, s, l), this.generateMipmaps = !1
    }

    function lg(e, t, i, n, r, a, o, s, l, h, c, u) {
        Du.call(this, null, a, o, s, l, h, n, r, c, u), this.image = {
            width: t, height: i
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }

    function hg(e, t, i, n, r, a, o, s, l) {
        Du.call(this, e, t, i, n, r, a, o, s, l), this.needsUpdate = !0
    }

    function cg(e, t, i, n, r, a, o, s, l, h) {
        if ((h = void 0 !== h ? h : Pc) !== Pc && h !== Lc) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && h === Pc && (i = fc), void 0 === i && h === Lc && (i = wc), Du.call(this, null, n, r, a, o, s, h, i, l), this.image = {
            width: e, height: t
        }, this.magFilter = void 0 !== o ? o : ac, this.minFilter = void 0 !== s ? s : ac, this.flipY = !1, this.generateMipmaps = !1
    }

    function ug(e) {
        sd.call(this), this.type = "WireframeGeometry";
        var t, i, n, r, a, o, s, l, h, c, u = [], p = [0, 0], d = {}, f = ["a", "b", "c"];
        if (e && e.isGeometry) {
            var m = e.faces;
            for (t = 0, n = m.length; t < n; t++) {
                var g = m[t];
                for (i = 0; i < 3; i++) s = g[f[i]], l = g[f[(i + 1) % 3]], p[0] = Math.min(s, l), p[1] = Math.max(s, l), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                    index1: p[0], index2: p[1]
                })
            }
            for (h in d) o = d[h], c = e.vertices[o.index1], u.push(c.x, c.y, c.z), c = e.vertices[o.index2], u.push(c.x, c.y, c.z)
        } else if (e && e.isBufferGeometry) {
            var v, y, _, x, b, w;
            if (c = new yu, null !== e.index) {
                for (v = e.attributes.position, y = e.index, 0 === (_ = e.groups).length && (_ = [{
                    start: 0, count: y.count, materialIndex: 0
                }]), r = 0, a = _.length; r < a; ++r) for (n = (t = (x = _[r]).start) + x.count; t < n; t += 3) for (i = 0; i < 3; i++) s = y.getX(t + i), l = y.getX(t + (i + 1) % 3), p[0] = Math.min(s, l), p[1] = Math.max(s, l), void 0 === d[h = p[0] + "," + p[1]] && (d[h] = {
                    index1: p[0], index2: p[1]
                });
                for (h in d) o = d[h], c.fromBufferAttribute(v, o.index1), u.push(c.x, c.y, c.z), c.fromBufferAttribute(v, o.index2), u.push(c.x, c.y, c.z)
            } else for (t = 0, n = (v = e.attributes.position).count / 3; t < n; t++) for (i = 0; i < 3; i++) b = 3 * t + i, c.fromBufferAttribute(v, b), u.push(c.x, c.y, c.z), w = 3 * t + (i + 1) % 3, c.fromBufferAttribute(v, w), u.push(c.x, c.y, c.z)
        }
        this.addAttribute("position", new Wp(u, 3))
    }

    function pg(e, t, i) {
        Up.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: e, slices: t, stacks: i
        }, this.fromBufferGeometry(new dg(e, t, i)), this.mergeVertices()
    }

    function dg(e, t, i) {
        sd.call(this), this.type = "ParametricBufferGeometry", this.parameters = {func: e, slices: t, stacks: i};
        var n, r, a = [], o = [], s = [], l = [], h = new yu, c = new yu, u = new yu, p = new yu, d = new yu;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var f = t + 1;
        for (n = 0; n <= i; n++) {
            var m = n / i;
            for (r = 0; r <= t; r++) {
                var g = r / t;
                e(g, m, c), o.push(c.x, c.y, c.z), 0 <= g - 1e-5 ? (e(g - 1e-5, m, u), p.subVectors(c, u)) : (e(g + 1e-5, m, u), p.subVectors(u, c)), 0 <= m - 1e-5 ? (e(g, m - 1e-5, u), d.subVectors(c, u)) : (e(g, m + 1e-5, u), d.subVectors(u, c)), h.crossVectors(p, d).normalize(), s.push(h.x, h.y, h.z), l.push(g, m)
            }
        }
        for (n = 0; n < i; n++) for (r = 0; r < t; r++) {
            var v = n * f + r, y = n * f + r + 1, _ = (n + 1) * f + r + 1, x = (n + 1) * f + r;
            a.push(v, y, x), a.push(y, _, x)
        }
        this.setIndex(a), this.addAttribute("position", new Wp(o, 3)), this.addAttribute("normal", new Wp(s, 3)), this.addAttribute("uv", new Wp(l, 2))
    }

    function fg(e, t, i, n) {
        Up.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e, indices: t, radius: i, detail: n
        }, this.fromBufferGeometry(new mg(e, t, i, n)), this.mergeVertices()
    }

    function mg(n, a, e, t) {
        sd.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: n, indices: a, radius: e, detail: t
        }, e = e || 1;
        var c = [], u = [];

        function o(e, t, i, n) {
            var r, a, o = Math.pow(2, n), s = [];
            for (r = 0; r <= o; r++) {
                s[r] = [];
                var l = e.clone().lerp(i, r / o), h = t.clone().lerp(i, r / o), c = o - r;
                for (a = 0; a <= c; a++) s[r][a] = 0 === a && r === o ? l : l.clone().lerp(h, a / c)
            }
            for (r = 0; r < o; r++) for (a = 0; a < 2 * (o - r) - 1; a++) {
                var u = Math.floor(a / 2);
                a % 2 == 0 ? (p(s[r][u + 1]), p(s[r + 1][u]), p(s[r][u])) : (p(s[r][u + 1]), p(s[r + 1][u + 1]), p(s[r + 1][u]))
            }
        }

        function p(e) {
            c.push(e.x, e.y, e.z)
        }

        function s(e, t) {
            var i = 3 * e;
            t.x = n[i + 0], t.y = n[i + 1], t.z = n[i + 2]
        }

        function d(e, t, i, n) {
            n < 0 && 1 === e.x && (u[t] = e.x - 1), 0 === i.x && 0 === i.z && (u[t] = n / 2 / Math.PI + .5)
        }

        function f(e) {
            return Math.atan2(e.z, -e.x)
        }

        !function (e) {
            for (var t = new yu, i = new yu, n = new yu, r = 0; r < a.length; r += 3) s(a[r + 0], t), s(a[r + 1], i), s(a[r + 2], n), o(t, i, n, e)
        }(t = t || 0), function (e) {
            for (var t = new yu, i = 0; i < c.length; i += 3) t.x = c[i + 0], t.y = c[i + 1], t.z = c[i + 2], t.normalize().multiplyScalar(e), c[i + 0] = t.x, c[i + 1] = t.y, c[i + 2] = t.z
        }(e), function () {
            for (var e = new yu, t = 0; t < c.length; t += 3) {
                e.x = c[t + 0], e.y = c[t + 1], e.z = c[t + 2];
                var i = f(e) / 2 / Math.PI + .5,
                    n = (r = e, Math.atan2(-r.y, Math.sqrt(r.x * r.x + r.z * r.z)) / Math.PI + .5);
                u.push(i, 1 - n)
            }
            var r;
            (function () {
                for (var e = new yu, t = new yu, i = new yu, n = new yu, r = new mu, a = new mu, o = new mu, s = 0, l = 0; s < c.length; s += 9, l += 6) {
                    e.set(c[s + 0], c[s + 1], c[s + 2]), t.set(c[s + 3], c[s + 4], c[s + 5]), i.set(c[s + 6], c[s + 7], c[s + 8]), r.set(u[l + 0], u[l + 1]), a.set(u[l + 2], u[l + 3]), o.set(u[l + 4], u[l + 5]), n.copy(e).add(t).add(i).divideScalar(3);
                    var h = f(n);
                    d(r, l + 0, e, h), d(a, l + 2, t, h), d(o, l + 4, i, h)
                }
            })(), function () {
                for (var e = 0; e < u.length; e += 6) {
                    var t = u[e + 0], i = u[e + 2], n = u[e + 4], r = Math.max(t, i, n), a = Math.min(t, i, n);
                    .9 < r && a < .1 && (t < .2 && (u[e + 0] += 1), i < .2 && (u[e + 2] += 1), n < .2 && (u[e + 4] += 1))
                }
            }()
        }(), this.addAttribute("position", new Wp(c, 3)), this.addAttribute("normal", new Wp(c.slice(), 3)), this.addAttribute("uv", new Wp(u, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function gg(e, t) {
        Up.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e, detail: t
        }, this.fromBufferGeometry(new vg(e, t)), this.mergeVertices()
    }

    function vg(e, t) {
        mg.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: e, detail: t
        }
    }

    function yg(e, t) {
        Up.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: e, detail: t
        }, this.fromBufferGeometry(new _g(e, t)), this.mergeVertices()
    }

    function _g(e, t) {
        mg.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: e, detail: t
        }
    }

    function xg(e, t) {
        Up.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e, detail: t
        }, this.fromBufferGeometry(new bg(e, t)), this.mergeVertices()
    }

    function bg(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        mg.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: e, detail: t
        }
    }

    function wg(e, t) {
        Up.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e, detail: t
        }, this.fromBufferGeometry(new Tg(e, t)), this.mergeVertices()
    }

    function Tg(e, t) {
        var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
        mg.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: e, detail: t
        }
    }

    function Sg(e, t, i, n, r, a) {
        Up.call(this), this.type = "TubeGeometry", this.parameters = {
            path: e, tubularSegments: t, radius: i, radialSegments: n, closed: r
        }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
        var o = new Eg(e, t, i, n, r);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
    }

    function Eg(o, s, l, h, e) {
        sd.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: o, tubularSegments: s, radius: l, radialSegments: h, closed: e
        }, s = s || 64, l = l || 1, h = h || 8, e = e || !1;
        var c = o.computeFrenetFrames(s, e);
        this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals;
        var r, u, p = new yu, d = new yu, t = new mu, f = new yu, m = [], g = [], i = [], a = [];

        function n(e) {
            f = o.getPointAt(e / s, f);
            var t = c.normals[e], i = c.binormals[e];
            for (u = 0; u <= h; u++) {
                var n = u / h * Math.PI * 2, r = Math.sin(n), a = -Math.cos(n);
                d.x = a * t.x + r * i.x, d.y = a * t.y + r * i.y, d.z = a * t.z + r * i.z, d.normalize(), g.push(d.x, d.y, d.z), p.x = f.x + l * d.x, p.y = f.y + l * d.y, p.z = f.z + l * d.z, m.push(p.x, p.y, p.z)
            }
        }

        !function () {
            for (r = 0; r < s; r++) n(r);
            n(!1 === e ? s : 0), function () {
                for (r = 0; r <= s; r++) for (u = 0; u <= h; u++) t.x = r / s, t.y = u / h, i.push(t.x, t.y)
            }(), function () {
                for (u = 1; u <= s; u++) for (r = 1; r <= h; r++) {
                    var e = (h + 1) * (u - 1) + (r - 1), t = (h + 1) * u + (r - 1), i = (h + 1) * u + r,
                        n = (h + 1) * (u - 1) + r;
                    a.push(e, t, n), a.push(t, i, n)
                }
            }()
        }(), this.setIndex(a), this.addAttribute("position", new Wp(m, 3)), this.addAttribute("normal", new Wp(g, 3)), this.addAttribute("uv", new Wp(i, 2))
    }

    function Ag(e, t, i, n, r, a, o) {
        Up.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a
        }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Mg(e, t, i, n, r, a)), this.mergeVertices()
    }

    function Mg(e, t, i, n, r, a) {
        sd.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3;
        var o, s, l = [], h = [], c = [], u = [], p = new yu, d = new yu, f = new yu, m = new yu, g = new yu,
            v = new yu, y = new yu;
        for (o = 0; o <= i; ++o) {
            var _ = o / i * r * Math.PI * 2;
            for (M(_, r, a, e, f), M(_ + .01, r, a, e, m), v.subVectors(m, f), y.addVectors(m, f), g.crossVectors(v, y), y.crossVectors(g, v), g.normalize(), y.normalize(), s = 0; s <= n; ++s) {
                var x = s / n * Math.PI * 2, b = -t * Math.cos(x), w = t * Math.sin(x);
                p.x = f.x + (b * y.x + w * g.x), p.y = f.y + (b * y.y + w * g.y), p.z = f.z + (b * y.z + w * g.z), h.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), c.push(d.x, d.y, d.z), u.push(o / i), u.push(s / n)
            }
        }
        for (s = 1; s <= i; s++) for (o = 1; o <= n; o++) {
            var T = (n + 1) * (s - 1) + (o - 1), S = (n + 1) * s + (o - 1), E = (n + 1) * s + o,
                A = (n + 1) * (s - 1) + o;
            l.push(T, S, A), l.push(S, E, A)
        }

        function M(e, t, i, n, r) {
            var a = Math.cos(e), o = Math.sin(e), s = i / t * e, l = Math.cos(s);
            r.x = n * (2 + l) * .5 * a, r.y = n * (2 + l) * o * .5, r.z = n * Math.sin(s) * .5
        }

        this.setIndex(l), this.addAttribute("position", new Wp(h, 3)), this.addAttribute("normal", new Wp(c, 3)), this.addAttribute("uv", new Wp(u, 2))
    }

    function Pg(e, t, i, n, r) {
        Up.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r
        }, this.fromBufferGeometry(new Lg(e, t, i, n, r)), this.mergeVertices()
    }

    function Lg(e, t, i, n, r) {
        sd.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r
        }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
        var a, o, s = [], l = [], h = [], c = [], u = new yu, p = new yu, d = new yu;
        for (a = 0; a <= i; a++) for (o = 0; o <= n; o++) {
            var f = o / n * r, m = a / i * Math.PI * 2;
            p.x = (e + t * Math.cos(m)) * Math.cos(f), p.y = (e + t * Math.cos(m)) * Math.sin(f), p.z = t * Math.sin(m), l.push(p.x, p.y, p.z), u.x = e * Math.cos(f), u.y = e * Math.sin(f), d.subVectors(p, u).normalize(), h.push(d.x, d.y, d.z), c.push(o / n), c.push(a / i)
        }
        for (a = 1; a <= i; a++) for (o = 1; o <= n; o++) {
            var g = (n + 1) * a + o - 1, v = (n + 1) * (a - 1) + o - 1, y = (n + 1) * (a - 1) + o, _ = (n + 1) * a + o;
            s.push(g, v, _), s.push(v, y, _)
        }
        this.setIndex(s), this.addAttribute("position", new Wp(l, 3)), this.addAttribute("normal", new Wp(h, 3)), this.addAttribute("uv", new Wp(c, 2))
    }

    ((Im.prototype = Object.create(Dd.prototype)).constructor = Im).prototype.isMeshDepthMaterial = !0, Im.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }, ((Rm.prototype = Object.create(Dd.prototype)).constructor = Rm).prototype.isMeshDistanceMaterial = !0, Rm.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }, Um.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: Um, isGroup: !0
    }), Dm.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: Dm, isCamera: !0, copy: function (e, t) {
            return Pp.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
        }, getWorldDirection: function (e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new yu), this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        }, updateMatrixWorld: function (e) {
            Pp.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }
    }), zm.prototype = Object.assign(Object.create(Dm.prototype), {
        constructor: zm, isPerspectiveCamera: !0, copy: function (e, t) {
            return Dm.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
        }, setFocalLength: function (e) {
            var t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * fu.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        }, getFocalLength: function () {
            var e = Math.tan(.5 * fu.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        }, getEffectiveFOV: function () {
            return 2 * fu.RAD2DEG * Math.atan(Math.tan(.5 * fu.DEG2RAD * this.fov) / this.zoom)
        }, getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        }, getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        }, setViewOffset: function (e, t, i, n, r, a) {
            this.aspect = e / t, null === this.view && (this.view = {
                enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var e = this.near, t = e * Math.tan(.5 * fu.DEG2RAD * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i,
                r = -.5 * n, a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth, s = a.fullHeight;
                r += a.offsetX * n / o, t -= a.offsetY * i / s, n *= a.width / o, i *= a.height / s
            }
            var l = this.filmOffset;
            0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        }, toJSON: function (e) {
            var t = Pp.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }), Bm.prototype = Object.assign(Object.create(zm.prototype), {
        constructor: Bm, isArrayCamera: !0
    }), Vm.prototype.isFogExp2 = !0, Vm.prototype.clone = function () {
        return new Vm(this.color, this.density)
    }, Vm.prototype.toJSON = function () {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    }, Xm.prototype.isFog = !0, Xm.prototype.clone = function () {
        return new Xm(this.color, this.near, this.far)
    }, Xm.prototype.toJSON = function () {
        return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
    }, Wm.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: Wm, copy: function (e, t) {
            return Pp.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
        }, toJSON: function (e) {
            var t = Pp.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
        }
    }), Object.defineProperty(Ym.prototype, "needsUpdate", {
        set: function (e) {
            !0 === e && this.version++
        }
    }), Object.assign(Ym.prototype, {
        isInterleavedBuffer: !0, onUploadCallback: function () {
        }, setArray: function (e) {
            if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
        }, setDynamic: function (e) {
            return this.dynamic = e, this
        }, copy: function (e) {
            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
        }, copyAt: function (e, t, i) {
            e *= this.stride, i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
            return this
        }, set: function (e, t) {
            return void 0 === t && (t = 0), this.array.set(e, t), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, onUpload: function (e) {
            return this.onUploadCallback = e, this
        }
    }), Object.defineProperties(qm.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        }, array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(qm.prototype, {
        isInterleavedBufferAttribute: !0, setX: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t, this
        }, setY: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t, this
        }, setZ: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t, this
        }, setW: function (e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t, this
        }, getX: function (e) {
            return this.data.array[e * this.data.stride + this.offset]
        }, getY: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        }, getZ: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        }, getW: function (e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        }, setXY: function (e, t, i) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
        }, setXYZ: function (e, t, i, n) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this
        }, setXYZW: function (e, t, i, n, r) {
            return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this
        }
    }), ((Qm.prototype = Object.create(Dd.prototype)).constructor = Qm).prototype.isSpriteMaterial = !0, Qm.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
    }, Zm.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: Zm, isSprite: !0, raycast: function () {
            var l = new yu, h = new yu, c = new yu, o = new mu, s = new mu, u = new gu, p = new yu, d = new yu,
                f = new yu, m = new mu, g = new mu, v = new mu;

            function y(e, t, i, n, r, a) {
                o.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = a * o.x - r * o.y, s.y = r * o.x + a * o.y) : s.copy(o), e.copy(t), e.x += s.x, e.y += s.y, e.applyMatrix4(u)
            }

            return function (e, t) {
                h.setFromMatrixScale(this.matrixWorld), u.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), c.setFromMatrixPosition(this.modelViewMatrix);
                var i, n, r = this.material.rotation;
                0 !== r && (n = Math.cos(r), i = Math.sin(r));
                var a = this.center;
                y(p.set(-.5, -.5, 0), c, a, h, i, n), y(d.set(.5, -.5, 0), c, a, h, i, n), y(f.set(.5, .5, 0), c, a, h, i, n), m.set(0, 0), g.set(1, 0), v.set(1, 1);
                var o = e.ray.intersectTriangle(p, d, f, !1, l);
                if (null !== o || (y(d.set(-.5, .5, 0), c, a, h, i, n), g.set(0, 1), null !== (o = e.ray.intersectTriangle(p, f, d, !1, l)))) {
                    var s = e.ray.origin.distanceTo(l);
                    s < e.near || s > e.far || t.push({
                        distance: s,
                        point: l.clone(),
                        uv: Hd.getUV(l, p, d, f, m, g, v, new mu),
                        face: null,
                        object: this
                    })
                }
            }
        }(), clone: function () {
            return new this.constructor(this.material).copy(this)
        }, copy: function (e) {
            return Pp.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
        }
    }), Jm.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: Jm, copy: function (e) {
            Pp.prototype.copy.call(this, e, !1);
            for (var t = e.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this
        }, addLevel: function (e, t) {
            void 0 === t && (t = 0), t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++) ;
            i.splice(n, 0, {distance: t, object: e}), this.add(e)
        }, getObjectForDistance: function (e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++) ;
            return t[i - 1].object
        }, raycast: (fm = new yu, function (e, t) {
            fm.setFromMatrixPosition(this.matrixWorld);
            var i = e.ray.origin.distanceTo(fm);
            this.getObjectForDistance(i).raycast(e, t)
        }), update: (pm = new yu, dm = new yu, function (e) {
            var t = this.levels;
            if (1 < t.length) {
                pm.setFromMatrixPosition(e.matrixWorld), dm.setFromMatrixPosition(this.matrixWorld);
                var i = pm.distanceTo(dm);
                t[0].object.visible = !0;
                for (var n = 1, r = t.length; n < r && i >= t[n].distance; n++) t[n - 1].object.visible = !1, t[n].object.visible = !0;
                for (; n < r; n++) t[n].object.visible = !1
            }
        }), toJSON: function (e) {
            var t = Pp.prototype.toJSON.call(this, e);
            t.object.levels = [];
            for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
                var a = i[n];
                t.object.levels.push({object: a.object.uuid, distance: a.distance})
            }
            return t
        }
    }), Object.assign(Km.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new gu;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
            }
        }, pose: function () {
            var e, t, i;
            for (t = 0, i = this.bones.length; t < i; t++) (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0, i = this.bones.length; t < i; t++) (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        }, update: (mm = new gu, gm = new gu, function () {
            for (var e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = e.length; r < a; r++) {
                var o = e[r] ? e[r].matrixWorld : gm;
                mm.multiplyMatrices(o, t[r]), mm.toArray(i, 16 * r)
            }
            void 0 !== n && (n.needsUpdate = !0)
        }), clone: function () {
            return new Km(this.bones, this.boneInverses)
        }, getBoneByName: function (e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e) return n
            }
        }
    }), $m.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: $m, isBone: !0
    }), eg.prototype = Object.assign(Object.create(jd.prototype), {
        constructor: eg, isSkinnedMesh: !0, initBones: function () {
            var e, t, i, n, r = [];
            if (this.geometry && void 0 !== this.geometry.bones) {
                for (i = 0, n = this.geometry.bones.length; i < n; i++) t = this.geometry.bones[i], e = new $m, r.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
                for (i = 0, n = this.geometry.bones.length; i < n; i++) -1 !== (t = this.geometry.bones[i]).parent && null !== t.parent && void 0 !== r[t.parent] ? r[t.parent].add(r[i]) : this.add(r[i])
            }
            return this.updateMatrixWorld(!0), r
        }, bind: function (e, t) {
            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
        }, pose: function () {
            this.skeleton.pose()
        }, normalizeSkinWeights: function () {
            var e, t;
            if (this.geometry && this.geometry.isGeometry) for (t = 0; t < this.geometry.skinWeights.length; t++) {
                var i = this.geometry.skinWeights[t];
                (e = 1 / i.manhattanLength()) !== 1 / 0 ? i.multiplyScalar(e) : i.set(1, 0, 0, 0)
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var n = new zu, r = this.geometry.attributes.skinWeight;
                for (t = 0; t < r.count; t++) n.x = r.getX(t), n.y = r.getY(t), n.z = r.getZ(t), n.w = r.getW(t), (e = 1 / n.manhattanLength()) !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0), r.setXYZW(t, n.x, n.y, n.z, n.w)
            }
        }, updateMatrixWorld: function (e) {
            jd.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        }, clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), ((tg.prototype = Object.create(Dd.prototype)).constructor = tg).prototype.isLineBasicMaterial = !0, tg.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
    }, ig.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: ig, isLine: !0, computeLineDistances: (xm = new yu, bm = new yu, function () {
            var e = this.geometry;
            if (e.isBufferGeometry) if (null === e.index) {
                for (var t = e.attributes.position, i = [0], n = 1, r = t.count; n < r; n++) xm.fromBufferAttribute(t, n - 1), bm.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += xm.distanceTo(bm);
                e.addAttribute("lineDistance", new Wp(i, 1))
            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (e.isGeometry) {
                var a = e.vertices;
                for ((i = e.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++) i[n] = i[n - 1], i[n] += a[n - 1].distanceTo(a[n])
            }
            return this
        }), raycast: (vm = new gu, ym = new Bd, _m = new Vu, function (e, t) {
            var i = e.linePrecision, n = this.geometry, r = this.matrixWorld;
            if (null === n.boundingSphere && n.computeBoundingSphere(), _m.copy(n.boundingSphere), _m.applyMatrix4(r), _m.radius += i, !1 !== e.ray.intersectsSphere(_m)) {
                vm.getInverse(r), ym.copy(e.ray).applyMatrix4(vm);
                var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3), o = a * a, s = new yu, l = new yu,
                    h = new yu, c = new yu, u = this && this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var p = n.index, d = n.attributes.position.array;
                    if (null !== p) for (var f = p.array, m = 0, g = f.length - 1; m < g; m += u) {
                        var v = f[m], y = f[m + 1];
                        s.fromArray(d, 3 * v), l.fromArray(d, 3 * y), o < ym.distanceSqToSegment(s, l, c, h) || (c.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(c)) < e.near || b > e.far || t.push({
                            distance: b,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: m,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    } else for (m = 0, g = d.length / 3 - 1; m < g; m += u) s.fromArray(d, 3 * m), l.fromArray(d, 3 * m + 3), o < ym.distanceSqToSegment(s, l, c, h) || (c.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(c)) < e.near || b > e.far || t.push({
                        distance: b,
                        point: h.clone().applyMatrix4(this.matrixWorld),
                        index: m,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
                } else if (n.isGeometry) {
                    var _ = n.vertices, x = _.length;
                    for (m = 0; m < x - 1; m += u) {
                        var b;
                        o < ym.distanceSqToSegment(_[m], _[m + 1], c, h) || (c.applyMatrix4(this.matrixWorld), (b = e.ray.origin.distanceTo(c)) < e.near || b > e.far || t.push({
                            distance: b,
                            point: h.clone().applyMatrix4(this.matrixWorld),
                            index: m,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    }
                }
            }
        }), clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), ng.prototype = Object.assign(Object.create(ig.prototype), {
        constructor: ng, isLineSegments: !0, computeLineDistances: (wm = new yu, Tm = new yu, function () {
            var e = this.geometry;
            if (e.isBufferGeometry) if (null === e.index) {
                for (var t = e.attributes.position, i = [], n = 0, r = t.count; n < r; n += 2) wm.fromBufferAttribute(t, n), Tm.fromBufferAttribute(t, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + wm.distanceTo(Tm);
                e.addAttribute("lineDistance", new Wp(i, 1))
            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (e.isGeometry) {
                var a = e.vertices;
                for (i = e.lineDistances, n = 0, r = a.length; n < r; n += 2) wm.copy(a[n]), Tm.copy(a[n + 1]), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + wm.distanceTo(Tm)
            }
            return this
        })
    }), rg.prototype = Object.assign(Object.create(ig.prototype), {
        constructor: rg, isLineLoop: !0
    }), ((ag.prototype = Object.create(Dd.prototype)).constructor = ag).prototype.isPointsMaterial = !0, ag.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
    }, og.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: og, isPoints: !0, raycast: (Sm = new gu, Em = new Bd, Am = new Vu, function (r, a) {
            var o = this, e = this.geometry, s = this.matrixWorld, t = r.params.Points.threshold;
            if (null === e.boundingSphere && e.computeBoundingSphere(), Am.copy(e.boundingSphere), Am.applyMatrix4(s), Am.radius += t, !1 !== r.ray.intersectsSphere(Am)) {
                Sm.getInverse(s), Em.copy(r.ray).applyMatrix4(Sm);
                var i = t / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = i * i, n = new yu, h = new yu;
                if (e.isBufferGeometry) {
                    var c = e.index, u = e.attributes.position.array;
                    if (null !== c) for (var p = c.array, d = 0, f = p.length; d < f; d++) {
                        var m = p[d];
                        n.fromArray(u, 3 * m), y(n, m)
                    } else {
                        d = 0;
                        for (var g = u.length / 3; d < g; d++) n.fromArray(u, 3 * d), y(n, d)
                    }
                } else {
                    var v = e.vertices;
                    for (d = 0, g = v.length; d < g; d++) y(v[d], d)
                }
            }

            function y(e, t) {
                var i = Em.distanceSqToPoint(e);
                if (i < l) {
                    Em.closestPointToPoint(e, h), h.applyMatrix4(s);
                    var n = r.ray.origin.distanceTo(h);
                    if (n < r.near || n > r.far) return;
                    a.push({
                        distance: n, distanceToRay: Math.sqrt(i), point: h.clone(), index: t, face: null, object: o
                    })
                }
            }
        }), clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), sg.prototype = Object.assign(Object.create(Du.prototype), {
        constructor: sg, isVideoTexture: !0, update: function () {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), ((lg.prototype = Object.create(Du.prototype)).constructor = lg).prototype.isCompressedTexture = !0, ((hg.prototype = Object.create(Du.prototype)).constructor = hg).prototype.isCanvasTexture = !0, ((cg.prototype = Object.create(Du.prototype)).constructor = cg).prototype.isDepthTexture = !0, (ug.prototype = Object.create(sd.prototype)).constructor = ug, (pg.prototype = Object.create(Up.prototype)).constructor = pg, (dg.prototype = Object.create(sd.prototype)).constructor = dg, (fg.prototype = Object.create(Up.prototype)).constructor = fg, (mg.prototype = Object.create(sd.prototype)).constructor = mg, (gg.prototype = Object.create(Up.prototype)).constructor = gg, (vg.prototype = Object.create(mg.prototype)).constructor = vg, (yg.prototype = Object.create(Up.prototype)).constructor = yg, (_g.prototype = Object.create(mg.prototype)).constructor = _g, (xg.prototype = Object.create(Up.prototype)).constructor = xg, (bg.prototype = Object.create(mg.prototype)).constructor = bg, (wg.prototype = Object.create(Up.prototype)).constructor = wg, (Tg.prototype = Object.create(mg.prototype)).constructor = Tg, (Sg.prototype = Object.create(Up.prototype)).constructor = Sg, (Eg.prototype = Object.create(sd.prototype)).constructor = Eg, (Ag.prototype = Object.create(Up.prototype)).constructor = Ag, (Mg.prototype = Object.create(sd.prototype)).constructor = Mg, (Pg.prototype = Object.create(Up.prototype)).constructor = Pg, (Lg.prototype = Object.create(sd.prototype)).constructor = Lg;
    var Cg = function (e, t, i) {
        i = i || 2;
        var n, r, a, o, s, l, h, c = t && t.length, u = c ? t[0] * i : e.length, p = Ig(e, 0, u, i, !0), d = [];
        if (!p) return d;
        if (c && (p = function (e, t, i, n) {
            var r, a, o, s, l, h = [];
            for (r = 0, a = t.length; r < a; r++) o = t[r] * n, s = r < a - 1 ? t[r + 1] * n : e.length, (l = Ig(e, o, s, n, !1)) === l.next && (l.steiner = !0), h.push(Hg(l));
            for (h.sort(Dg), r = 0; r < h.length; r++) zg(h[r], i), i = Rg(i, i.next);
            return i
        }(e, t, p, i)), e.length > 80 * i) {
            n = a = e[0], r = o = e[1];
            for (var f = i; f < u; f += i) (s = e[f]) < n && (n = s), (l = e[f + 1]) < r && (r = l), a < s && (a = s), o < l && (o = l);
            h = 0 !== (h = Math.max(a - n, o - r)) ? 1 / h : 0
        }
        return Og(p, d, i, n, r, h), d
    };

    function Ig(e, t, i, n, r) {
        var a, o;
        if (r === 0 < function (e, t, i, n) {
            for (var r = 0, a = t, o = i - n; a < i; a += n) r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
            return r
        }(e, t, i, n)) for (a = t; a < i; a += n) o = qg(a, e[a], e[a + 1], o); else for (a = i - n; t <= a; a -= n) o = qg(a, e[a], e[a + 1], o);
        return o && Vg(o, o.next) && (Qg(o), o = o.next), o
    }

    function Rg(e, t) {
        if (!e) return e;
        t || (t = e);
        var i, n = e;
        do {
            if (i = !1, n.steiner || !Vg(n, n.next) && 0 !== jg(n.prev, n, n.next)) n = n.next; else {
                if (Qg(n), (n = t = n.prev) === n.next) break;
                i = !0
            }
        } while (i || n !== t);
        return t
    }

    function Og(e, t, i, n, r, a, o) {
        if (e) {
            !o && a && function (e, t, i, n) {
                var r = e;
                for (; null === r.z && (r.z = Bg(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next, r !== e;) ;
                r.prevZ.nextZ = null, r.prevZ = null, function (e) {
                    var t, i, n, r, a, o, s, l, h = 1;
                    do {
                        for (i = e, a = e = null, o = 0; i;) {
                            for (o++, n = i, t = s = 0; t < h && (s++, n = n.nextZ); t++) ;
                            for (l = h; 0 < s || 0 < l && n;) 0 !== s && (0 === l || !n || i.z <= n.z) ? (i = (r = i).nextZ, s--) : (n = (r = n).nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                            i = n
                        }
                        a.nextZ = null, h *= 2
                    } while (1 < o)
                }(r)
            }(e, n, r, a);
            for (var s, l, h = e; e.prev !== e.next;) if (s = e.prev, l = e.next, a ? Ng(e, n, r, a) : Fg(e)) t.push(s.i / i), t.push(e.i / i), t.push(l.i / i), Qg(e), e = l.next, h = l.next; else if ((e = l) === h) {
                o ? 1 === o ? Og(e = kg(e, t, i), t, i, n, r, a, 2) : 2 === o && Ug(e, t, i, n, r, a) : Og(Rg(e), t, i, n, r, a, 1);
                break
            }
        }
    }

    function Fg(e) {
        var t = e.prev, i = e, n = e.next;
        if (0 <= jg(t, i, n)) return !1;
        for (var r = e.next.next; r !== e.prev;) {
            if (Gg(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= jg(r.prev, r, r.next)) return !1;
            r = r.next
        }
        return !0
    }

    function Ng(e, t, i, n) {
        var r = e.prev, a = e, o = e.next;
        if (0 <= jg(r, a, o)) return !1;
        for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, h = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, c = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u = Bg(s, l, t, i, n), p = Bg(h, c, t, i, n), d = e.nextZ; d && d.z <= p;) {
            if (d !== e.prev && d !== e.next && Gg(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= jg(d.prev, d, d.next)) return !1;
            d = d.nextZ
        }
        for (d = e.prevZ; d && d.z >= u;) {
            if (d !== e.prev && d !== e.next && Gg(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) && 0 <= jg(d.prev, d, d.next)) return !1;
            d = d.prevZ
        }
        return !0
    }

    function kg(e, t, i) {
        var n = e;
        do {
            var r = n.prev, a = n.next.next;
            !Vg(r, a) && Xg(r, n, n.next, a) && Wg(r, a) && Wg(a, r) && (t.push(r.i / i), t.push(n.i / i), t.push(a.i / i), Qg(n), Qg(n.next), n = e = a), n = n.next
        } while (n !== e);
        return n
    }

    function Ug(e, t, i, n, r, a) {
        var o, s, l = e;
        do {
            for (var h = l.next.next; h !== l.prev;) {
                if (l.i !== h.i && (s = h, (o = l).next.i !== s.i && o.prev.i !== s.i && !function (e, t) {
                    var i = e;
                    do {
                        if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && Xg(i, i.next, e, t)) return !0;
                        i = i.next
                    } while (i !== e);
                    return !1
                }(o, s) && Wg(o, s) && Wg(s, o) && function (e, t) {
                    var i = e, n = !1, r = (e.x + t.x) / 2, a = (e.y + t.y) / 2;
                    for (; i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== e;) ;
                    return n
                }(o, s))) {
                    var c = Yg(l, h);
                    return l = Rg(l, l.next), c = Rg(c, c.next), Og(l, t, i, n, r, a), void Og(c, t, i, n, r, a)
                }
                h = h.next
            }
            l = l.next
        } while (l !== e)
    }

    function Dg(e, t) {
        return e.x - t.x
    }

    function zg(e, t) {
        if (t = function (e, t) {
            var i, n = t, r = e.x, a = e.y, o = -1 / 0;
            do {
                if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
                    var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                    if (s <= r && o < s) {
                        if ((o = s) === r) {
                            if (a === n.y) return n;
                            if (a === n.next.y) return n.next
                        }
                        i = n.x < n.next.x ? n : n.next
                    }
                }
                n = n.next
            } while (n !== t);
            if (!i) return null;
            if (r === o) return i.prev;
            var l, h = i, c = i.x, u = i.y, p = 1 / 0;
            n = i.next;
            for (; n !== h;) r >= n.x && n.x >= c && r !== n.x && Gg(a < u ? r : o, a, c, u, a < u ? o : r, a, n.x, n.y) && ((l = Math.abs(a - n.y) / (r - n.x)) < p || l === p && n.x > i.x) && Wg(n, e) && (i = n, p = l), n = n.next;
            return i
        }(e, t)) {
            var i = Yg(t, e);
            Rg(i, i.next)
        }
    }

    function Bg(e, t, i, n, r) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }

    function Hg(e) {
        for (var t = e, i = e; t.x < i.x && (i = t), (t = t.next) !== e;) ;
        return i
    }

    function Gg(e, t, i, n, r, a, o, s) {
        return 0 <= (r - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (n - s) - (i - o) * (t - s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
    }

    function jg(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }

    function Vg(e, t) {
        return e.x === t.x && e.y === t.y
    }

    function Xg(e, t, i, n) {
        return !!(Vg(e, t) && Vg(i, n) || Vg(e, n) && Vg(i, t)) || 0 < jg(e, t, i) != 0 < jg(e, t, n) && 0 < jg(i, n, e) != 0 < jg(i, n, t)
    }

    function Wg(e, t) {
        return jg(e.prev, e, e.next) < 0 ? 0 <= jg(e, t, e.next) && 0 <= jg(e, e.prev, t) : jg(e, t, e.prev) < 0 || jg(e, e.next, t) < 0
    }

    function Yg(e, t) {
        var i = new Zg(e.i, e.x, e.y), n = new Zg(t.i, t.x, t.y), r = e.next, a = t.prev;
        return (e.next = t).prev = e, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n).prev = a, n
    }

    function qg(e, t, i, n) {
        var r = new Zg(e, t, i);
        return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r, r
    }

    function Qg(e) {
        e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }

    function Zg(e, t, i) {
        this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }

    var Jg = {
        area: function (e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        }, isClockWise: function (e) {
            return Jg.area(e) < 0
        }, triangulateShape: function (e, t) {
            var i = [], n = [], r = [];
            Kg(e), $g(i, e);
            var a = e.length;
            t.forEach(Kg);
            for (var o = 0; o < t.length; o++) n.push(a), a += t[o].length, $g(i, t[o]);
            var s = Cg(i, n);
            for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
            return r
        }
    };

    function Kg(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }

    function $g(e, t) {
        for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y)
    }

    function ev(e, t) {
        Up.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e, options: t
        }, this.fromBufferGeometry(new tv(e, t)), this.mergeVertices()
    }

    function tv(e, Z) {
        sd.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: e, options: Z
        }, e = Array.isArray(e) ? e : [e];
        for (var J = this, K = [], $ = [], t = 0, i = e.length; t < i; t++) {
            n(e[t])
        }

        function n(e) {
            var n = [], t = void 0 !== Z.curveSegments ? Z.curveSegments : 12, l = void 0 !== Z.steps ? Z.steps : 1,
                i = void 0 !== Z.depth ? Z.depth : 100, r = void 0 === Z.bevelEnabled || Z.bevelEnabled,
                a = void 0 !== Z.bevelThickness ? Z.bevelThickness : 6,
                o = void 0 !== Z.bevelSize ? Z.bevelSize : a - 2, h = void 0 !== Z.bevelSegments ? Z.bevelSegments : 3,
                s = Z.extrudePath, c = void 0 !== Z.UVGenerator ? Z.UVGenerator : iv;
            void 0 !== Z.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = Z.amount);
            var u, p, d, f, m, g, v, y, _ = !1;
            s && (u = s.getSpacedPoints(l), r = !(_ = !0), p = s.computeFrenetFrames(l, !1), d = new yu, f = new yu, m = new yu), r || (o = a = h = 0);
            var x = e.extractPoints(t), b = x.shape, w = x.holes;
            if (!Jg.isClockWise(b)) for (b = b.reverse(), v = 0, y = w.length; v < y; v++) g = w[v], Jg.isClockWise(g) && (w[v] = g.reverse());
            var T = Jg.triangulateShape(b, w), S = b;
            for (v = 0, y = w.length; v < y; v++) g = w[v], b = b.concat(g);

            function E(e, t, i) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
            }

            var A, M, P, L, C, I, R = b.length, O = T.length;

            function F(e, t, i) {
                var n, r, a, o = e.x - t.x, s = e.y - t.y, l = i.x - e.x, h = i.y - e.y, c = o * o + s * s,
                    u = o * h - s * l;
                if (Math.abs(u) > Number.EPSILON) {
                    var p = Math.sqrt(c), d = Math.sqrt(l * l + h * h), f = t.x - s / p, m = t.y + o / p,
                        g = ((i.x - h / d - f) * h - (i.y + l / d - m) * l) / (o * h - s * l),
                        v = (n = f + o * g - e.x) * n + (r = m + s * g - e.y) * r;
                    if (v <= 2) return new mu(n, r);
                    a = Math.sqrt(v / 2)
                } else {
                    var y = !1;
                    o > Number.EPSILON ? l > Number.EPSILON && (y = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(h) && (y = !0), a = y ? (n = -s, r = o, Math.sqrt(c)) : (n = o, r = s, Math.sqrt(c / 2))
                }
                return new mu(n / a, r / a)
            }

            for (var N = [], k = 0, U = S.length, D = U - 1, z = k + 1; k < U; k++, D++, z++) D === U && (D = 0), z === U && (z = 0), N[k] = F(S[k], S[D], S[z]);
            var B, H, G = [], j = N.concat();
            for (v = 0, y = w.length; v < y; v++) {
                for (g = w[v], B = [], k = 0, D = (U = g.length) - 1, z = k + 1; k < U; k++, D++, z++) D === U && (D = 0), z === U && (z = 0), B[k] = F(g[k], g[D], g[z]);
                G.push(B), j = j.concat(B)
            }
            for (A = 0; A < h; A++) {
                for (P = A / h, L = a * Math.cos(P * Math.PI / 2), M = o * Math.sin(P * Math.PI / 2), k = 0, U = S.length; k < U; k++) X((C = E(S[k], N[k], M)).x, C.y, -L);
                for (v = 0, y = w.length; v < y; v++) for (g = w[v], B = G[v], k = 0, U = g.length; k < U; k++) X((C = E(g[k], B[k], M)).x, C.y, -L)
            }
            for (M = o, k = 0; k < R; k++) C = r ? E(b[k], j[k], M) : b[k], _ ? (f.copy(p.normals[0]).multiplyScalar(C.x), d.copy(p.binormals[0]).multiplyScalar(C.y), m.copy(u[0]).add(f).add(d), X(m.x, m.y, m.z)) : X(C.x, C.y, 0);
            for (H = 1; H <= l; H++) for (k = 0; k < R; k++) C = r ? E(b[k], j[k], M) : b[k], _ ? (f.copy(p.normals[H]).multiplyScalar(C.x), d.copy(p.binormals[H]).multiplyScalar(C.y), m.copy(u[H]).add(f).add(d), X(m.x, m.y, m.z)) : X(C.x, C.y, i / l * H);
            for (A = h - 1; 0 <= A; A--) {
                for (P = A / h, L = a * Math.cos(P * Math.PI / 2), M = o * Math.sin(P * Math.PI / 2), k = 0, U = S.length; k < U; k++) X((C = E(S[k], N[k], M)).x, C.y, i + L);
                for (v = 0, y = w.length; v < y; v++) for (g = w[v], B = G[v], k = 0, U = g.length; k < U; k++) C = E(g[k], B[k], M), _ ? X(C.x, C.y + u[l - 1].y, u[l - 1].x + L) : X(C.x, C.y, i + L)
            }

            function V(e, t) {
                var i, n;
                for (k = e.length; 0 <= --k;) {
                    (n = (i = k) - 1) < 0 && (n = e.length - 1);
                    var r = 0, a = l + 2 * h;
                    for (r = 0; r < a; r++) {
                        var o = R * r, s = R * (r + 1);
                        Y(t + i + o, t + n + o, t + n + s, t + i + s)
                    }
                }
            }

            function X(e, t, i) {
                n.push(e), n.push(t), n.push(i)
            }

            function W(e, t, i) {
                q(e), q(t), q(i);
                var n = K.length / 3, r = c.generateTopUV(J, K, n - 3, n - 2, n - 1);
                Q(r[0]), Q(r[1]), Q(r[2])
            }

            function Y(e, t, i, n) {
                q(e), q(t), q(n), q(t), q(i), q(n);
                var r = K.length / 3, a = c.generateSideWallUV(J, K, r - 6, r - 3, r - 2, r - 1);
                Q(a[0]), Q(a[1]), Q(a[3]), Q(a[1]), Q(a[2]), Q(a[3])
            }

            function q(e) {
                K.push(n[3 * e + 0]), K.push(n[3 * e + 1]), K.push(n[3 * e + 2])
            }

            function Q(e) {
                $.push(e.x), $.push(e.y)
            }

            !function () {
                var e = K.length / 3;
                if (r) {
                    var t = 0, i = R * t;
                    for (k = 0; k < O; k++) W((I = T[k])[2] + i, I[1] + i, I[0] + i);
                    for (i = R * (t = l + 2 * h), k = 0; k < O; k++) W((I = T[k])[0] + i, I[1] + i, I[2] + i)
                } else {
                    for (k = 0; k < O; k++) W((I = T[k])[2], I[1], I[0]);
                    for (k = 0; k < O; k++) W((I = T[k])[0] + R * l, I[1] + R * l, I[2] + R * l)
                }
                J.addGroup(e, K.length / 3 - e, 0)
            }(), function () {
                var e = K.length / 3, t = 0;
                for (V(S, t), t += S.length, v = 0, y = w.length; v < y; v++) V(g = w[v], t), t += g.length;
                J.addGroup(e, K.length / 3 - e, 1)
            }()
        }

        this.addAttribute("position", new Wp(K, 3)), this.addAttribute("uv", new Wp($, 2)), this.computeVertexNormals()
    }

    ((ev.prototype = Object.create(Up.prototype)).constructor = ev).prototype.toJSON = function () {
        var e = Up.prototype.toJSON.call(this);
        return nv(this.parameters.shapes, this.parameters.options, e)
    }, ((tv.prototype = Object.create(sd.prototype)).constructor = tv).prototype.toJSON = function () {
        var e = sd.prototype.toJSON.call(this);
        return nv(this.parameters.shapes, this.parameters.options, e)
    };
    var iv = {
        generateTopUV: function (e, t, i, n, r) {
            var a = t[3 * i], o = t[3 * i + 1], s = t[3 * n], l = t[3 * n + 1], h = t[3 * r], c = t[3 * r + 1];
            return [new mu(a, o), new mu(s, l), new mu(h, c)]
        }, generateSideWallUV: function (e, t, i, n, r, a) {
            var o = t[3 * i], s = t[3 * i + 1], l = t[3 * i + 2], h = t[3 * n], c = t[3 * n + 1], u = t[3 * n + 2],
                p = t[3 * r], d = t[3 * r + 1], f = t[3 * r + 2], m = t[3 * a], g = t[3 * a + 1], v = t[3 * a + 2];
            return Math.abs(s - c) < .01 ? [new mu(o, 1 - l), new mu(h, 1 - u), new mu(p, 1 - f), new mu(m, 1 - v)] : [new mu(s, 1 - l), new mu(c, 1 - u), new mu(d, 1 - f), new mu(g, 1 - v)]
        }
    };

    function nv(e, t, i) {
        if (i.shapes = [], Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) {
            var a = e[n];
            i.shapes.push(a.uuid)
        } else i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i
    }

    function rv(e, t) {
        Up.call(this), this.type = "TextGeometry", this.parameters = {
            text: e, parameters: t
        }, this.fromBufferGeometry(new av(e, t)), this.mergeVertices()
    }

    function av(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new Up;
        var n = i.generateShapes(e, t.size);
        t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), tv.call(this, n, t), this.type = "TextBufferGeometry"
    }

    function ov(e, t, i, n, r, a, o) {
        Up.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o
        }, this.fromBufferGeometry(new sv(e, t, i, n, r, a, o)), this.mergeVertices()
    }

    function sv(e, t, i, n, r, a, o) {
        sd.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o
        }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var s, l, h = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI), c = 0, u = [], p = new yu,
            d = new yu, f = [], m = [], g = [], v = [];
        for (l = 0; l <= i; l++) {
            var y = [], _ = l / i;
            for (s = 0; s <= t; s++) {
                var x = s / t;
                p.x = -e * Math.cos(n + x * r) * Math.sin(a + _ * o), p.y = e * Math.cos(a + _ * o), p.z = e * Math.sin(n + x * r) * Math.sin(a + _ * o), m.push(p.x, p.y, p.z), d.set(p.x, p.y, p.z).normalize(), g.push(d.x, d.y, d.z), v.push(x, 1 - _), y.push(c++)
            }
            u.push(y)
        }
        for (l = 0; l < i; l++) for (s = 0; s < t; s++) {
            var b = u[l][s + 1], w = u[l][s], T = u[l + 1][s], S = u[l + 1][s + 1];
            (0 !== l || 0 < a) && f.push(b, w, S), (l !== i - 1 || h < Math.PI) && f.push(w, T, S)
        }
        this.setIndex(f), this.addAttribute("position", new Wp(m, 3)), this.addAttribute("normal", new Wp(g, 3)), this.addAttribute("uv", new Wp(v, 2))
    }

    function lv(e, t, i, n, r, a) {
        Up.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a
        }, this.fromBufferGeometry(new hv(e, t, i, n, r, a)), this.mergeVertices()
    }

    function hv(e, t, i, n, r, a) {
        sd.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a
        }, e = e || .5, t = t || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8;
        var o, s, l, h = [], c = [], u = [], p = [], d = e, f = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1),
            m = new yu, g = new mu;
        for (s = 0; s <= n; s++) {
            for (l = 0; l <= i; l++) o = r + l / i * a, m.x = d * Math.cos(o), m.y = d * Math.sin(o), c.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, p.push(g.x, g.y);
            d += f
        }
        for (s = 0; s < n; s++) {
            var v = s * (i + 1);
            for (l = 0; l < i; l++) {
                var y = o = l + v, _ = o + i + 1, x = o + i + 2, b = o + 1;
                h.push(y, _, b), h.push(_, x, b)
            }
        }
        this.setIndex(h), this.addAttribute("position", new Wp(c, 3)), this.addAttribute("normal", new Wp(u, 3)), this.addAttribute("uv", new Wp(p, 2))
    }

    function cv(e, t, i, n) {
        Up.call(this), this.type = "LatheGeometry", this.parameters = {
            points: e, segments: t, phiStart: i, phiLength: n
        }, this.fromBufferGeometry(new uv(e, t, i, n)), this.mergeVertices()
    }

    function uv(e, t, i, n) {
        sd.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: e, segments: t, phiStart: i, phiLength: n
        }, t = Math.floor(t) || 12, i = i || 0, n = n || 2 * Math.PI, n = fu.clamp(n, 0, 2 * Math.PI);
        var r, a, o, s = [], l = [], h = [], c = 1 / t, u = new yu, p = new mu;
        for (a = 0; a <= t; a++) {
            var d = i + a * c * n, f = Math.sin(d), m = Math.cos(d);
            for (o = 0; o <= e.length - 1; o++) u.x = e[o].x * f, u.y = e[o].y, u.z = e[o].x * m, l.push(u.x, u.y, u.z), p.x = a / t, p.y = o / (e.length - 1), h.push(p.x, p.y)
        }
        for (a = 0; a < t; a++) for (o = 0; o < e.length - 1; o++) {
            var g = r = o + a * e.length, v = r + e.length, y = r + e.length + 1, _ = r + 1;
            s.push(g, v, _), s.push(v, y, _)
        }
        if (this.setIndex(s), this.addAttribute("position", new Wp(l, 3)), this.addAttribute("uv", new Wp(h, 2)), this.computeVertexNormals(), n === 2 * Math.PI) {
            var x = this.attributes.normal.array, b = new yu, w = new yu, T = new yu;
            for (r = t * e.length * 3, o = a = 0; a < e.length; a++, o += 3) b.x = x[o + 0], b.y = x[o + 1], b.z = x[o + 2], w.x = x[r + o + 0], w.y = x[r + o + 1], w.z = x[r + o + 2], T.addVectors(b, w).normalize(), x[o + 0] = x[r + o + 0] = T.x, x[o + 1] = x[r + o + 1] = T.y, x[o + 2] = x[r + o + 2] = T.z
        }
    }

    function pv(e, t) {
        Up.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
            shapes: e, curveSegments: t
        }, this.fromBufferGeometry(new dv(e, t)), this.mergeVertices()
    }

    function dv(e, f) {
        sd.call(this), this.type = "ShapeBufferGeometry", this.parameters = {shapes: e, curveSegments: f}, f = f || 12;
        var m = [], g = [], v = [], y = [], t = 0, _ = 0;
        if (!1 === Array.isArray(e)) n(e); else for (var i = 0; i < e.length; i++) n(e[i]), this.addGroup(t, _, i), t += _, _ = 0;

        function n(e) {
            var t, i, n, r = g.length / 3, a = e.extractPoints(f), o = a.shape, s = a.holes;
            if (!1 === Jg.isClockWise(o)) for (o = o.reverse(), t = 0, i = s.length; t < i; t++) n = s[t], !0 === Jg.isClockWise(n) && (s[t] = n.reverse());
            var l = Jg.triangulateShape(o, s);
            for (t = 0, i = s.length; t < i; t++) n = s[t], o = o.concat(n);
            for (t = 0, i = o.length; t < i; t++) {
                var h = o[t];
                g.push(h.x, h.y, 0), v.push(0, 0, 1), y.push(h.x, h.y)
            }
            for (t = 0, i = l.length; t < i; t++) {
                var c = l[t], u = c[0] + r, p = c[1] + r, d = c[2] + r;
                m.push(u, p, d), _ += 3
            }
        }

        this.setIndex(m), this.addAttribute("position", new Wp(g, 3)), this.addAttribute("normal", new Wp(v, 3)), this.addAttribute("uv", new Wp(y, 2))
    }

    function fv(e, t) {
        if (t.shapes = [], Array.isArray(e)) for (var i = 0, n = e.length; i < n; i++) {
            var r = e[i];
            t.shapes.push(r.uuid)
        } else t.shapes.push(e.uuid);
        return t
    }

    function mv(e, t) {
        sd.call(this), this.type = "EdgesGeometry", this.parameters = {thresholdAngle: t}, t = void 0 !== t ? t : 1;
        var i, n, r, a, o = [], s = Math.cos(fu.DEG2RAD * t), l = [0, 0], h = {}, c = ["a", "b", "c"];
        e.isBufferGeometry ? (a = new Up).fromBufferGeometry(e) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals();
        for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++) for (var m = p[d], g = 0; g < 3; g++) i = m[c[g]], n = m[c[(g + 1) % 3]], l[0] = Math.min(i, n), l[1] = Math.max(i, n), void 0 === h[r = l[0] + "," + l[1]] ? h[r] = {
            index1: l[0], index2: l[1], face1: d, face2: void 0
        } : h[r].face2 = d;
        for (r in h) {
            var v = h[r];
            if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
                var y = u[v.index1];
                o.push(y.x, y.y, y.z), y = u[v.index2], o.push(y.x, y.y, y.z)
            }
        }
        this.addAttribute("position", new Wp(o, 3))
    }

    function gv(e, t, i, n, r, a, o, s) {
        Up.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new vv(e, t, i, n, r, a, o, s)), this.mergeVertices()
    }

    function vv(v, y, _, x, b, e, w, T) {
        sd.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: v,
            radiusBottom: y,
            height: _,
            radialSegments: x,
            heightSegments: b,
            openEnded: e,
            thetaStart: w,
            thetaLength: T
        };
        var S = this;
        v = void 0 !== v ? v : 1, y = void 0 !== y ? y : 1, _ = _ || 1, x = Math.floor(x) || 8, b = Math.floor(b) || 1, e = void 0 !== e && e, w = void 0 !== w ? w : 0, T = void 0 !== T ? T : 2 * Math.PI;
        var E = [], A = [], M = [], P = [], L = 0, C = [], I = _ / 2, R = 0;

        function t(e) {
            var t, i, n, r = new mu, a = new yu, o = 0, s = !0 === e ? v : y, l = !0 === e ? 1 : -1;
            for (i = L, t = 1; t <= x; t++) A.push(0, I * l, 0), M.push(0, l, 0), P.push(.5, .5), L++;
            for (n = L, t = 0; t <= x; t++) {
                var h = t / x * T + w, c = Math.cos(h), u = Math.sin(h);
                a.x = s * u, a.y = I * l, a.z = s * c, A.push(a.x, a.y, a.z), M.push(0, l, 0), r.x = .5 * c + .5, r.y = .5 * u * l + .5, P.push(r.x, r.y), L++
            }
            for (t = 0; t < x; t++) {
                var p = i + t, d = n + t;
                !0 === e ? E.push(d, d + 1, p) : E.push(d + 1, d, p), o += 3
            }
            S.addGroup(R, o, !0 === e ? 1 : 2), R += o
        }

        !function () {
            var e, t, i = new yu, n = new yu, r = 0, a = (y - v) / _;
            for (t = 0; t <= b; t++) {
                var o = [], s = t / b, l = s * (y - v) + v;
                for (e = 0; e <= x; e++) {
                    var h = e / x, c = h * T + w, u = Math.sin(c), p = Math.cos(c);
                    n.x = l * u, n.y = -s * _ + I, n.z = l * p, A.push(n.x, n.y, n.z), i.set(u, a, p).normalize(), M.push(i.x, i.y, i.z), P.push(h, 1 - s), o.push(L++)
                }
                C.push(o)
            }
            for (e = 0; e < x; e++) for (t = 0; t < b; t++) {
                var d = C[t][e], f = C[t + 1][e], m = C[t + 1][e + 1], g = C[t][e + 1];
                E.push(d, f, g), E.push(f, m, g), r += 6
            }
            S.addGroup(R, r, 0), R += r
        }(), !1 === e && (0 < v && t(!0), 0 < y && t(!1)), this.setIndex(E), this.addAttribute("position", new Wp(A, 3)), this.addAttribute("normal", new Wp(M, 3)), this.addAttribute("uv", new Wp(P, 2))
    }

    function yv(e, t, i, n, r, a, o) {
        gv.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
            radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: o
        }
    }

    function _v(e, t, i, n, r, a, o) {
        vv.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
            radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: o
        }
    }

    function xv(e, t, i, n) {
        Up.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: e, segments: t, thetaStart: i, thetaLength: n
        }, this.fromBufferGeometry(new bv(e, t, i, n)), this.mergeVertices()
    }

    function bv(e, t, i, n) {
        sd.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: e, segments: t, thetaStart: i, thetaLength: n
        }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
        var r, a, o = [], s = [], l = [], h = [], c = new yu, u = new mu;
        for (s.push(0, 0, 0), l.push(0, 0, 1), h.push(.5, .5), a = 0, r = 3; a <= t; a++, r += 3) {
            var p = i + a / t * n;
            c.x = e * Math.cos(p), c.y = e * Math.sin(p), s.push(c.x, c.y, c.z), l.push(0, 0, 1), u.x = (s[r] / e + 1) / 2, u.y = (s[r + 1] / e + 1) / 2, h.push(u.x, u.y)
        }
        for (r = 1; r <= t; r++) o.push(r, r + 1, 0);
        this.setIndex(o), this.addAttribute("position", new Wp(s, 3)), this.addAttribute("normal", new Wp(l, 3)), this.addAttribute("uv", new Wp(h, 2))
    }

    (rv.prototype = Object.create(Up.prototype)).constructor = rv, (av.prototype = Object.create(tv.prototype)).constructor = av, (ov.prototype = Object.create(Up.prototype)).constructor = ov, (sv.prototype = Object.create(sd.prototype)).constructor = sv, (lv.prototype = Object.create(Up.prototype)).constructor = lv, (hv.prototype = Object.create(sd.prototype)).constructor = hv, (cv.prototype = Object.create(Up.prototype)).constructor = cv, (uv.prototype = Object.create(sd.prototype)).constructor = uv, ((pv.prototype = Object.create(Up.prototype)).constructor = pv).prototype.toJSON = function () {
        var e = Up.prototype.toJSON.call(this);
        return fv(this.parameters.shapes, e)
    }, ((dv.prototype = Object.create(sd.prototype)).constructor = dv).prototype.toJSON = function () {
        var e = sd.prototype.toJSON.call(this);
        return fv(this.parameters.shapes, e)
    }, (mv.prototype = Object.create(sd.prototype)).constructor = mv, (gv.prototype = Object.create(Up.prototype)).constructor = gv, (vv.prototype = Object.create(sd.prototype)).constructor = vv, (yv.prototype = Object.create(gv.prototype)).constructor = yv, (_v.prototype = Object.create(vv.prototype)).constructor = _v, (xv.prototype = Object.create(Up.prototype)).constructor = xv, (bv.prototype = Object.create(sd.prototype)).constructor = bv;
    var wv = Object.freeze({
        WireframeGeometry: ug,
        ParametricGeometry: pg,
        ParametricBufferGeometry: dg,
        TetrahedronGeometry: gg,
        TetrahedronBufferGeometry: vg,
        OctahedronGeometry: yg,
        OctahedronBufferGeometry: _g,
        IcosahedronGeometry: xg,
        IcosahedronBufferGeometry: bg,
        DodecahedronGeometry: wg,
        DodecahedronBufferGeometry: Tg,
        PolyhedronGeometry: fg,
        PolyhedronBufferGeometry: mg,
        TubeGeometry: Sg,
        TubeBufferGeometry: Eg,
        TorusKnotGeometry: Ag,
        TorusKnotBufferGeometry: Mg,
        TorusGeometry: Pg,
        TorusBufferGeometry: Lg,
        TextGeometry: rv,
        TextBufferGeometry: av,
        SphereGeometry: ov,
        SphereBufferGeometry: sv,
        RingGeometry: lv,
        RingBufferGeometry: hv,
        PlaneGeometry: cd,
        PlaneBufferGeometry: ud,
        LatheGeometry: cv,
        LatheBufferGeometry: uv,
        ShapeGeometry: pv,
        ShapeBufferGeometry: dv,
        ExtrudeGeometry: ev,
        ExtrudeBufferGeometry: tv,
        EdgesGeometry: mv,
        ConeGeometry: yv,
        ConeBufferGeometry: _v,
        CylinderGeometry: gv,
        CylinderBufferGeometry: vv,
        CircleGeometry: xv,
        CircleBufferGeometry: bv,
        BoxGeometry: ld,
        BoxBufferGeometry: hd
    });

    function Tv(e) {
        Dd.call(this), this.type = "ShadowMaterial", this.color = new $u(0), this.transparent = !0, this.setValues(e)
    }

    function Sv(e) {
        zd.call(this, e), this.type = "RawShaderMaterial"
    }

    function Ev(e) {
        Dd.call(this), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new $u(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $u(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pu, this.normalScale = new mu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Av(e) {
        Ev.call(this), this.defines = {PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
    }

    function Mv(e) {
        Dd.call(this), this.type = "MeshPhongMaterial", this.color = new $u(16777215), this.specular = new $u(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $u(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pu, this.normalScale = new mu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Pv(e) {
        Mv.call(this), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
    }

    function Lv(e) {
        Dd.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pu, this.normalScale = new mu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Cv(e) {
        Dd.call(this), this.type = "MeshLambertMaterial", this.color = new $u(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new $u(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Hh, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
    }

    function Iv(e) {
        if (Dd.call(this), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new $u(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = pu, this.normalScale = new mu(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e), null === this.matcap) {
            var t = document.createElement("canvas");
            t.width = 1, t.height = 1;
            var i = t.getContext("2d");
            i.fillStyle = "#fff", i.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t)
        }
    }

    function Rv(e) {
        tg.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }

    ((Tv.prototype = Object.create(Dd.prototype)).constructor = Tv).prototype.isShadowMaterial = !0, Tv.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this
    }, ((Sv.prototype = Object.create(zd.prototype)).constructor = Sv).prototype.isRawShaderMaterial = !0, ((Ev.prototype = Object.create(Dd.prototype)).constructor = Ev).prototype.isMeshStandardMaterial = !0, Ev.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.defines = {STANDARD: ""}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Av.prototype = Object.create(Ev.prototype)).constructor = Av).prototype.isMeshPhysicalMaterial = !0, Av.prototype.copy = function (e) {
        return Ev.prototype.copy.call(this, e), this.defines = {PHYSICAL: ""}, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
    }, ((Mv.prototype = Object.create(Dd.prototype)).constructor = Mv).prototype.isMeshPhongMaterial = !0, Mv.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Pv.prototype = Object.create(Mv.prototype)).constructor = Pv).prototype.isMeshToonMaterial = !0, Pv.prototype.copy = function (e) {
        return Mv.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
    }, ((Lv.prototype = Object.create(Dd.prototype)).constructor = Lv).prototype.isMeshNormalMaterial = !0, Lv.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Cv.prototype = Object.create(Dd.prototype)).constructor = Cv).prototype.isMeshLambertMaterial = !0, Cv.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Iv.prototype = Object.create(Dd.prototype)).constructor = Iv).prototype.isMeshMatcapMaterial = !0, Iv.prototype.copy = function (e) {
        return Dd.prototype.copy.call(this, e), this.defines = {MATCAP: ""}, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
    }, ((Rv.prototype = Object.create(tg.prototype)).constructor = Rv).prototype.isLineDashedMaterial = !0, Rv.prototype.copy = function (e) {
        return tg.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    };
    var Ov = Object.freeze({
        ShadowMaterial: Tv,
        SpriteMaterial: Qm,
        RawShaderMaterial: Sv,
        ShaderMaterial: zd,
        PointsMaterial: ag,
        MeshPhysicalMaterial: Av,
        MeshStandardMaterial: Ev,
        MeshPhongMaterial: Mv,
        MeshToonMaterial: Pv,
        MeshNormalMaterial: Lv,
        MeshLambertMaterial: Cv,
        MeshDepthMaterial: Im,
        MeshDistanceMaterial: Rm,
        MeshBasicMaterial: Gd,
        MeshMatcapMaterial: Iv,
        LineDashedMaterial: Rv,
        LineBasicMaterial: tg,
        Material: Dd
    }), Fv = {
        enabled: !1, files: {}, add: function (e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        }, get: function (e) {
            if (!1 !== this.enabled) return this.files[e]
        }, remove: function (e) {
            delete this.files[e]
        }, clear: function () {
            this.files = {}
        }
    };

    function Nv(e, t, i) {
        var n = this, r = !1, a = 0, o = 0, s = void 0;
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) {
            o++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, o), r = !0
        }, this.itemEnd = function (e) {
            a++, void 0 !== n.onProgress && n.onProgress(e, a, o), a === o && (r = !1, void 0 !== n.onLoad && n.onLoad())
        }, this.itemError = function (e) {
            void 0 !== n.onError && n.onError(e)
        }, this.resolveURL = function (e) {
            return s ? s(e) : e
        }, this.setURLModifier = function (e) {
            return s = e, this
        }
    }

    var kv = new Nv, Uv = {};

    function Dv(e) {
        this.manager = void 0 !== e ? e : kv
    }

    function zv(e) {
        this.manager = void 0 !== e ? e : kv
    }

    function Bv(e) {
        this.manager = void 0 !== e ? e : kv
    }

    function Hv(e) {
        this.manager = void 0 !== e ? e : kv
    }

    function Gv() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function jv(e, t, i, n, r, a, o, s) {
        Gv.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
    }

    function Vv(e, t, i, n, r, a) {
        jv.call(this, e, t, i, i, n, r, a), this.type = "ArcCurve"
    }

    function Xv() {
        var r = 0, a = 0, o = 0, s = 0;

        function h(e, t, i, n) {
            o = -3 * (r = e) + 3 * t - 2 * (a = i) - n, s = 2 * e - 2 * t + i + n
        }

        return {
            initCatmullRom: function (e, t, i, n, r) {
                h(t, i, r * (i - e), r * (n - t))
            }, initNonuniformCatmullRom: function (e, t, i, n, r, a, o) {
                var s = (t - e) / r - (i - e) / (r + a) + (i - t) / a,
                    l = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
                h(t, i, s *= a, l *= a)
            }, calc: function (e) {
                var t = e * e;
                return r + a * e + o * t + s * (t * e)
            }
        }
    }

    Object.assign(Dv.prototype, {
        load: function (o, e, t, i) {
            void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o);
            var s = this, n = Fv.get(o);
            if (void 0 !== n) return s.manager.itemStart(o), setTimeout(function () {
                e && e(n), s.manager.itemEnd(o)
            }, 0), n;
            if (void 0 === Uv[o]) {
                var r = o.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (r) {
                    var a = r[1], l = !!r[2], h = r[3];
                    h = window.decodeURIComponent(h), l && (h = window.atob(h));
                    try {
                        var c, u = (this.responseType || "").toLowerCase();
                        switch (u) {
                            case"arraybuffer":
                            case"blob":
                                for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++) p[d] = h.charCodeAt(d);
                                c = "blob" === u ? new Blob([p.buffer], {type: a}) : p.buffer;
                                break;
                            case"document":
                                var f = new DOMParser;
                                c = f.parseFromString(h, a);
                                break;
                            case"json":
                                c = JSON.parse(h);
                                break;
                            default:
                                c = h
                        }
                        window.setTimeout(function () {
                            e && e(c), s.manager.itemEnd(o)
                        }, 0)
                    } catch (e) {
                        window.setTimeout(function () {
                            i && i(e), s.manager.itemEnd(o), s.manager.itemError(o)
                        }, 0)
                    }
                } else {
                    Uv[o] = [], Uv[o].push({onLoad: e, onProgress: t, onError: i});
                    var m = new XMLHttpRequest;
                    for (var g in m.open("GET", o, !0), m.addEventListener("load", function (e) {
                        var t = this.response;
                        Fv.add(o, t);
                        var i = Uv[o];
                        if (delete Uv[o], 200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var n = 0, r = i.length; n < r; n++) {
                                (a = i[n]).onLoad && a.onLoad(t)
                            }
                            s.manager.itemEnd(o)
                        } else {
                            for (n = 0, r = i.length; n < r; n++) {
                                var a;
                                (a = i[n]).onError && a.onError(e)
                            }
                            s.manager.itemEnd(o), s.manager.itemError(o)
                        }
                    }, !1), m.addEventListener("progress", function (e) {
                        for (var t = Uv[o], i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onProgress && r.onProgress(e)
                        }
                    }, !1), m.addEventListener("error", function (e) {
                        var t = Uv[o];
                        delete Uv[o];
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onError && r.onError(e)
                        }
                        s.manager.itemEnd(o), s.manager.itemError(o)
                    }, !1), m.addEventListener("abort", function (e) {
                        var t = Uv[o];
                        delete Uv[o];
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onError && r.onError(e)
                        }
                        s.manager.itemEnd(o), s.manager.itemError(o)
                    }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                    m.send(null)
                }
                return s.manager.itemStart(o), m
            }
            Uv[o].push({onLoad: e, onProgress: t, onError: i})
        }, setPath: function (e) {
            return this.path = e, this
        }, setResponseType: function (e) {
            return this.responseType = e, this
        }, setWithCredentials: function (e) {
            return this.withCredentials = e, this
        }, setMimeType: function (e) {
            return this.mimeType = e, this
        }, setRequestHeader: function (e) {
            return this.requestHeader = e, this
        }
    }), Object.assign(function (e) {
        this.manager = void 0 !== e ? e : kv, this._parser = null
    }.prototype, {
        load: function (e, a, t, n) {
            var o = this, s = [], l = new lg;
            l.image = s;
            var r = new Dv(this.manager);

            function i(i) {
                r.load(e[i], function (e) {
                    var t = o._parser(e, !0);
                    s[i] = {
                        width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps
                    }, 6 === (h += 1) && (1 === t.mipmapCount && (l.minFilter = lc), l.format = t.format, l.needsUpdate = !0, a && a(l))
                }, t, n)
            }

            if (r.setPath(this.path), r.setResponseType("arraybuffer"), Array.isArray(e)) for (var h = 0, c = 0, u = e.length; c < u; ++c) i(c); else r.load(e, function (e) {
                var t = o._parser(e, !0);
                if (t.isCubemap) for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) {
                    s[n] = {mipmaps: []};
                    for (var r = 0; r < t.mipmapCount; r++) s[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), s[n].format = t.format, s[n].width = t.width, s[n].height = t.height
                } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                1 === t.mipmapCount && (l.minFilter = lc), l.format = t.format, l.needsUpdate = !0, a && a(l)
            }, t, n);
            return l
        }, setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(function (e) {
        this.manager = void 0 !== e ? e : kv, this._parser = null
    }.prototype, {
        load: function (e, i, t, n) {
            var r = this, a = new Gu, o = new Dv(this.manager);
            return o.setResponseType("arraybuffer"), o.load(e, function (e) {
                var t = r._parser(e);
                t && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : nc, a.wrapT = void 0 !== t.wrapT ? t.wrapT : nc, a.magFilter = void 0 !== t.magFilter ? t.magFilter : lc, a.minFilter = void 0 !== t.minFilter ? t.minFilter : cc, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps), 1 === t.mipmapCount && (a.minFilter = lc), a.needsUpdate = !0, i && i(a, t))
            }, t, n), a
        }
    }), Object.assign(zv.prototype, {
        crossOrigin: "anonymous", load: function (t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this, a = Fv.get(t);
            if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
                e && e(a), r.manager.itemEnd(t)
            }, 0), a;
            var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

            function s() {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Fv.add(t, this), e && e(this), r.manager.itemEnd(t)
            }

            function l(e) {
                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), n && n(e), r.manager.itemEnd(t), r.manager.itemError(t)
            }

            return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
        }, setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        }, setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Bv.prototype, {
        crossOrigin: "anonymous", load: function (e, i, t, n) {
            var r = new tf, a = new zv(this.manager);
            a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
            var o = 0;

            function s(t) {
                a.load(e[t], function (e) {
                    r.images[t] = e, 6 === ++o && (r.needsUpdate = !0, i && i(r))
                }, void 0, n)
            }

            for (var l = 0; l < e.length; ++l) s(l);
            return r
        }, setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        }, setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Hv.prototype, {
        crossOrigin: "anonymous", load: function (i, n, e, t) {
            var r = new Du, a = new zv(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i, function (e) {
                r.image = e;
                var t = 0 < i.search(/\.jpe?g$/i) || 0 === i.search(/^data\:image\/jpeg/);
                r.format = t ? Sc : Ec, r.needsUpdate = !0, void 0 !== n && n(r)
            }, e, t), r
        }, setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        }, setPath: function (e) {
            return this.path = e, this
        }
    }), Object.assign(Gv.prototype, {
        getPoint: function () {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        }, getPointAt: function (e, t) {
            var i = this.getUtoTmapping(e);
            return this.getPoint(i, t)
        }, getPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return t
        }, getSpacedPoints: function (e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
            return t
        }, getLength: function () {
            var e = this.getLengths();
            return e[e.length - 1]
        }, getLengths: function (e) {
            if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i, n = [], r = this.getPoint(0), a = 0;
            for (n.push(0), i = 1; i <= e; i++) a += (t = this.getPoint(i / e)).distanceTo(r), n.push(a), r = t;
            return this.cacheArcLengths = n
        }, updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        }, getUtoTmapping: function (e, t) {
            var i, n = this.getLengths(), r = 0, a = n.length;
            i = t || e * n[a - 1];
            for (var o, s = 0, l = a - 1; s <= l;) if ((o = n[r = Math.floor(s + (l - s) / 2)] - i) < 0) s = r + 1; else {
                if (!(0 < o)) {
                    l = r;
                    break
                }
                l = r - 1
            }
            if (n[r = l] === i) return r / (a - 1);
            var h = n[r];
            return (r + (i - h) / (n[r + 1] - h)) / (a - 1)
        }, getTangent: function (e) {
            var t = e - 1e-4, i = e + 1e-4;
            t < 0 && (t = 0), 1 < i && (i = 1);
            var n = this.getPoint(t);
            return this.getPoint(i).clone().sub(n).normalize()
        }, getTangentAt: function (e) {
            var t = this.getUtoTmapping(e);
            return this.getTangent(t)
        }, computeFrenetFrames: function (e, t) {
            var i, n, r, a = new yu, o = [], s = [], l = [], h = new yu, c = new gu;
            for (i = 0; i <= e; i++) n = i / e, o[i] = this.getTangentAt(n), o[i].normalize();
            s[0] = new yu, l[0] = new yu;
            var u = Number.MAX_VALUE, p = Math.abs(o[0].x), d = Math.abs(o[0].y), f = Math.abs(o[0].z);
            for (p <= u && (u = p, a.set(1, 0, 0)), d <= u && (u = d, a.set(0, 1, 0)), f <= u && a.set(0, 0, 1), h.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], h), l[0].crossVectors(o[0], s[0]), i = 1; i <= e; i++) s[i] = s[i - 1].clone(), l[i] = l[i - 1].clone(), h.crossVectors(o[i - 1], o[i]), h.length() > Number.EPSILON && (h.normalize(), r = Math.acos(fu.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(c.makeRotationAxis(h, r))), l[i].crossVectors(o[i], s[i]);
            if (!0 === t) for (r = Math.acos(fu.clamp(s[0].dot(s[e]), -1, 1)), r /= e, 0 < o[0].dot(h.crossVectors(s[0], s[e])) && (r = -r), i = 1; i <= e; i++) s[i].applyMatrix4(c.makeRotationAxis(o[i], r * i)), l[i].crossVectors(o[i], s[i]);
            return {tangents: o, normals: s, binormals: l}
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }, toJSON: function () {
            var e = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
            return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
        }, fromJSON: function (e) {
            return this.arcLengthDivisions = e.arcLengthDivisions, this
        }
    }), ((jv.prototype = Object.create(Gv.prototype)).constructor = jv).prototype.isEllipseCurve = !0, jv.prototype.getPoint = function (e, t) {
        for (var i = t || new mu, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += n;
        for (; n < r;) r -= n;
        r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n);
        var o = this.aStartAngle + e * r, s = this.aX + this.xRadius * Math.cos(o),
            l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
            var h = Math.cos(this.aRotation), c = Math.sin(this.aRotation), u = s - this.aX, p = l - this.aY;
            s = u * h - p * c + this.aX, l = u * c + p * h + this.aY
        }
        return i.set(s, l)
    }, jv.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, jv.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }, jv.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }, ((Vv.prototype = Object.create(jv.prototype)).constructor = Vv).prototype.isArcCurve = !0;
    var Wv = new yu, Yv = new Xv, qv = new Xv, Qv = new Xv;

    function Zv(e, t, i, n) {
        Gv.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function Jv(e, t, i, n, r) {
        var a = .5 * (n - t), o = .5 * (r - i), s = e * e;
        return (2 * i - 2 * n + a + o) * (e * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * e + i
    }

    function Kv(e, t, i, n) {
        return (o = 1 - e) * o * t + 2 * (1 - (a = e)) * a * i + (r = e) * r * n;
        var r, a, o
    }

    function $v(e, t, i, n, r) {
        return (h = 1 - e) * h * h * t + 3 * (l = 1 - (s = e)) * l * s * i + 3 * (1 - (o = e)) * o * o * n + (a = e) * a * a * r;
        var a, o, s, l, h
    }

    function ey(e, t, i, n) {
        Gv.call(this), this.type = "CubicBezierCurve", this.v0 = e || new mu, this.v1 = t || new mu, this.v2 = i || new mu, this.v3 = n || new mu
    }

    function ty(e, t, i, n) {
        Gv.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new yu, this.v1 = t || new yu, this.v2 = i || new yu, this.v3 = n || new yu
    }

    function iy(e, t) {
        Gv.call(this), this.type = "LineCurve", this.v1 = e || new mu, this.v2 = t || new mu
    }

    function ny(e, t) {
        Gv.call(this), this.type = "LineCurve3", this.v1 = e || new yu, this.v2 = t || new yu
    }

    function ry(e, t, i) {
        Gv.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new mu, this.v1 = t || new mu, this.v2 = i || new mu
    }

    function ay(e, t, i) {
        Gv.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new yu, this.v1 = t || new yu, this.v2 = i || new yu
    }

    function oy(e) {
        Gv.call(this), this.type = "SplineCurve", this.points = e || []
    }

    ((Zv.prototype = Object.create(Gv.prototype)).constructor = Zv).prototype.isCatmullRomCurve3 = !0, Zv.prototype.getPoint = function (e, t) {
        var i, n, r, a, o = t || new yu, s = this.points, l = s.length, h = (l - (this.closed ? 0 : 1)) * e,
            c = Math.floor(h), u = h - c;
        if (this.closed ? c += 0 < c ? 0 : (Math.floor(Math.abs(c) / l) + 1) * l : 0 === u && c === l - 1 && (c = l - 2, u = 1), i = this.closed || 0 < c ? s[(c - 1) % l] : (Wv.subVectors(s[0], s[1]).add(s[0]), Wv), n = s[c % l], r = s[(c + 1) % l], a = this.closed || c + 2 < l ? s[(c + 2) % l] : (Wv.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), Wv), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var p = "chordal" === this.curveType ? .5 : .25, d = Math.pow(i.distanceToSquared(n), p),
                f = Math.pow(n.distanceToSquared(r), p), m = Math.pow(r.distanceToSquared(a), p);
            f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), Yv.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, d, f, m), qv.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, d, f, m), Qv.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, d, f, m)
        } else "catmullrom" === this.curveType && (Yv.initCatmullRom(i.x, n.x, r.x, a.x, this.tension), qv.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), Qv.initCatmullRom(i.z, n.z, r.z, a.z, this.tension));
        return o.set(Yv.calc(u), qv.calc(u), Qv.calc(u)), o
    }, Zv.prototype.copy = function (e) {
        Gv.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, Zv.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }, Zv.prototype.fromJSON = function (e) {
        Gv.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new yu).fromArray(n))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }, ((ey.prototype = Object.create(Gv.prototype)).constructor = ey).prototype.isCubicBezierCurve = !0, ey.prototype.getPoint = function (e, t) {
        var i = t || new mu, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
        return i.set($v(e, n.x, r.x, a.x, o.x), $v(e, n.y, r.y, a.y, o.y)), i
    }, ey.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, ey.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, ey.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, ((ty.prototype = Object.create(Gv.prototype)).constructor = ty).prototype.isCubicBezierCurve3 = !0, ty.prototype.getPoint = function (e, t) {
        var i = t || new yu, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
        return i.set($v(e, n.x, r.x, a.x, o.x), $v(e, n.y, r.y, a.y, o.y), $v(e, n.z, r.z, a.z, o.z)), i
    }, ty.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }, ty.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }, ty.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }, ((iy.prototype = Object.create(Gv.prototype)).constructor = iy).prototype.isLineCurve = !0, iy.prototype.getPoint = function (e, t) {
        var i = t || new mu;
        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }, iy.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, iy.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize()
    }, iy.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, iy.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, iy.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((ny.prototype = Object.create(Gv.prototype)).constructor = ny).prototype.isLineCurve3 = !0, ny.prototype.getPoint = function (e, t) {
        var i = t || new yu;
        return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
    }, ny.prototype.getPointAt = function (e, t) {
        return this.getPoint(e, t)
    }, ny.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, ny.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, ny.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((ry.prototype = Object.create(Gv.prototype)).constructor = ry).prototype.isQuadraticBezierCurve = !0, ry.prototype.getPoint = function (e, t) {
        var i = t || new mu, n = this.v0, r = this.v1, a = this.v2;
        return i.set(Kv(e, n.x, r.x, a.x), Kv(e, n.y, r.y, a.y)), i
    }, ry.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, ry.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, ry.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((ay.prototype = Object.create(Gv.prototype)).constructor = ay).prototype.isQuadraticBezierCurve3 = !0, ay.prototype.getPoint = function (e, t) {
        var i = t || new yu, n = this.v0, r = this.v1, a = this.v2;
        return i.set(Kv(e, n.x, r.x, a.x), Kv(e, n.y, r.y, a.y), Kv(e, n.z, r.z, a.z)), i
    }, ay.prototype.copy = function (e) {
        return Gv.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }, ay.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }, ay.prototype.fromJSON = function (e) {
        return Gv.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }, ((oy.prototype = Object.create(Gv.prototype)).constructor = oy).prototype.isSplineCurve = !0, oy.prototype.getPoint = function (e, t) {
        var i = t || new mu, n = this.points, r = (n.length - 1) * e, a = Math.floor(r), o = r - a,
            s = n[0 === a ? a : a - 1], l = n[a], h = n[a > n.length - 2 ? n.length - 1 : a + 1],
            c = n[a > n.length - 3 ? n.length - 1 : a + 2];
        return i.set(Jv(o, s.x, l.x, h.x, c.x), Jv(o, s.y, l.y, h.y, c.y)), i
    }, oy.prototype.copy = function (e) {
        Gv.prototype.copy.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push(n.clone())
        }
        return this
    }, oy.prototype.toJSON = function () {
        var e = Gv.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++) {
            var n = this.points[t];
            e.points.push(n.toArray())
        }
        return e
    }, oy.prototype.fromJSON = function (e) {
        Gv.prototype.fromJSON.call(this, e), this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new mu).fromArray(n))
        }
        return this
    };
    var sy = Object.freeze({
        ArcCurve: Vv,
        CatmullRomCurve3: Zv,
        CubicBezierCurve: ey,
        CubicBezierCurve3: ty,
        EllipseCurve: jv,
        LineCurve: iy,
        LineCurve3: ny,
        QuadraticBezierCurve: ry,
        QuadraticBezierCurve3: ay,
        SplineCurve: oy
    });

    function ly() {
        Gv.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function hy(e) {
        ly.call(this), this.type = "Path", this.currentPoint = new mu, e && this.setFromPoints(e)
    }

    function cy(e) {
        hy.call(this, e), this.uuid = fu.generateUUID(), this.type = "Shape", this.holes = []
    }

    function uy(e, t) {
        Pp.call(this), this.type = "Light", this.color = new $u(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
    }

    function py(e, t, i) {
        uy.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(Pp.DefaultUp), this.updateMatrix(), this.groundColor = new $u(t)
    }

    function dy(e) {
        this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new mu(512, 512), this.map = null, this.matrix = new gu
    }

    function fy() {
        dy.call(this, new zm(50, 1, .5, 500))
    }

    function my(e, t, i, n, r, a) {
        uy.call(this, e, t), this.type = "SpotLight", this.position.copy(Pp.DefaultUp), this.updateMatrix(), this.target = new Pp, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            }, set: function (e) {
                this.intensity = e / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new fy
    }

    function gy(e, t, i, n) {
        uy.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            }, set: function (e) {
                this.intensity = e / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new dy(new zm(90, 1, .5, 500))
    }

    function vy(e, t, i, n, r, a) {
        Dm.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
    }

    function yy() {
        dy.call(this, new vy(-5, 5, 5, -5, .5, 500))
    }

    function _y(e, t) {
        uy.call(this, e, t), this.type = "DirectionalLight", this.position.copy(Pp.DefaultUp), this.updateMatrix(), this.target = new Pp, this.shadow = new yy
    }

    function xy(e, t) {
        uy.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
    }

    function by(e, t, i, n) {
        uy.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    ly.prototype = Object.assign(Object.create(Gv.prototype), {
        constructor: ly, add: function (e) {
            this.curves.push(e)
        }, closePath: function () {
            var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new iy(t, e))
        }, getPoint: function (e) {
            for (var t = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) {
                if (i[n] >= t) {
                    var r = i[n] - t, a = this.curves[n], o = a.getLength(), s = 0 === o ? 0 : 1 - r / o;
                    return a.getPointAt(s)
                }
                n++
            }
            return null
        }, getLength: function () {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        }, updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        }, getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
            return this.cacheLengths = e
        }, getSpacedPoints: function (e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]), t
        }, getPoints: function (e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++) for (var a = r[n], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) {
                var h = s[l];
                t && t.equals(h) || (i.push(h), t = h)
            }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
        }, copy: function (e) {
            Gv.prototype.copy.call(this, e), this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push(n.clone())
            }
            return this.autoClose = e.autoClose, this
        }, toJSON: function () {
            var e = Gv.prototype.toJSON.call(this);
            e.autoClose = this.autoClose, e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++) {
                var n = this.curves[t];
                e.curves.push(n.toJSON())
            }
            return e
        }, fromJSON: function (e) {
            Gv.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new sy[n.type]).fromJSON(n))
            }
            return this
        }
    }), hy.prototype = Object.assign(Object.create(ly.prototype), {
        constructor: hy, setFromPoints: function (e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
        }, moveTo: function (e, t) {
            this.currentPoint.set(e, t)
        }, lineTo: function (e, t) {
            var i = new iy(this.currentPoint.clone(), new mu(e, t));
            this.curves.push(i), this.currentPoint.set(e, t)
        }, quadraticCurveTo: function (e, t, i, n) {
            var r = new ry(this.currentPoint.clone(), new mu(e, t), new mu(i, n));
            this.curves.push(r), this.currentPoint.set(i, n)
        }, bezierCurveTo: function (e, t, i, n, r, a) {
            var o = new ey(this.currentPoint.clone(), new mu(e, t), new mu(i, n), new mu(r, a));
            this.curves.push(o), this.currentPoint.set(r, a)
        }, splineThru: function (e) {
            var t = new oy([this.currentPoint.clone()].concat(e));
            this.curves.push(t), this.currentPoint.copy(e[e.length - 1])
        }, arc: function (e, t, i, n, r, a) {
            var o = this.currentPoint.x, s = this.currentPoint.y;
            this.absarc(e + o, t + s, i, n, r, a)
        }, absarc: function (e, t, i, n, r, a) {
            this.absellipse(e, t, i, i, n, r, a)
        }, ellipse: function (e, t, i, n, r, a, o, s) {
            var l = this.currentPoint.x, h = this.currentPoint.y;
            this.absellipse(e + l, t + h, i, n, r, a, o, s)
        }, absellipse: function (e, t, i, n, r, a, o, s) {
            var l = new jv(e, t, i, n, r, a, o, s);
            if (0 < this.curves.length) {
                var h = l.getPoint(0);
                h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
            }
            this.curves.push(l);
            var c = l.getPoint(1);
            this.currentPoint.copy(c)
        }, copy: function (e) {
            return ly.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
        }, toJSON: function () {
            var e = ly.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(), e
        }, fromJSON: function (e) {
            return ly.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
        }
    }), cy.prototype = Object.assign(Object.create(hy.prototype), {
        constructor: cy, getPointsHoles: function (e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
            return t
        }, extractPoints: function (e) {
            return {shape: this.getPoints(e), holes: this.getPointsHoles(e)}
        }, copy: function (e) {
            hy.prototype.copy.call(this, e), this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push(n.clone())
            }
            return this
        }, toJSON: function () {
            var e = hy.prototype.toJSON.call(this);
            e.uuid = this.uuid, e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++) {
                var n = this.holes[t];
                e.holes.push(n.toJSON())
            }
            return e
        }, fromJSON: function (e) {
            hy.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new hy).fromJSON(n))
            }
            return this
        }
    }), uy.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: uy, isLight: !0, copy: function (e) {
            return Pp.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
        }, toJSON: function (e) {
            var t = Pp.prototype.toJSON.call(this, e);
            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }), py.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: py, isHemisphereLight: !0, copy: function (e) {
            return uy.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
        }
    }), Object.assign(dy.prototype, {
        copy: function (e) {
            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, toJSON: function () {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
        }
    }), fy.prototype = Object.assign(Object.create(dy.prototype), {
        constructor: fy, isSpotLightShadow: !0, update: function (e) {
            var t = this.camera, i = 2 * fu.RAD2DEG * e.angle, n = this.mapSize.width / this.mapSize.height,
                r = e.distance || t.far;
            i === t.fov && n === t.aspect && r === t.far || (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix())
        }
    }), my.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: my, isSpotLight: !0, copy: function (e) {
            return uy.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), gy.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: gy, isPointLight: !0, copy: function (e) {
            return uy.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
        }
    }), vy.prototype = Object.assign(Object.create(Dm.prototype), {
        constructor: vy, isOrthographicCamera: !0, copy: function (e, t) {
            return Dm.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
        }, setViewOffset: function (e, t, i, n, r, a) {
            null === this.view && (this.view = {
                enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1
            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - e, a = i + e, o = n + t,
                s = n - t;
            if (null !== this.view && this.view.enabled) {
                var l = this.zoom / (this.view.width / this.view.fullWidth),
                    h = this.zoom / (this.view.height / this.view.fullHeight),
                    c = (this.right - this.left) / this.view.width, u = (this.top - this.bottom) / this.view.height;
                a = (r += c * (this.view.offsetX / l)) + c * (this.view.width / l), s = (o -= u * (this.view.offsetY / h)) - u * (this.view.height / h)
            }
            this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        }, toJSON: function (e) {
            var t = Pp.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }), yy.prototype = Object.assign(Object.create(dy.prototype), {constructor: yy}), _y.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: _y, isDirectionalLight: !0, copy: function (e) {
            return uy.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
        }
    }), xy.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: xy, isAmbientLight: !0
    }), by.prototype = Object.assign(Object.create(uy.prototype), {
        constructor: by, isRectAreaLight: !0, copy: function (e) {
            return uy.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
        }, toJSON: function (e) {
            var t = uy.prototype.toJSON.call(this, e);
            return t.object.width = this.width, t.object.height = this.height, t
        }
    });
    var wy = {
        arraySlice: function (e, t, i) {
            return wy.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
        }, convertArray: function (e, t, i) {
            return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }, isTypedArray: function (e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }, getKeyframeOrder: function (i) {
            for (var e = i.length, t = new Array(e), n = 0; n !== e; ++n) t[n] = n;
            return t.sort(function (e, t) {
                return i[e] - i[t]
            }), t
        }, sortedArray: function (e, t, i) {
            for (var n = e.length, r = new e.constructor(n), a = 0, o = 0; o !== n; ++a) for (var s = i[a] * t, l = 0; l !== t; ++l) r[o++] = e[s + l];
            return r
        }, flattenJSON: function (e, t, i, n) {
            for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[n];) a = e[r++];
            if (void 0 !== a) {
                var o = a[n];
                if (void 0 !== o) if (Array.isArray(o)) for (; void 0 !== (o = a[n]) && (t.push(a.time), i.push.apply(i, o)), void 0 !== (a = e[r++]);) ; else if (void 0 !== o.toArray) for (; void 0 !== (o = a[n]) && (t.push(a.time), o.toArray(i, i.length)), void 0 !== (a = e[r++]);) ; else for (; void 0 !== (o = a[n]) && (t.push(a.time), i.push(o)), void 0 !== (a = e[r++]);) ;
            }
        }
    };

    function Ty(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i
    }

    function Sy(e, t, i, n) {
        Ty.call(this, e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
    }

    function Ey(e, t, i, n) {
        Ty.call(this, e, t, i, n)
    }

    function Ay(e, t, i, n) {
        Ty.call(this, e, t, i, n)
    }

    function My(e, t, i, n) {
        if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = wy.convertArray(t, this.TimeBufferType), this.values = wy.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }

    function Py(e, t, i) {
        My.call(this, e, t, i)
    }

    function Ly(e, t, i, n) {
        My.call(this, e, t, i, n)
    }

    function Cy(e, t, i, n) {
        My.call(this, e, t, i, n)
    }

    function Iy(e, t, i, n) {
        Ty.call(this, e, t, i, n)
    }

    function Ry(e, t, i, n) {
        My.call(this, e, t, i, n)
    }

    function Oy(e, t, i, n) {
        My.call(this, e, t, i, n)
    }

    function Fy(e, t, i, n) {
        My.call(this, e, t, i, n)
    }

    function Ny(e, t, i) {
        this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = fu.generateUUID(), this.duration < 0 && this.resetDuration()
    }

    function ky(e) {
        if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t = function (e) {
            switch (e.toLowerCase()) {
                case"scalar":
                case"double":
                case"float":
                case"number":
                case"integer":
                    return Cy;
                case"vector":
                case"vector2":
                case"vector3":
                case"vector4":
                    return Fy;
                case"color":
                    return Ly;
                case"quaternion":
                    return Ry;
                case"bool":
                case"boolean":
                    return Py;
                case"string":
                    return Oy
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        if (void 0 === e.times) {
            var i = [], n = [];
            wy.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    }

    function Uy(e) {
        this.manager = void 0 !== e ? e : kv, this.textures = {}
    }

    function Dy(e) {
        this.manager = void 0 !== e ? e : kv
    }

    Object.assign(Ty.prototype, {
        evaluate: function (e) {
            var t = this.parameterPositions, i = this._cachedIndex, n = t[i], r = t[i - 1];
            e:{
                t:{
                    var a;
                    i:{
                        n:if (!(e < n)) {
                            for (var o = i + 2; ;) {
                                if (void 0 === n) {
                                    if (e < r) break n;
                                    return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r)
                                }
                                if (i === o) break;
                                if (r = n, e < (n = t[++i])) break t
                            }
                            a = t.length;
                            break i
                        }
                        if (r <= e) break e;
                        var s = t[1];
                        e < s && (i = 2, r = s);
                        for (o = i - 2; ;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                            if (i === o) break;
                            if (n = r, (r = t[--i - 1]) <= e) break t
                        }
                        a = i, i = 0
                    }
                    for (; i < a;) {
                        var l = i + a >>> 1;
                        e < t[l] ? a = l : i = l + 1
                    }
                    if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, n);
                    if (void 0 === n) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i, this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        }, settings: null, DefaultSettings_: {}, getSettings_: function () {
            return this.settings || this.DefaultSettings_
        }, copySampleValue_: function (e) {
            for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n, a = 0; a !== n; ++a) t[a] = i[r + a];
            return t
        }, interpolate_: function () {
            throw new Error("call to abstract method")
        }, intervalChanged_: function () {
        }
    }), Object.assign(Ty.prototype, {
        beforeStart_: Ty.prototype.copySampleValue_, afterEnd_: Ty.prototype.copySampleValue_
    }), Sy.prototype = Object.assign(Object.create(Ty.prototype), {
        constructor: Sy, DefaultSettings_: {endingStart: eu, endingEnd: eu}, intervalChanged_: function (e, t, i) {
            var n = this.parameterPositions, r = e - 2, a = e + 1, o = n[r], s = n[a];
            if (void 0 === o) switch (this.getSettings_().endingStart) {
                case tu:
                    r = e, o = 2 * t - i;
                    break;
                case 2402:
                    o = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e, o = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case tu:
                    a = e, s = 2 * i - t;
                    break;
                case 2402:
                    s = i + n[a = 1] - n[0];
                    break;
                default:
                    a = e - 1, s = t
            }
            var l = .5 * (i - t), h = this.valueSize;
            this._weightPrev = l / (t - o), this._weightNext = l / (s - i), this._offsetPrev = r * h, this._offsetNext = a * h
        }, interpolate_: function (e, t, i, n) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, h = this._offsetPrev, c = this._offsetNext, u = this._weightPrev, p = this._weightNext, d = (i - t) / (n - t), f = d * d, m = f * d, g = -u * m + 2 * u * f - u * d, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, _ = p * m - p * f, x = 0; x !== o; ++x) r[x] = g * a[h + x] + v * a[l + x] + y * a[s + x] + _ * a[c + x];
            return r
        }
    }), Ey.prototype = Object.assign(Object.create(Ty.prototype), {
        constructor: Ey, interpolate_: function (e, t, i, n) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, h = (i - t) / (n - t), c = 1 - h, u = 0; u !== o; ++u) r[u] = a[l + u] * c + a[s + u] * h;
            return r
        }
    }), Ay.prototype = Object.assign(Object.create(Ty.prototype), {
        constructor: Ay, interpolate_: function (e) {
            return this.copySampleValue_(e - 1)
        }
    }), Object.assign(My, {
        toJSON: function (e) {
            var t, i = e.constructor;
            if (void 0 !== i.toJSON) t = i.toJSON(e); else {
                t = {name: e.name, times: wy.convertArray(e.times, Array), values: wy.convertArray(e.values, Array)};
                var n = e.getInterpolation();
                n !== e.DefaultInterpolation && (t.interpolation = n)
            }
            return t.type = e.ValueTypeName, t
        }
    }), Object.assign(My.prototype, {
        constructor: My,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (e) {
            return new Ay(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodLinear: function (e) {
            return new Ey(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: function (e) {
            return new Sy(this.times, this.values, this.getValueSize(), e)
        },
        setInterpolation: function (e) {
            var t;
            switch (e) {
                case 2300:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 !== t) return this.createInterpolant = t, this;
            var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw new Error(i);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("THREE.KeyframeTrack:", i), this
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (e) {
            if (0 !== e) for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e;
            return this
        },
        scale: function (e) {
            if (1 !== e) for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e;
            return this
        },
        trim: function (e, t) {
            for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e;) ++r;
            for (; -1 !== a && i[a] > t;) --a;
            if (++a, 0 !== r || a !== n) {
                a <= r && (r = (a = Math.max(a, 1)) - 1);
                var o = this.getValueSize();
                this.times = wy.arraySlice(i, r, a), this.values = wy.arraySlice(this.values, r * o, a * o)
            }
            return this
        },
        validate: function () {
            var e = !0, t = this.getValueSize();
            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
            var i = this.times, n = this.values, r = i.length;
            0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
            for (var a = null, o = 0; o !== r; o++) {
                var s = i[o];
                if ("number" == typeof s && isNaN(s)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                    break
                }
                if (null !== a && s < a) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                    break
                }
                a = s
            }
            if (void 0 !== n && wy.isTypedArray(n)) {
                o = 0;
                for (var l = n.length; o !== l; ++o) {
                    var h = n[o];
                    if (isNaN(h)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, h), e = !1;
                        break
                    }
                }
            }
            return e
        },
        optimize: function () {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; o < a; ++o) {
                var s = !1, l = e[o];
                if (l !== e[o + 1] && (1 !== o || l !== l[0])) if (n) s = !0; else for (var h = o * i, c = h - i, u = h + i, p = 0; p !== i; ++p) {
                    var d = t[h + p];
                    if (d !== t[c + p] || d !== t[u + p]) {
                        s = !0;
                        break
                    }
                }
                if (s) {
                    if (o !== r) {
                        e[r] = e[o];
                        var f = o * i, m = r * i;
                        for (p = 0; p !== i; ++p) t[m + p] = t[f + p]
                    }
                    ++r
                }
            }
            if (0 < a) {
                e[r] = e[a];
                for (f = a * i, m = r * i, p = 0; p !== i; ++p) t[m + p] = t[f + p];
                ++r
            }
            return r !== e.length && (this.times = wy.arraySlice(e, 0, r), this.values = wy.arraySlice(t, 0, r * i)), this
        }
    }), Py.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Py,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Ly.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Ly, ValueTypeName: "color"
    }), Cy.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Cy, ValueTypeName: "number"
    }), Iy.prototype = Object.assign(Object.create(Ty.prototype), {
        constructor: Iy, interpolate_: function (e, t, i, n) {
            for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = (i - t) / (n - t), h = s + o; s !== h; s += 4) vu.slerpFlat(r, 0, a, s - o, a, s, l);
            return r
        }
    }), Ry.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Ry,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (e) {
            return new Iy(this.times, this.values, this.getValueSize(), e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), Oy.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Oy,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), Fy.prototype = Object.assign(Object.create(My.prototype), {
        constructor: Fy, ValueTypeName: "vector"
    }), Object.assign(Ny, {
        parse: function (e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r) t.push(ky(i[r]).scale(n));
            return new Ny(e.name, e.duration, t)
        }, toJSON: function (e) {
            for (var t = [], i = e.tracks, n = {
                name: e.name, duration: e.duration, tracks: t, uuid: e.uuid
            }, r = 0, a = i.length; r !== a; ++r) t.push(My.toJSON(i[r]));
            return n
        }, CreateFromMorphTargetSequence: function (e, t, i, n) {
            for (var r = t.length, a = [], o = 0; o < r; o++) {
                var s = [], l = [];
                s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                var h = wy.getKeyframeOrder(s);
                s = wy.sortedArray(s, 1, h), l = wy.sortedArray(l, 1, h), n || 0 !== s[0] || (s.push(r), l.push(l[0])), a.push(new Cy(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / i))
            }
            return new Ny(e, -1, a)
        }, findByName: function (e, t) {
            var i = e;
            if (!Array.isArray(e)) {
                var n = e;
                i = n.geometry && n.geometry.animations || n.animations
            }
            for (var r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
            return null
        }, CreateClipsFromMorphTargetSequences: function (e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s = e[a], l = s.name.match(r);
                if (l && 1 < l.length) {
                    var h = n[u = l[1]];
                    h || (n[u] = h = []), h.push(s)
                }
            }
            var c = [];
            for (var u in n) c.push(Ny.CreateFromMorphTargetSequence(u, n[u], t, i));
            return c
        }, parseAnimation: function (e, t) {
            if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            for (var i = function (e, t, i, n, r) {
                if (0 !== i.length) {
                    var a = [], o = [];
                    wy.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new e(t, a, o))
                }
            }, n = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                var h = s[l].keys;
                if (h && 0 !== h.length) if (h[0].morphTargets) {
                    for (var c = {}, u = 0; u < h.length; u++) if (h[u].morphTargets) for (var p = 0; p < h[u].morphTargets.length; p++) c[h[u].morphTargets[p]] = -1;
                    for (var d in c) {
                        var f = [], m = [];
                        for (p = 0; p !== h[u].morphTargets.length; ++p) {
                            var g = h[u];
                            f.push(g.time), m.push(g.morphTarget === d ? 1 : 0)
                        }
                        n.push(new Cy(".morphTargetInfluence[" + d + "]", f, m))
                    }
                    a = c.length * (o || 1)
                } else {
                    var v = ".bones[" + t[l].name + "]";
                    i(Fy, v + ".position", h, "pos", n), i(Ry, v + ".quaternion", h, "rot", n), i(Fy, v + ".scale", h, "scl", n)
                }
            }
            return 0 === n.length ? null : new Ny(r, a, n)
        }
    }), Object.assign(Ny.prototype, {
        resetDuration: function () {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
                var n = this.tracks[t];
                e = Math.max(e, n.times[n.times.length - 1])
            }
            return this.duration = e, this
        }, trim: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
            return this
        }, validate: function () {
            for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
            return e
        }, optimize: function () {
            for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
            return this
        }
    }), Object.assign(Uy.prototype, {
        load: function (e, t, i, n) {
            var r = this;
            new Dv(r.manager).load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        }, setTextures: function (e) {
            this.textures = e
        }, parse: function (e) {
            var t = this.textures;

            function i(e) {
                return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
            }

            var n = new Ov[e.type];
            if (void 0 !== e.uuid && (n.uuid = e.uuid), void 0 !== e.name && (n.name = e.name), void 0 !== e.color && n.color.setHex(e.color), void 0 !== e.roughness && (n.roughness = e.roughness), void 0 !== e.metalness && (n.metalness = e.metalness), void 0 !== e.emissive && n.emissive.setHex(e.emissive), void 0 !== e.specular && n.specular.setHex(e.specular), void 0 !== e.shininess && (n.shininess = e.shininess), void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors), void 0 !== e.fog && (n.fog = e.fog), void 0 !== e.flatShading && (n.flatShading = e.flatShading), void 0 !== e.blending && (n.blending = e.blending), void 0 !== e.combine && (n.combine = e.combine), void 0 !== e.side && (n.side = e.side), void 0 !== e.opacity && (n.opacity = e.opacity), void 0 !== e.transparent && (n.transparent = e.transparent), void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest), void 0 !== e.depthTest && (n.depthTest = e.depthTest), void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite), void 0 !== e.wireframe && (n.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (n.rotation = e.rotation), 1 !== e.linewidth && (n.linewidth = e.linewidth), void 0 !== e.dashSize && (n.dashSize = e.dashSize), void 0 !== e.gapSize && (n.gapSize = e.gapSize), void 0 !== e.scale && (n.scale = e.scale), void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (n.skinning = e.skinning), void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets), void 0 !== e.dithering && (n.dithering = e.dithering), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.uniforms) for (var r in e.uniforms) {
                var a = e.uniforms[r];
                switch (n.uniforms[r] = {}, a.type) {
                    case"t":
                        n.uniforms[r].value = i(a.value);
                        break;
                    case"c":
                        n.uniforms[r].value = (new $u).setHex(a.value);
                        break;
                    case"v2":
                        n.uniforms[r].value = (new mu).fromArray(a.value);
                        break;
                    case"v3":
                        n.uniforms[r].value = (new yu).fromArray(a.value);
                        break;
                    case"v4":
                        n.uniforms[r].value = (new zu).fromArray(a.value);
                        break;
                    case"m4":
                        n.uniforms[r].value = (new gu).fromArray(a.value);
                        break;
                    default:
                        n.uniforms[r].value = a.value
                }
            }
            if (void 0 !== e.defines && (n.defines = e.defines), void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader), void 0 !== e.shading && (n.flatShading = 1 === e.shading), void 0 !== e.size && (n.size = e.size), void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (n.map = i(e.map)), void 0 !== e.alphaMap && (n.alphaMap = i(e.alphaMap), n.transparent = !0), void 0 !== e.bumpMap && (n.bumpMap = i(e.bumpMap)), void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale), void 0 !== e.normalMap && (n.normalMap = i(e.normalMap)), void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                var o = e.normalScale;
                !1 === Array.isArray(o) && (o = [o, o]), n.normalScale = (new mu).fromArray(o)
            }
            return void 0 !== e.displacementMap && (n.displacementMap = i(e.displacementMap)), void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (n.roughnessMap = i(e.roughnessMap)), void 0 !== e.metalnessMap && (n.metalnessMap = i(e.metalnessMap)), void 0 !== e.emissiveMap && (n.emissiveMap = i(e.emissiveMap)), void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (n.specularMap = i(e.specularMap)), void 0 !== e.envMap && (n.envMap = i(e.envMap)), void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity), void 0 !== e.lightMap && (n.lightMap = i(e.lightMap)), void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (n.aoMap = i(e.aoMap)), void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (n.gradientMap = i(e.gradientMap)), n
        }
    }), Object.assign(Dy.prototype, {
        load: function (e, t, i, n) {
            var r = this;
            new Dv(r.manager).load(e, function (e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        }, parse: function (e) {
            var t = new sd, i = e.data.index;
            if (void 0 !== i) {
                var n = new jy[i.type](i.array);
                t.setIndex(new Dp(n, 1))
            }
            var r = e.data.attributes;
            for (var a in r) {
                var o = r[a];
                n = new jy[o.type](o.array);
                t.addAttribute(a, new Dp(n, o.itemSize, o.normalized))
            }
            var s = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== s) for (var l = 0, h = s.length; l !== h; ++l) {
                var c = s[l];
                t.addGroup(c.start, c.count, c.materialIndex)
            }
            var u = e.data.boundingSphere;
            if (void 0 !== u) {
                var p = new yu;
                void 0 !== u.center && p.fromArray(u.center), t.boundingSphere = new Vu(p, u.radius)
            }
            return t
        }
    });
    var zy, By, Hy, Gy, jy = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };

    function Vy() {
    }

    Vy.Handlers = {
        handlers: [], add: function (e, t) {
            this.handlers.push(e, t)
        }, get: function (e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i], a = t[i + 1];
                if (r.test(e)) return a
            }
            return null
        }
    }, Object.assign(Vy.prototype, {
        crossOrigin: "anonymous", onLoadStart: function () {
        }, onLoadProgress: function () {
        }, onLoadComplete: function () {
        }, initMaterials: function (e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i);
            return n
        }, createMaterial: (zy = {
            NoBlending: uh,
            NormalBlending: ph,
            AdditiveBlending: dh,
            SubtractiveBlending: fh,
            MultiplyBlending: mh,
            CustomBlending: gh
        }, By = new $u, Hy = new Hv, Gy = new Uy, function (e, h, c) {
            var u = {};

            function t(e, t, i, n, r) {
                var a, o = h + e, s = Vy.Handlers.get(o);
                a = null !== s ? s.load(o) : (Hy.setCrossOrigin(c), Hy.load(o)), void 0 !== t && (a.repeat.fromArray(t), 1 !== t[0] && (a.wrapS = ic), 1 !== t[1] && (a.wrapT = ic)), void 0 !== i && a.offset.fromArray(i), void 0 !== n && ("repeat" === n[0] && (a.wrapS = ic), "mirror" === n[0] && (a.wrapS = rc), "repeat" === n[1] && (a.wrapT = ic), "mirror" === n[1] && (a.wrapT = rc)), void 0 !== r && (a.anisotropy = r);
                var l = fu.generateUUID();
                return u[l] = a, l
            }

            var i = {uuid: fu.generateUUID(), type: "MeshLambertMaterial"};
            for (var n in e) {
                var r = e[n];
                switch (n) {
                    case"DbgColor":
                    case"DbgIndex":
                    case"opticalDensity":
                    case"illumination":
                        break;
                    case"DbgName":
                        i.name = r;
                        break;
                    case"blending":
                        i.blending = zy[r];
                        break;
                    case"colorAmbient":
                    case"mapAmbient":
                        console.warn("THREE.Loader.createMaterial:", n, "is no longer supported.");
                        break;
                    case"colorDiffuse":
                        i.color = By.fromArray(r).getHex();
                        break;
                    case"colorSpecular":
                        i.specular = By.fromArray(r).getHex();
                        break;
                    case"colorEmissive":
                        i.emissive = By.fromArray(r).getHex();
                        break;
                    case"specularCoef":
                        i.shininess = r;
                        break;
                    case"shading":
                        "basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"), "phong" === r.toLowerCase() && (i.type = "MeshPhongMaterial"), "standard" === r.toLowerCase() && (i.type = "MeshStandardMaterial");
                        break;
                    case"mapDiffuse":
                        i.map = t(r, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                        break;
                    case"mapDiffuseRepeat":
                    case"mapDiffuseOffset":
                    case"mapDiffuseWrap":
                    case"mapDiffuseAnisotropy":
                        break;
                    case"mapEmissive":
                        i.emissiveMap = t(r, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                        break;
                    case"mapEmissiveRepeat":
                    case"mapEmissiveOffset":
                    case"mapEmissiveWrap":
                    case"mapEmissiveAnisotropy":
                        break;
                    case"mapLight":
                        i.lightMap = t(r, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                        break;
                    case"mapLightRepeat":
                    case"mapLightOffset":
                    case"mapLightWrap":
                    case"mapLightAnisotropy":
                        break;
                    case"mapAO":
                        i.aoMap = t(r, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                        break;
                    case"mapAORepeat":
                    case"mapAOOffset":
                    case"mapAOWrap":
                    case"mapAOAnisotropy":
                        break;
                    case"mapBump":
                        i.bumpMap = t(r, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                        break;
                    case"mapBumpScale":
                        i.bumpScale = r;
                        break;
                    case"mapBumpRepeat":
                    case"mapBumpOffset":
                    case"mapBumpWrap":
                    case"mapBumpAnisotropy":
                        break;
                    case"mapNormal":
                        i.normalMap = t(r, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                        break;
                    case"mapNormalFactor":
                        i.normalScale = r;
                        break;
                    case"mapNormalRepeat":
                    case"mapNormalOffset":
                    case"mapNormalWrap":
                    case"mapNormalAnisotropy":
                        break;
                    case"mapSpecular":
                        i.specularMap = t(r, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                        break;
                    case"mapSpecularRepeat":
                    case"mapSpecularOffset":
                    case"mapSpecularWrap":
                    case"mapSpecularAnisotropy":
                        break;
                    case"mapMetalness":
                        i.metalnessMap = t(r, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                        break;
                    case"mapMetalnessRepeat":
                    case"mapMetalnessOffset":
                    case"mapMetalnessWrap":
                    case"mapMetalnessAnisotropy":
                        break;
                    case"mapRoughness":
                        i.roughnessMap = t(r, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                        break;
                    case"mapRoughnessRepeat":
                    case"mapRoughnessOffset":
                    case"mapRoughnessWrap":
                    case"mapRoughnessAnisotropy":
                        break;
                    case"mapAlpha":
                        i.alphaMap = t(r, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                        break;
                    case"mapAlphaRepeat":
                    case"mapAlphaOffset":
                    case"mapAlphaWrap":
                    case"mapAlphaAnisotropy":
                        break;
                    case"flipSided":
                        i.side = lh;
                        break;
                    case"doubleSided":
                        i.side = hh;
                        break;
                    case"transparency":
                        console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), i.opacity = r;
                        break;
                    case"depthTest":
                    case"depthWrite":
                    case"colorWrite":
                    case"opacity":
                    case"reflectivity":
                    case"transparent":
                    case"visible":
                    case"wireframe":
                        i[n] = r;
                        break;
                    case"vertexColors":
                        !0 === r && (i.vertexColors = 2), "face" === r && (i.vertexColors = 1);
                        break;
                    default:
                        console.error("THREE.Loader.createMaterial: Unsupported", n, r)
                }
            }
            return "MeshBasicMaterial" === i.type && delete i.emissive, "MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 && (i.transparent = !0), Gy.setTextures(u), Gy.parse(i)
        })
    });
    var Xy = function (e) {
        var t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1)
    };

    function Wy(e) {
        "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : kv, this.withCredentials = !1
    }

    Object.assign(Wy.prototype, {
        crossOrigin: "anonymous", load: function (a, o, e, t) {
            var s = this, l = void 0 === this.path ? Xy(a) : this.path, i = new Dv(this.manager);
            i.setPath(this.path), i.setWithCredentials(this.withCredentials), i.load(a, function (e) {
                var t = JSON.parse(e), i = t.metadata;
                if (void 0 !== i) {
                    var n = i.type;
                    if (void 0 !== n && "object" === n.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.")
                }
                var r = s.parse(t, l);
                o(r.geometry, r.materials)
            }, e, t)
        }, setPath: function (e) {
            return this.path = e, this
        }, setResourcePath: function (e) {
            return this.resourcePath = e, this
        }, setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        }, parse: function (e, t) {
            void 0 !== e.data && (e = e.data), void 0 !== e.scale ? e.scale = 1 / e.scale : e.scale = 1;
            var i = new Up;
            return function (e, t) {
                function i(e, t) {
                    return e & 1 << t
                }

                var n, r, a, o, s, l, h, c, u, p, d, f, m, g, v, y, _, x, b, w, T, S, E, A, M, P = e.faces,
                    L = e.vertices, C = e.normals, I = e.colors, R = e.scale, O = 0;
                if (void 0 !== e.uvs) {
                    for (n = 0; n < e.uvs.length; n++) e.uvs[n].length && O++;
                    for (n = 0; n < O; n++) t.faceVertexUvs[n] = []
                }
                for (o = 0, s = L.length; o < s;) (x = new yu).x = L[o++] * R, x.y = L[o++] * R, x.z = L[o++] * R, t.vertices.push(x);
                for (o = 0, s = P.length; o < s;) if (d = i(p = P[o++], 0), f = i(p, 1), m = i(p, 3), g = i(p, 4), v = i(p, 5), y = i(p, 6), _ = i(p, 7), d) {
                    if ((w = new op).a = P[o], w.b = P[o + 1], w.c = P[o + 3], (T = new op).a = P[o + 1], T.b = P[o + 2], T.c = P[o + 3], o += 4, f && (u = P[o++], w.materialIndex = u, T.materialIndex = u), a = t.faces.length, m) for (n = 0; n < O; n++) for (A = e.uvs[n], t.faceVertexUvs[n][a] = [], t.faceVertexUvs[n][a + 1] = [], r = 0; r < 4; r++) M = new mu(A[2 * (c = P[o++])], A[2 * c + 1]), 2 !== r && t.faceVertexUvs[n][a].push(M), 0 !== r && t.faceVertexUvs[n][a + 1].push(M);
                    if (g && (h = 3 * P[o++], w.normal.set(C[h++], C[h++], C[h]), T.normal.copy(w.normal)), v) for (n = 0; n < 4; n++) h = 3 * P[o++], E = new yu(C[h++], C[h++], C[h]), 2 !== n && w.vertexNormals.push(E), 0 !== n && T.vertexNormals.push(E);
                    if (y && (S = I[l = P[o++]], w.color.setHex(S), T.color.setHex(S)), _) for (n = 0; n < 4; n++) S = I[l = P[o++]], 2 !== n && w.vertexColors.push(new $u(S)), 0 !== n && T.vertexColors.push(new $u(S));
                    t.faces.push(w), t.faces.push(T)
                } else {
                    if ((b = new op).a = P[o++], b.b = P[o++], b.c = P[o++], f && (u = P[o++], b.materialIndex = u), a = t.faces.length, m) for (n = 0; n < O; n++) for (A = e.uvs[n], t.faceVertexUvs[n][a] = [], r = 0; r < 3; r++) M = new mu(A[2 * (c = P[o++])], A[2 * c + 1]), t.faceVertexUvs[n][a].push(M);
                    if (g && (h = 3 * P[o++], b.normal.set(C[h++], C[h++], C[h])), v) for (n = 0; n < 3; n++) h = 3 * P[o++], E = new yu(C[h++], C[h++], C[h]), b.vertexNormals.push(E);
                    if (y && (l = P[o++], b.color.setHex(I[l])), _) for (n = 0; n < 3; n++) l = P[o++], b.vertexColors.push(new $u(I[l]));
                    t.faces.push(b)
                }
            }(e, i), function (e, t) {
                var i = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                if (e.skinWeights) for (var n = 0, r = e.skinWeights.length; n < r; n += i) {
                    var a = e.skinWeights[n], o = 1 < i ? e.skinWeights[n + 1] : 0,
                        s = 2 < i ? e.skinWeights[n + 2] : 0, l = 3 < i ? e.skinWeights[n + 3] : 0;
                    t.skinWeights.push(new zu(a, o, s, l))
                }
                if (e.skinIndices) for (n = 0, r = e.skinIndices.length; n < r; n += i) {
                    var h = e.skinIndices[n], c = 1 < i ? e.skinIndices[n + 1] : 0,
                        u = 2 < i ? e.skinIndices[n + 2] : 0, p = 3 < i ? e.skinIndices[n + 3] : 0;
                    t.skinIndices.push(new zu(h, c, u, p))
                }
                t.bones = e.bones, t.bones && 0 < t.bones.length && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
            }(e, i), function (e, t) {
                var i = e.scale;
                if (void 0 !== e.morphTargets) for (var n = 0, r = e.morphTargets.length; n < r; n++) {
                    t.morphTargets[n] = {}, t.morphTargets[n].name = e.morphTargets[n].name, t.morphTargets[n].vertices = [];
                    for (var a = t.morphTargets[n].vertices, o = e.morphTargets[n].vertices, s = 0, l = o.length; s < l; s += 3) {
                        var h = new yu;
                        h.x = o[s] * i, h.y = o[s + 1] * i, h.z = o[s + 2] * i, a.push(h)
                    }
                }
                if (void 0 !== e.morphColors && 0 < e.morphColors.length) {
                    console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                    var c = t.faces, u = e.morphColors[0].colors;
                    for (n = 0, r = c.length; n < r; n++) c[n].color.fromArray(u, 3 * n)
                }
            }(e, i), function (e, t) {
                var i = [], n = [];
                void 0 !== e.animation && n.push(e.animation), void 0 !== e.animations && (e.animations.length ? n = n.concat(e.animations) : n.push(e.animations));
                for (var r = 0; r < n.length; r++) {
                    var a = Ny.parseAnimation(n[r], t.bones);
                    a && i.push(a)
                }
                if (t.morphTargets) {
                    var o = Ny.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                    i = i.concat(o)
                }
                0 < i.length && (t.animations = i)
            }(e, i), i.computeFaceNormals(), i.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length ? {geometry: i} : {
                geometry: i,
                materials: Vy.prototype.initMaterials(e.materials, this.resourcePath || t, this.crossOrigin)
            }
        }
    }), Object.assign(function (e) {
        this.manager = void 0 !== e ? e : kv, this.texturePath = ""
    }.prototype, {
        crossOrigin: "anonymous", load: function (n, r, e, a) {
            "" === this.texturePath && (this.texturePath = n.substring(0, n.lastIndexOf("/") + 1));
            var o = this;
            new Dv(o.manager).load(n, function (e) {
                var t = null;
                try {
                    t = JSON.parse(e)
                } catch (e) {
                    return void 0 !== a && a(e), void console.error("THREE:ObjectLoader: Can't parse " + n + ".", e.message)
                }
                var i = t.metadata;
                void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() ? o.parse(t, r) : console.error("THREE.ObjectLoader: Can't load " + n + ". Use THREE.JSONLoader instead.")
            }, e, a)
        }, setTexturePath: function (e) {
            return this.texturePath = e, this
        }, setCrossOrigin: function (e) {
            return this.crossOrigin = e, this
        }, parse: function (e, t) {
            var i = this.parseShape(e.shapes), n = this.parseGeometries(e.geometries, i),
                r = this.parseImages(e.images, function () {
                    void 0 !== t && t(s)
                }), a = this.parseTextures(e.textures, r), o = this.parseMaterials(e.materials, a),
                s = this.parseObject(e.object, n, o);
            return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
        }, parseShape: function (e) {
            var t = {};
            if (void 0 !== e) for (var i = 0, n = e.length; i < n; i++) {
                var r = (new cy).fromJSON(e[i]);
                t[r.uuid] = r
            }
            return t
        }, parseGeometries: function (e, t) {
            var i = {};
            if (void 0 !== e) for (var n = new Wy, r = new Dy, a = 0, o = e.length; a < o; a++) {
                var s, l = e[a];
                switch (l.type) {
                    case"PlaneGeometry":
                    case"PlaneBufferGeometry":
                        s = new wv[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                        break;
                    case"BoxGeometry":
                    case"BoxBufferGeometry":
                    case"CubeGeometry":
                        s = new wv[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                        break;
                    case"CircleGeometry":
                    case"CircleBufferGeometry":
                        s = new wv[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                        break;
                    case"CylinderGeometry":
                    case"CylinderBufferGeometry":
                        s = new wv[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                        break;
                    case"ConeGeometry":
                    case"ConeBufferGeometry":
                        s = new wv[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                        break;
                    case"SphereGeometry":
                    case"SphereBufferGeometry":
                        s = new wv[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                        break;
                    case"DodecahedronGeometry":
                    case"DodecahedronBufferGeometry":
                    case"IcosahedronGeometry":
                    case"IcosahedronBufferGeometry":
                    case"OctahedronGeometry":
                    case"OctahedronBufferGeometry":
                    case"TetrahedronGeometry":
                    case"TetrahedronBufferGeometry":
                        s = new wv[l.type](l.radius, l.detail);
                        break;
                    case"RingGeometry":
                    case"RingBufferGeometry":
                        s = new wv[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                        break;
                    case"TorusGeometry":
                    case"TorusBufferGeometry":
                        s = new wv[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                        break;
                    case"TorusKnotGeometry":
                    case"TorusKnotBufferGeometry":
                        s = new wv[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                        break;
                    case"LatheGeometry":
                    case"LatheBufferGeometry":
                        s = new wv[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                        break;
                    case"PolyhedronGeometry":
                    case"PolyhedronBufferGeometry":
                        s = new wv[l.type](l.vertices, l.indices, l.radius, l.details);
                        break;
                    case"ShapeGeometry":
                    case"ShapeBufferGeometry":
                        for (var h = [], c = 0, u = l.shapes.length; c < u; c++) {
                            var p = t[l.shapes[c]];
                            h.push(p)
                        }
                        s = new wv[l.type](h, l.curveSegments);
                        break;
                    case"ExtrudeGeometry":
                    case"ExtrudeBufferGeometry":
                        for (h = [], c = 0, u = l.shapes.length; c < u; c++) {
                            p = t[l.shapes[c]];
                            h.push(p)
                        }
                        var d = l.options.extrudePath;
                        void 0 !== d && (l.options.extrudePath = (new sy[d.type]).fromJSON(d)), s = new wv[l.type](h, l.options);
                        break;
                    case"BufferGeometry":
                        s = r.parse(l);
                        break;
                    case"Geometry":
                        s = n.parse(l, this.texturePath).geometry;
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                        continue
                }
                s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), !0 === s.isBufferGeometry && void 0 !== l.userData && (s.userData = l.userData), i[l.uuid] = s
            }
            return i
        }, parseMaterials: function (e, t) {
            var i = {};
            if (void 0 !== e) {
                var n = new Uy;
                n.setTextures(t);
                for (var r = 0, a = e.length; r < a; r++) {
                    var o = e[r];
                    if ("MultiMaterial" === o.type) {
                        for (var s = [], l = 0; l < o.materials.length; l++) s.push(n.parse(o.materials[l]));
                        i[o.uuid] = s
                    } else i[o.uuid] = n.parse(o)
                }
            }
            return i
        }, parseAnimations: function (e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i], r = Ny.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r)
            }
            return t
        }, parseImages: function (e, t) {
            var i = this, n = {};

            function r(e) {
                return i.manager.itemStart(e), a.load(e, function () {
                    i.manager.itemEnd(e)
                }, void 0, function () {
                    i.manager.itemEnd(e), i.manager.itemError(e)
                })
            }

            if (void 0 !== e && 0 < e.length) {
                var a = new zv(new Nv(t));
                a.setCrossOrigin(this.crossOrigin);
                for (var o = 0, s = e.length; o < s; o++) {
                    var l = e[o], h = l.url;
                    if (Array.isArray(h)) {
                        n[l.uuid] = [];
                        for (var c = 0, u = h.length; c < u; c++) {
                            var p = h[c], d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.texturePath + p;
                            n[l.uuid].push(r(d))
                        }
                    } else {
                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.texturePath + l.url;
                        n[l.uuid] = r(d)
                    }
                }
            }
            return n
        }, parseTextures: function (e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
            }

            var n = {};
            if (void 0 !== e) for (var r = 0, a = e.length; r < a; r++) {
                var o, s = e[r];
                void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (o = Array.isArray(t[s.image]) ? new tf(t[s.image]) : new Du(t[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, qy)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], Qy), o.wrapT = i(s.wrap[1], Qy)), void 0 !== s.format && (o.format = s.format), void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, Zy)), void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, Zy)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), n[s.uuid] = o
            }
            return n
        }, parseObject: function (e, t, a) {
            var i;

            function n(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
            }

            function r(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], i = 0, n = e.length; i < n; i++) {
                            var r = e[i];
                            void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r), t.push(a[r])
                        }
                        return t
                    }
                    return void 0 === a[e] && console.warn("THREE.ObjectLoader: Undefined material", e), a[e]
                }
            }

            switch (e.type) {
                case"Scene":
                    i = new Wm, void 0 !== e.background && Number.isInteger(e.background) && (i.background = new $u(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Xm(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new Vm(e.fog.color, e.fog.density)));
                    break;
                case"PerspectiveCamera":
                    i = new zm(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (i.focus = e.focus), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset), void 0 !== e.view && (i.view = Object.assign({}, e.view));
                    break;
                case"OrthographicCamera":
                    i = new vy(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.view && (i.view = Object.assign({}, e.view));
                    break;
                case"AmbientLight":
                    i = new xy(e.color, e.intensity);
                    break;
                case"DirectionalLight":
                    i = new _y(e.color, e.intensity);
                    break;
                case"PointLight":
                    i = new gy(e.color, e.intensity, e.distance, e.decay);
                    break;
                case"RectAreaLight":
                    i = new by(e.color, e.intensity, e.width, e.height);
                    break;
                case"SpotLight":
                    i = new my(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                    break;
                case"HemisphereLight":
                    i = new py(e.color, e.groundColor, e.intensity);
                    break;
                case"SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case"Mesh":
                    var o = n(e.geometry), s = r(e.material);
                    i = o.bones && 0 < o.bones.length ? new eg(o, s) : new jd(o, s);
                    break;
                case"LOD":
                    i = new Jm;
                    break;
                case"Line":
                    i = new ig(n(e.geometry), r(e.material), e.mode);
                    break;
                case"LineLoop":
                    i = new rg(n(e.geometry), r(e.material));
                    break;
                case"LineSegments":
                    i = new ng(n(e.geometry), r(e.material));
                    break;
                case"PointCloud":
                case"Points":
                    i = new og(n(e.geometry), r(e.material));
                    break;
                case"Sprite":
                    i = new Zm(r(e.material));
                    break;
                case"Group":
                    i = new Um;
                    break;
                default:
                    i = new Pp
            }
            if (i.uuid = e.uuid, void 0 !== e.name && (i.name = e.name), void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position), void 0 !== e.rotation && i.rotation.fromArray(e.rotation), void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion), void 0 !== e.scale && i.scale.fromArray(e.scale)), void 0 !== e.castShadow && (i.castShadow = e.castShadow), void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.layers && (i.layers.mask = e.layers), void 0 !== e.children) for (var l = e.children, h = 0; h < l.length; h++) i.add(this.parseObject(l[h], t, a));
            if ("LOD" === e.type) for (var c = e.levels, u = 0; u < c.length; u++) {
                var p = c[u], d = i.getObjectByProperty("uuid", p.object);
                void 0 !== d && i.addLevel(d, p.distance)
            }
            return i
        }
    });
    var Yy, qy = {
        UVMapping: 300,
        CubeReflectionMapping: Qh,
        CubeRefractionMapping: Zh,
        EquirectangularReflectionMapping: Jh,
        EquirectangularRefractionMapping: Kh,
        SphericalReflectionMapping: $h,
        CubeUVReflectionMapping: ec,
        CubeUVRefractionMapping: tc
    }, Qy = {RepeatWrapping: ic, ClampToEdgeWrapping: nc, MirroredRepeatWrapping: rc}, Zy = {
        NearestFilter: ac,
        NearestMipMapNearestFilter: oc,
        NearestMipMapLinearFilter: sc,
        LinearFilter: lc,
        LinearMipMapNearestFilter: hc,
        LinearMipMapLinearFilter: cc
    };

    function Jy() {
        this.type = "ShapePath", this.color = new $u, this.subPaths = [], this.currentPath = null
    }

    function Ky(e) {
        this.type = "Font", this.data = e
    }

    function $y(e, t, i, n, r) {
        var a = r.glyphs[e] || r.glyphs["?"];
        if (a) {
            var o, s, l, h, c, u, p, d, f = new Jy;
            if (a.o) for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) {
                switch (m[g++]) {
                    case"m":
                        o = m[g++] * t + i, s = m[g++] * t + n, f.moveTo(o, s);
                        break;
                    case"l":
                        o = m[g++] * t + i, s = m[g++] * t + n, f.lineTo(o, s);
                        break;
                    case"q":
                        l = m[g++] * t + i, h = m[g++] * t + n, c = m[g++] * t + i, u = m[g++] * t + n, f.quadraticCurveTo(c, u, l, h);
                        break;
                    case"b":
                        l = m[g++] * t + i, h = m[g++] * t + n, c = m[g++] * t + i, u = m[g++] * t + n, p = m[g++] * t + i, d = m[g++] * t + n, f.bezierCurveTo(c, u, p, d, l, h)
                }
            }
            return {offsetX: a.ha * t, path: f}
        }
    }

    Object.assign(Jy.prototype, {
        moveTo: function (e, t) {
            this.currentPath = new hy, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
        }, lineTo: function (e, t) {
            this.currentPath.lineTo(e, t)
        }, quadraticCurveTo: function (e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        }, bezierCurveTo: function (e, t, i, n, r, a) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, a)
        }, splineThru: function (e) {
            this.currentPath.splineThru(e)
        }, toShapes: function (e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i], a = new cy;
                    a.curves = r.curves, t.push(a)
                }
                return t
            }

            function n(e, t) {
                for (var i = t.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                    var o = t[r], s = t[a], l = s.x - o.x, h = s.y - o.y;
                    if (Math.abs(h) > Number.EPSILON) {
                        if (h < 0 && (o = t[a], l = -l, s = t[r], h = -h), e.y < o.y || e.y > s.y) continue;
                        if (e.y === o.y) {
                            if (e.x === o.x) return !0
                        } else {
                            var c = h * (e.x - o.x) - l * (e.y - o.y);
                            if (0 === c) return !0;
                            if (c < 0) continue;
                            n = !n
                        }
                    } else {
                        if (e.y !== o.y) continue;
                        if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0
                    }
                }
                return n
            }

            var r = Jg.isClockWise, a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === t) return i(a);
            var o, s, l, h = [];
            if (1 === a.length) return s = a[0], (l = new cy).curves = s.curves, h.push(l), h;
            var c = !r(a[0].getPoints());
            c = e ? !c : c;
            var u, p, d = [], f = [], m = [], g = 0;
            f[g] = void 0, m[g] = [];
            for (var v = 0, y = a.length; v < y; v++) o = r(u = (s = a[v]).getPoints()), (o = e ? !o : o) ? (!c && f[g] && g++, f[g] = {
                s: new cy, p: u
            }, f[g].s.curves = s.curves, c && g++, m[g] = []) : m[g].push({h: s, p: u[0]});
            if (!f[0]) return i(a);
            if (1 < f.length) {
                for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) d[b] = [];
                for (b = 0, w = f.length; b < w; b++) for (var T = m[b], S = 0; S < T.length; S++) {
                    for (var E = T[S], A = !0, M = 0; M < f.length; M++) n(E.p, f[M].p) && (b !== M && x.push({
                        froms: b, tos: M, hole: S
                    }), A ? (A = !1, d[M].push(E)) : _ = !0);
                    A && d[b].push(E)
                }
                0 < x.length && (_ || (m = d))
            }
            v = 0;
            for (var P = f.length; v < P; v++) {
                l = f[v].s, h.push(l);
                for (var L = 0, C = (p = m[v]).length; L < C; L++) l.holes.push(p[L].h)
            }
            return h
        }
    }), Object.assign(Ky.prototype, {
        isFont: !0, generateShapes: function (e, t) {
            void 0 === t && (t = 100);
            for (var i = [], n = function (e, t, i) {
                for (var n = Array.from ? Array.from(e) : String(e).split(""), r = t / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, o = [], s = 0, l = 0, h = 0; h < n.length; h++) {
                    var c = n[h];
                    if ("\n" === c) s = 0, l -= a; else {
                        var u = $y(c, r, s, l, i);
                        s += u.offsetX, o.push(u.path)
                    }
                }
                return o
            }(e, t, this.data), r = 0, a = n.length; r < a; r++) Array.prototype.push.apply(i, n[r].toShapes());
            return i
        }
    }), Object.assign(function (e) {
        this.manager = void 0 !== e ? e : kv
    }.prototype, {
        load: function (e, n, t, i) {
            var r = this, a = new Dv(this.manager);
            a.setPath(this.path), a.load(e, function (t) {
                var i;
                try {
                    i = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                }
                var e = r.parse(i);
                n && n(e)
            }, t, i)
        }, parse: function (e) {
            return new Ky(e)
        }, setPath: function (e) {
            return this.path = e, this
        }
    });
    var e_, t_, i_, n_, r_, a_, o_, s_, l_, h_, c_, u_, p_, d_, f_, m_, g_, v_, y_ = function () {
        return void 0 === Yy && (Yy = new (window.AudioContext || window.webkitAudioContext)), Yy
    };

    function __(e) {
        this.manager = void 0 !== e ? e : kv
    }

    function x_(e, t, i) {
        Pp.call(this), this.type = "CubeCamera";
        var r = new zm(90, 1, e, t);
        r.up.set(0, -1, 0), r.lookAt(new yu(1, 0, 0)), this.add(r);
        var a = new zm(90, 1, e, t);
        a.up.set(0, -1, 0), a.lookAt(new yu(-1, 0, 0)), this.add(a);
        var o = new zm(90, 1, e, t);
        o.up.set(0, 0, 1), o.lookAt(new yu(0, 1, 0)), this.add(o);
        var s = new zm(90, 1, e, t);
        s.up.set(0, 0, -1), s.lookAt(new yu(0, -1, 0)), this.add(s);
        var l = new zm(90, 1, e, t);
        l.up.set(0, -1, 0), l.lookAt(new yu(0, 0, 1)), this.add(l);
        var h = new zm(90, 1, e, t);
        h.up.set(0, -1, 0), h.lookAt(new yu(0, 0, -1)), this.add(h);
        var n = {format: Sc, magFilter: lc, minFilter: lc};
        this.renderTarget = new Hu(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = this.renderTarget, n = i.texture.generateMipmaps;
            i.texture.generateMipmaps = !1, i.activeCubeFace = 0, e.render(t, r, i), i.activeCubeFace = 1, e.render(t, a, i), i.activeCubeFace = 2, e.render(t, o, i), i.activeCubeFace = 3, e.render(t, s, i), i.activeCubeFace = 4, e.render(t, l, i), i.texture.generateMipmaps = n, i.activeCubeFace = 5, e.render(t, h, i), e.setRenderTarget(null)
        }, this.clear = function (e, t, i, n) {
            for (var r = this.renderTarget, a = 0; a < 6; a++) r.activeCubeFace = a, e.setRenderTarget(r), e.clear(t, i, n);
            e.setRenderTarget(null)
        }
    }

    function b_() {
        Pp.call(this), this.type = "AudioListener", this.context = y_(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
    }

    function w_(e) {
        Pp.call(this), this.type = "Audio", this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function T_(e) {
        w_.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function S_(e, t) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }

    function E_(e, t, i) {
        this.binding = e, this.valueSize = i;
        var n, r = Float64Array;
        switch (t) {
            case"quaternion":
                n = this._slerp;
                break;
            case"string":
            case"bool":
                r = Array, n = this._select;
                break;
            default:
                n = this._lerp
        }
        this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
    }

    Object.assign(__.prototype, {
        load: function (e, i, t, n) {
            var r = new Dv(this.manager);
            r.setResponseType("arraybuffer"), r.load(e, function (e) {
                var t = e.slice(0);
                y_().decodeAudioData(t, function (e) {
                    i(e)
                })
            }, t, n)
        }
    }), Object.assign(function () {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new zm, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new zm, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }.prototype, {
        update: (l_ = new gu, h_ = new gu, function (e) {
            if (e_ !== this || t_ !== e.focus || i_ !== e.fov || n_ !== e.aspect * this.aspect || r_ !== e.near || a_ !== e.far || o_ !== e.zoom || s_ !== this.eyeSep) {
                e_ = this, t_ = e.focus, i_ = e.fov, n_ = e.aspect * this.aspect, r_ = e.near, a_ = e.far, o_ = e.zoom;
                var t, i, n = e.projectionMatrix.clone(), r = (s_ = this.eyeSep / 2) * r_ / t_,
                    a = r_ * Math.tan(fu.DEG2RAD * i_ * .5) / o_;
                h_.elements[12] = -s_, l_.elements[12] = s_, t = -a * n_ + r, i = a * n_ + r, n.elements[0] = 2 * r_ / (i - t), n.elements[8] = (i + t) / (i - t), this.cameraL.projectionMatrix.copy(n), t = -a * n_ - r, i = a * n_ - r, n.elements[0] = 2 * r_ / (i - t), n.elements[8] = (i + t) / (i - t), this.cameraR.projectionMatrix.copy(n)
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(h_), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(l_)
        })
    }), (x_.prototype = Object.create(Pp.prototype)).constructor = x_, b_.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: b_, getInput: function () {
            return this.gain
        }, removeFilter: function () {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        }, getFilter: function () {
            return this.filter
        }, setFilter: function (e) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        }, getMasterVolume: function () {
            return this.gain.gain.value
        }, setMasterVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }, updateMatrixWorld: (c_ = new yu, u_ = new vu, p_ = new yu, d_ = new yu, function (e) {
            Pp.prototype.updateMatrixWorld.call(this, e);
            var t = this.context.listener, i = this.up;
            this.matrixWorld.decompose(c_, u_, p_), d_.set(0, 0, -1).applyQuaternion(u_), t.positionX ? (t.positionX.setValueAtTime(c_.x, this.context.currentTime), t.positionY.setValueAtTime(c_.y, this.context.currentTime), t.positionZ.setValueAtTime(c_.z, this.context.currentTime), t.forwardX.setValueAtTime(d_.x, this.context.currentTime), t.forwardY.setValueAtTime(d_.y, this.context.currentTime), t.forwardZ.setValueAtTime(d_.z, this.context.currentTime), t.upX.setValueAtTime(i.x, this.context.currentTime), t.upY.setValueAtTime(i.y, this.context.currentTime), t.upZ.setValueAtTime(i.z, this.context.currentTime)) : (t.setPosition(c_.x, c_.y, c_.z), t.setOrientation(d_.x, d_.y, d_.z, i.x, i.y, i.z))
        })
    }), w_.prototype = Object.assign(Object.create(Pp.prototype), {
        constructor: w_, getOutput: function () {
            return this.gain
        }, setNodeSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
        }, setMediaElementSource: function (e) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
        }, setBuffer: function (e) {
            return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
        }, play: function () {
            if (!0 !== this.isPlaying) {
                if (!1 !== this.hasPlaybackControl) {
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            } else console.warn("THREE.Audio: Audio is already playing.")
        }, pause: function () {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, stop: function () {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, connect: function () {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        }, disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        }, getFilters: function () {
            return this.filters
        }, setFilters: function (e) {
            return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
        }, getFilter: function () {
            return this.getFilters()[0]
        }, setFilter: function (e) {
            return this.setFilters(e ? [e] : [])
        }, setPlaybackRate: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, getPlaybackRate: function () {
            return this.playbackRate
        }, onEnded: function () {
            this.isPlaying = !1
        }, getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        }, setLoop: function (e) {
            if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, getVolume: function () {
            return this.gain.gain.value
        }, setVolume: function (e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
        }
    }), T_.prototype = Object.assign(Object.create(w_.prototype), {
        constructor: T_, getOutput: function () {
            return this.panner
        }, getRefDistance: function () {
            return this.panner.refDistance
        }, setRefDistance: function (e) {
            return this.panner.refDistance = e, this
        }, getRolloffFactor: function () {
            return this.panner.rolloffFactor
        }, setRolloffFactor: function (e) {
            return this.panner.rolloffFactor = e, this
        }, getDistanceModel: function () {
            return this.panner.distanceModel
        }, setDistanceModel: function (e) {
            return this.panner.distanceModel = e, this
        }, getMaxDistance: function () {
            return this.panner.maxDistance
        }, setMaxDistance: function (e) {
            return this.panner.maxDistance = e, this
        }, setDirectionalCone: function (e, t, i) {
            return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
        }, updateMatrixWorld: (f_ = new yu, m_ = new vu, g_ = new yu, v_ = new yu, function (e) {
            Pp.prototype.updateMatrixWorld.call(this, e);
            var t = this.panner;
            this.matrixWorld.decompose(f_, m_, g_), v_.set(0, 0, 1).applyQuaternion(m_), t.setPosition(f_.x, f_.y, f_.z), t.setOrientation(v_.x, v_.y, v_.z)
        })
    }), Object.assign(S_.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        }, getAverageFrequency: function () {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i];
            return e / t.length
        }
    }), Object.assign(E_.prototype, {
        accumulate: function (e, t) {
            var i = this.buffer, n = this.valueSize, r = e * n + n, a = this.cumulativeWeight;
            if (0 === a) {
                for (var o = 0; o !== n; ++o) i[r + o] = i[o];
                a = t
            } else {
                var s = t / (a += t);
                this._mixBufferRegion(i, r, 0, s, n)
            }
            this.cumulativeWeight = a
        }, apply: function (e) {
            var t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.binding;
            if (this.cumulativeWeight = 0, r < 1) {
                var o = 3 * t;
                this._mixBufferRegion(i, n, o, 1 - r, t)
            }
            for (var s = t, l = t + t; s !== l; ++s) if (i[s] !== i[s + t]) {
                a.setValue(i, n);
                break
            }
        }, saveOriginalState: function () {
            var e = this.binding, t = this.buffer, i = this.valueSize, n = 3 * i;
            e.getValue(t, n);
            for (var r = i, a = n; r !== a; ++r) t[r] = t[n + r % i];
            this.cumulativeWeight = 0
        }, restoreOriginalState: function () {
            var e = 3 * this.valueSize;
            this.binding.setValue(this.buffer, e)
        }, _select: function (e, t, i, n, r) {
            if (.5 <= n) for (var a = 0; a !== r; ++a) e[t + a] = e[i + a]
        }, _slerp: function (e, t, i, n) {
            vu.slerpFlat(e, t, e, t, e, i, n)
        }, _lerp: function (e, t, i, n, r) {
            for (var a = 1 - n, o = 0; o !== r; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[i + o] * n
            }
        }
    });
    var A_, M_, P_, L_, C_, I_, R_, O_, F_, N_, k_, U_, D_, z_, B_, H_, G_, j_, V_, X_, W_, Y_, q_, Q_, Z_, J_, K_, $_,
        ex, tx, ix, nx, rx, ax, ox, sx, lx = "\\[\\]\\.:\\/";

    function hx(e, t, i) {
        var n = i || cx.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, n)
    }

    function cx(e, t, i) {
        this.path = t, this.parsedPath = i || cx.parseTrackName(t), this.node = cx.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
    }

    function ux(e, t, i) {
        this._mixer = e, this._clip = t, this._localRoot = i || null;
        for (var n = t.tracks, r = n.length, a = new Array(r), o = {
            endingStart: eu, endingEnd: eu
        }, s = 0; s !== r; ++s) {
            var l = n[s].createInterpolant(null);
            (a[s] = l).settings = o
        }
        this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }

    function px(e) {
        this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }

    function dx(e) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
    }

    function fx() {
        sd.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function mx(e, t, i) {
        Ym.call(this, e, t), this.meshPerAttribute = i || 1
    }

    function gx(e, t, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), Dp.call(this, e, t, i), this.meshPerAttribute = n || 1
    }

    function vx(e, t) {
        return e.distance - t.distance
    }

    function yx(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) for (var r = e.children, a = 0, o = r.length; a < o; a++) yx(r[a], t, i, !0)
    }

    function _x(e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function xx(e, t) {
        this.min = void 0 !== e ? e : new mu(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new mu(-1 / 0, -1 / 0)
    }

    function bx(e, t) {
        this.start = void 0 !== e ? e : new yu, this.end = void 0 !== t ? t : new yu
    }

    function wx(e) {
        Pp.call(this), this.material = e, this.render = function () {
        }
    }

    function Tx(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var r = void 0 !== i ? i : 16711680, a = void 0 !== n ? n : 1, o = 0, s = this.object.geometry;
        s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
        var l = new sd, h = new Wp(2 * o * 3, 3);
        l.addAttribute("position", h), ng.call(this, l, new tg({
            color: r, linewidth: a
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Sx(e, t) {
        Pp.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        for (var i = new sd, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) {
            var o = r / 32 * Math.PI * 2, s = a / 32 * Math.PI * 2;
            n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1)
        }
        i.addAttribute("position", new Wp(n, 3));
        var l = new tg({fog: !1});
        this.cone = new ng(i, l), this.add(this.cone), this.update()
    }

    function Ex(e) {
        for (var t = function e(t) {
            var i = [];
            t && t.isBone && i.push(t);
            for (var n = 0; n < t.children.length; n++) i.push.apply(i, e(t.children[n]));
            return i
        }(e), i = new sd, n = [], r = [], a = new $u(0, 0, 1), o = new $u(0, 1, 0), s = 0; s < t.length; s++) {
            var l = t[s];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
        }
        i.addAttribute("position", new Wp(n, 3)), i.addAttribute("color", new Wp(r, 3));
        var h = new tg({vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0});
        ng.call(this, i, h), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }

    function Ax(e, t, i) {
        this.light = e, this.light.updateMatrixWorld(), this.color = i;
        var n = new sv(t, 4, 2), r = new Gd({wireframe: !0, fog: !1});
        jd.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Mx(e, t) {
        Pp.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
        var i = new tg({fog: !1}), n = new sd;
        n.addAttribute("position", new Dp(new Float32Array(15), 3)), this.line = new ig(n, i), this.add(this.line), this.update()
    }

    function Px(e, t, i) {
        Pp.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i;
        var n = new _g(t);
        n.rotateY(.5 * Math.PI), this.material = new Gd({
            wireframe: !0, fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2);
        var r = n.getAttribute("position"), a = new Float32Array(3 * r.count);
        n.addAttribute("color", new Dp(a, 3)), this.add(new jd(n, this.material)), this.update()
    }

    function Lx(e, t, i, n) {
        e = e || 10, t = t || 10, i = new $u(void 0 !== i ? i : 4473924), n = new $u(void 0 !== n ? n : 8947848);
        for (var r = t / 2, a = e / t, o = e / 2, s = [], l = [], h = 0, c = 0, u = -o; h <= t; h++, u += a) {
            s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
            var p = h === r ? i : n;
            p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3, p.toArray(l, c), c += 3
        }
        var d = new sd;
        d.addAttribute("position", new Wp(s, 3)), d.addAttribute("color", new Wp(l, 3));
        var f = new tg({vertexColors: 2});
        ng.call(this, d, f)
    }

    function Cx(e, t, i, n, r, a) {
        e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new $u(void 0 !== r ? r : 4473924), a = new $u(void 0 !== a ? a : 8947848);
        var o, s, l, h, c, u, p, d = [], f = [];
        for (h = 0; h <= t; h++) l = h / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, d.push(0, 0, 0), d.push(o, 0, s), p = 1 & h ? r : a, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
        for (h = 0; h <= i; h++) for (p = 1 & h ? r : a, u = e - e / i * h, c = 0; c < n; c++) l = c / n * (2 * Math.PI), o = Math.sin(l) * u, s = Math.cos(l) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b), l = (c + 1) / n * (2 * Math.PI), o = Math.sin(l) * u, s = Math.cos(l) * u, d.push(o, 0, s), f.push(p.r, p.g, p.b);
        var m = new sd;
        m.addAttribute("position", new Wp(d, 3)), m.addAttribute("color", new Wp(f, 3));
        var g = new tg({vertexColors: 2});
        ng.call(this, m, g)
    }

    function Ix(e, t, i, n) {
        this.object = e, this.size = void 0 !== t ? t : 1;
        var r = void 0 !== i ? i : 16776960, a = void 0 !== n ? n : 1, o = 0, s = this.object.geometry;
        s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
        var l = new sd, h = new Wp(2 * o * 3, 3);
        l.addAttribute("position", h), ng.call(this, l, new tg({
            color: r, linewidth: a
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Rx(e, t, i) {
        Pp.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1);
        var n = new sd;
        n.addAttribute("position", new Wp([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        var r = new tg({fog: !1});
        this.lightPlane = new ig(n, r), this.add(this.lightPlane), (n = new sd).addAttribute("position", new Wp([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ig(n, r), this.add(this.targetLine), this.update()
    }

    function Ox(e) {
        var t = new sd, i = new tg({color: 16777215, vertexColors: 1}), n = [], r = [], a = {}, o = new $u(16755200),
            s = new $u(16711680), l = new $u(43775), h = new $u(16777215), c = new $u(3355443);

        function u(e, t, i) {
            p(e, i), p(t, i)
        }

        function p(e, t) {
            n.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(n.length / 3 - 1)
        }

        u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", h), u("p", "c", c), u("cn1", "cn2", c), u("cn3", "cn4", c), u("cf1", "cf2", c), u("cf3", "cf4", c), t.addAttribute("position", new Wp(n, 3)), t.addAttribute("color", new Wp(r, 3)), ng.call(this, t, i), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
    }

    function Fx(e, t) {
        this.object = e, void 0 === t && (t = 16776960);
        var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            n = new Float32Array(24), r = new sd;
        r.setIndex(new Dp(i, 1)), r.addAttribute("position", new Dp(n, 3)), ng.call(this, r, new tg({color: t})), this.matrixAutoUpdate = !1, this.update()
    }

    function Nx(e, t) {
        this.type = "Box3Helper", this.box = e;
        var i = void 0 !== t ? t : 16776960,
            n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new sd;
        r.setIndex(new Dp(n, 1)), r.addAttribute("position", new Wp([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), ng.call(this, r, new tg({color: i})), this.geometry.computeBoundingSphere()
    }

    function kx(e, t, i) {
        this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
        var n = void 0 !== i ? i : 16776960, r = new sd;
        r.addAttribute("position", new Wp([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), ig.call(this, r, new tg({color: n}));
        var a = new sd;
        a.addAttribute("position", new Wp([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new jd(a, new Gd({
            color: n, opacity: .2, transparent: !0, depthWrite: !1
        })))
    }

    function Ux(e, t, i, n, r, a) {
        Pp.call(this), void 0 === n && (n = 16776960), void 0 === i && (i = 1), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === nx && ((nx = new sd).addAttribute("position", new Wp([0, 0, 0, 0, 1, 0], 3)), (rx = new vv(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new ig(nx, new tg({color: n})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new jd(rx, new Gd({color: n})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a)
    }

    function Dx(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new sd;
        i.addAttribute("position", new Wp(t, 3)), i.addAttribute("color", new Wp([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
        var n = new tg({vertexColors: 2});
        ng.call(this, i, n)
    }

    function zx(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Zv.call(this, e), this.type = "catmullrom"
    }

    Object.assign(hx.prototype, {
        getValue: function (e, t) {
            this.bind();
            var i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
            void 0 !== n && n.getValue(e, t)
        }, setValue: function (e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t)
        }, bind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
        }, unbind: function () {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
        }
    }), Object.assign(cx, {
        Composite: hx,
        create: function (e, t, i) {
            return e && e.isAnimationObjectGroup ? new cx.Composite(e, t, i) : new cx(e, t, i)
        },
        sanitizeNodeName: (F_ = new RegExp("[" + lx + "]", "g"), function (e) {
            return e.replace(/\s/g, "_").replace(F_, "")
        }),
        parseTrackName: (A_ = "[^" + lx + "]", M_ = "[^" + lx.replace("\\.", "") + "]", P_ = /((?:WC+[\/:])*)/.source.replace("WC", A_), L_ = /(WCOD+)?/.source.replace("WCOD", M_), C_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", A_), I_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", A_), R_ = new RegExp("^" + P_ + L_ + C_ + I_ + "$"), O_ = ["material", "materials", "bones"], function (e) {
            var t = R_.exec(e);
            if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            var i = {nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6]},
                n = i.nodeName && i.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n) {
                var r = i.nodeName.substring(n + 1);
                -1 !== O_.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r)
            }
            if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return i
        }),
        findNode: function (e, r) {
            if (!r || "" === r || "root" === r || "." === r || -1 === r || r === e.name || r === e.uuid) return e;
            if (e.skeleton) {
                var t = e.skeleton.getBoneByName(r);
                if (void 0 !== t) return t
            }
            if (e.children) {
                var a = function (e) {
                    for (var t = 0; t < e.length; t++) {
                        var i = e[t];
                        if (i.name === r || i.uuid === r) return i;
                        var n = a(i.children);
                        if (n) return n
                    }
                    return null
                }, i = a(e.children);
                if (i) return i
            }
            return null
        }
    }), Object.assign(cx.prototype, {
        _getValue_unavailable: function () {
        },
        _setValue_unavailable: function () {
        },
        BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
        Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
        GetterByBindingType: [function (e, t) {
            e[t] = this.node[this.propertyName]
        }, function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n]
        }, function (e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }, function (e, t) {
            this.resolvedProperty.toArray(e, t)
        }],
        SetterByBindingTypeAndVersioning: [[function (e, t) {
            this.targetObject[this.propertyName] = e[t]
        }, function (e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
        }, function (e, t) {
            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++]
        }, function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
            this.targetObject.needsUpdate = !0
        }, function (e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }, function (e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
        }, function (e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (e, t) {
            this.resolvedProperty.fromArray(e, t)
        }, function (e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
        }, function (e, t) {
            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
        }]],
        getValue: function (e, t) {
            this.bind(), this.getValue(e, t)
        },
        setValue: function (e, t) {
            this.bind(), this.setValue(e, t)
        },
        bind: function () {
            var e = this.node, t = this.parsedPath, i = t.objectName, n = t.propertyName, r = t.propertyIndex;
            if (e || (e = cx.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) {
                if (i) {
                    var a = t.objectIndex;
                    switch (i) {
                        case"materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case"bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (var o = 0; o < e.length; o++) if (e[o].name === a) {
                                a = o;
                                break
                            }
                            break;
                        default:
                            if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[i]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[a]
                    }
                }
                var s = e[n];
                if (void 0 !== s) {
                    var l = this.Versioning.None;
                    void 0 !== (this.targetObject = e).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate);
                    var h = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++) if (e.geometry.morphAttributes.position[o].name === r) {
                                    r = o;
                                    break
                                }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (o = 0; o < this.node.geometry.morphTargets.length; o++) if (e.geometry.morphTargets[o].name === r) {
                                    r = o;
                                    break
                                }
                            }
                        }
                        h = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (h = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][l]
                } else {
                    var c = t.nodeName;
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e)
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(cx.prototype, {
        _getValue_unbound: cx.prototype.getValue, _setValue_unbound: cx.prototype.setValue
    }), Object.assign(function () {
        this.uuid = fu.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                }, get inUse() {
                    return this.total - n.nCachedObjects_
                }
            }, get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }.prototype, {
        isAnimationObjectGroup: !0, add: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, h = 0, c = arguments.length; h !== c; ++h) {
                var u = arguments[h], p = u.uuid, d = n[p];
                if (void 0 === d) {
                    d = t++, n[p] = d, e.push(u);
                    for (var f = 0, m = s; f !== m; ++f) o[f].push(new cx(u, r[f], a[f]))
                } else if (d < i) {
                    l = e[d];
                    var g = --i, v = e[g];
                    e[n[v.uuid] = d] = v, e[n[p] = g] = u;
                    for (f = 0, m = s; f !== m; ++f) {
                        var y = o[f], _ = y[g], x = y[d];
                        y[d] = _, void 0 === x && (x = new cx(u, r[f], a[f])), y[g] = x
                    }
                } else e[d] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        }, remove: function () {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a], l = s.uuid, h = i[l];
                if (void 0 !== h && t <= h) {
                    var c = t++, u = e[c];
                    e[i[u.uuid] = h] = u, e[i[l] = c] = s;
                    for (var p = 0, d = r; p !== d; ++p) {
                        var f = n[p], m = f[c], g = f[h];
                        f[h] = m, f[c] = g
                    }
                }
            }
            this.nCachedObjects_ = t
        }, uncache: function () {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var l = arguments[o].uuid, h = n[l];
                if (void 0 !== h) if (delete n[l], h < i) {
                    var c = --i, u = e[c], p = e[v = --t];
                    e[n[u.uuid] = h] = u, e[n[p.uuid] = c] = p, e.pop();
                    for (var d = 0, f = a; d !== f; ++d) {
                        var m = (y = r[d])[c], g = y[v];
                        y[h] = m, y[c] = g, y.pop()
                    }
                } else {
                    var v;
                    e[n[(p = e[v = --t]).uuid] = h] = p, e.pop();
                    for (d = 0, f = a; d !== f; ++d) {
                        var y;
                        (y = r[d])[h] = y[v], y.pop()
                    }
                }
            }
            this.nCachedObjects_ = i
        }, subscribe_: function (e, t) {
            var i = this._bindingsIndicesByPath, n = i[e], r = this._bindings;
            if (void 0 !== n) return r[n];
            var a = this._paths, o = this._parsedPaths, s = this._objects, l = s.length, h = this.nCachedObjects_,
                c = new Array(l);
            n = r.length, i[e] = n, a.push(e), o.push(t), r.push(c);
            for (var u = h, p = s.length; u !== p; ++u) {
                var d = s[u];
                c[u] = new cx(d, e, t)
            }
            return c
        }, unsubscribe_: function (e) {
            var t = this._bindingsIndicesByPath, i = t[e];
            if (void 0 !== i) {
                var n = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o];
                a[t[e[o]] = i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
            }
        }
    }), Object.assign(ux.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        }, stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        }, reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        }, isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }, isScheduled: function () {
            return this._mixer._isActiveAction(this)
        }, startAt: function (e) {
            return this._startTime = e, this
        }, setLoop: function (e, t) {
            return this.loop = e, this.repetitions = t, this
        }, setEffectiveWeight: function (e) {
            return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
        }, getEffectiveWeight: function () {
            return this._effectiveWeight
        }, fadeIn: function (e) {
            return this._scheduleFading(e, 0, 1)
        }, fadeOut: function (e) {
            return this._scheduleFading(e, 1, 0)
        }, crossFadeFrom: function (e, t, i) {
            if (e.fadeOut(t), this.fadeIn(t), i) {
                var n = this._clip.duration, r = e._clip.duration, a = r / n, o = n / r;
                e.warp(1, a, t), this.warp(o, 1, t)
            }
            return this
        }, crossFadeTo: function (e, t, i) {
            return e.crossFadeFrom(this, t, i)
        }, stopFading: function () {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        }, setEffectiveTimeScale: function (e) {
            return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
        }, getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        }, setDuration: function (e) {
            return this.timeScale = this._clip.duration / e, this.stopWarping()
        }, syncWith: function (e) {
            return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
        }, halt: function (e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        }, warp: function (e, t, i) {
            var n = this._mixer, r = n.time, a = this._timeScaleInterpolant, o = this.timeScale;
            null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a);
            var s = a.parameterPositions, l = a.sampleValues;
            return s[0] = r, s[1] = r + i, l[0] = e / o, l[1] = t / o, this
        }, stopWarping: function () {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
        }, getMixer: function () {
            return this._mixer
        }, getClip: function () {
            return this._clip
        }, getRoot: function () {
            return this._localRoot || this._mixer._root
        }, _update: function (e, t, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    var a = (e - r) * i;
                    if (a < 0 || 0 === i) return;
                    this._startTime = null, t = i * a
                }
                t *= this._updateTimeScale(e);
                var o = this._updateTime(t), s = this._updateWeight(e);
                if (0 < s) for (var l = this._interpolants, h = this._propertyBindings, c = 0, u = l.length; c !== u; ++c) l[c].evaluate(o), h[c].accumulate(n, s)
            } else this._updateWeight(e)
        }, _updateWeight: function (e) {
            var t = 0;
            if (this.enabled) {
                t = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(e)[0];
                    t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = t
        }, _updateTimeScale: function (e) {
            var t = 0;
            if (!this.paused) {
                t = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i) t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
            }
            return this._effectiveTimeScale = t
        }, _updateTime: function (e) {
            var t = this.time + e, i = this._clip.duration, n = this.loop, r = this._loopCount, a = 2202 === n;
            if (0 === e) return -1 === r ? t : a && 1 == (1 & r) ? i - t : t;
            if (2200 === n) {
                -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                e:{
                    if (i <= t) t = i; else {
                        if (!(t < 0)) break e;
                        t = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                        type: "finished", action: this, direction: e < 0 ? -1 : 1
                    })
                }
            } else {
                if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), i <= t || t < 0) {
                    var o = Math.floor(t / i);
                    t -= i * o, r += Math.abs(o);
                    var s = this.repetitions - r;
                    if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = 0 < e ? i : 0, this._mixer.dispatchEvent({
                        type: "finished", action: this, direction: 0 < e ? 1 : -1
                    }); else {
                        if (1 === s) {
                            var l = e < 0;
                            this._setEndings(l, !l, a)
                        } else this._setEndings(!1, !1, a);
                        this._loopCount = r, this._mixer.dispatchEvent({type: "loop", action: this, loopDelta: o})
                    }
                }
                if (a && 1 == (1 & r)) return i - (this.time = t)
            }
            return this.time = t
        }, _setEndings: function (e, t, i) {
            var n = this._interpolantSettings;
            n.endingEnd = i ? n.endingStart = tu : (n.endingStart = e ? this.zeroSlopeAtStart ? tu : eu : 2402, t ? this.zeroSlopeAtEnd ? tu : eu : 2402)
        }, _scheduleFading: function (e, t, i) {
            var n = this._mixer, r = n.time, a = this._weightInterpolant;
            null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
            var o = a.parameterPositions, s = a.sampleValues;
            return o[0] = r, s[0] = t, o[1] = r + e, s[1] = i, this
        }
    }), px.prototype = Object.assign(Object.create(Il.prototype), {
        constructor: px, _bindAction: function (e, t) {
            var i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings,
                o = e._interpolants, s = i.uuid, l = this._bindingsByRootAndName, h = l[s];
            void 0 === h && (h = {}, l[s] = h);
            for (var c = 0; c !== r; ++c) {
                var u = n[c], p = u.name, d = h[p];
                if (void 0 !== d) a[c] = d; else {
                    if (void 0 !== (d = a[c])) {
                        null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
                        continue
                    }
                    var f = t && t._propertyBindings[c].binding.parsedPath;
                    ++(d = new E_(cx.create(i, p, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), a[c] = d
                }
                o[c].resultBuffer = d.buffer
            }
        }, _activateAction: function (e) {
            if (!this._isActiveAction(e)) {
                if (null === e._cacheIndex) {
                    var t = (e._localRoot || this._root).uuid, i = e._clip.uuid, n = this._actionsByClip[i];
                    this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t)
                }
                for (var r = e._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                    var s = r[a];
                    0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(e)
            }
        }, _deactivateAction: function (e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        }, _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    }, get inUse() {
                        return e._nActiveActions
                    }
                }, bindings: {
                    get total() {
                        return e._bindings.length
                    }, get inUse() {
                        return e._nActiveBindings
                    }
                }, controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    }, get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        }, _isActiveAction: function (e) {
            var t = e._cacheIndex;
            return null !== t && t < this._nActiveActions
        }, _addInactiveAction: function (e, t, i) {
            var n = this._actions, r = this._actionsByClip, a = r[t];
            if (void 0 === a) a = {knownActions: [e], actionByRoot: {}}, e._byClipCacheIndex = 0, r[t] = a; else {
                var o = a.knownActions;
                e._byClipCacheIndex = o.length, o.push(e)
            }
            e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e
        }, _removeInactiveAction: function (e) {
            var t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
            t[i._cacheIndex = n] = i, t.pop(), e._cacheIndex = null;
            var r = e._clip.uuid, a = this._actionsByClip, o = a[r], s = o.knownActions, l = s[s.length - 1],
                h = e._byClipCacheIndex;
            s[l._byClipCacheIndex = h] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(e)
        }, _removeInactiveBindingsForAction: function (e) {
            for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                var r = t[i];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        }, _lendAction: function (e) {
            var t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
            t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r
        }, _takeBackAction: function (e) {
            var t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
            t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r
        }, _addInactiveBinding: function (e, t, i) {
            var n = this._bindingsByRootAndName, r = n[t], a = this._bindings;
            void 0 === r && (r = {}, n[t] = r), (r[i] = e)._cacheIndex = a.length, a.push(e)
        }, _removeInactiveBinding: function (e) {
            var t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName,
                o = a[n], s = t[t.length - 1], l = e._cacheIndex;
            t[s._cacheIndex = l] = s, t.pop(), delete o[r];
            e:{
                for (var h in o) break e;
                delete a[n]
            }
        }, _lendBinding: function (e) {
            var t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
            t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r
        }, _takeBackBinding: function (e) {
            var t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
            t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r
        }, _lendControlInterpolant: function () {
            var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, i = e[t];
            return void 0 === i && (e[(i = new Ey(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = i), i
        }, _takeBackControlInterpolant: function (e) {
            var t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
            t[e.__cacheIndex = n] = e, t[r.__cacheIndex = i] = r
        }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (e, t) {
            var i = t || this._root, n = i.uuid, r = "string" == typeof e ? Ny.findByName(i, e) : e,
                a = null !== r ? r.uuid : e, o = this._actionsByClip[a], s = null;
            if (void 0 !== o) {
                var l = o.actionByRoot[n];
                if (void 0 !== l) return l;
                s = o.knownActions[0], null === r && (r = s._clip)
            }
            if (null === r) return null;
            var h = new ux(this, r, t);
            return this._bindAction(h, s), this._addInactiveAction(h, a, n), h
        }, existingAction: function (e, t) {
            var i = t || this._root, n = i.uuid, r = "string" == typeof e ? Ny.findByName(i, e) : e, a = r ? r.uuid : e,
                o = this._actionsByClip[a];
            return void 0 !== o && o.actionByRoot[n] || null
        }, stopAllAction: function () {
            var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings;
            this._nActiveActions = 0;
            for (var r = this._nActiveBindings = 0; r !== t; ++r) e[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        }, update: function (e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) {
                t[o]._update(n, e, r, a)
            }
            var s = this._bindings, l = this._nActiveBindings;
            for (o = 0; o !== l; ++o) s[o].apply(a);
            return this
        }, getRoot: function () {
            return this._root
        }, uncacheClip: function (e) {
            var t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
            if (void 0 !== r) {
                for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                    var l = a[o];
                    this._deactivateAction(l);
                    var h = l._cacheIndex, c = t[t.length - 1];
                    l._cacheIndex = null, l._byClipCacheIndex = null, t[c._cacheIndex = h] = c, t.pop(), this._removeInactiveBindingsForAction(l)
                }
                delete n[i]
            }
        }, uncacheRoot: function (e) {
            var t = e.uuid, i = this._actionsByClip;
            for (var n in i) {
                var r = i[n].actionByRoot[t];
                void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
            }
            var a = this._bindingsByRootAndName[t];
            if (void 0 !== a) for (var o in a) {
                var s = a[o];
                s.restoreOriginalState(), this._removeInactiveBinding(s)
            }
        }, uncacheAction: function (e, t) {
            var i = this.existingAction(e, t);
            null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
        }
    }), dx.prototype.clone = function () {
        return new dx(void 0 === this.value.clone ? this.value : this.value.clone())
    }, fx.prototype = Object.assign(Object.create(sd.prototype), {
        constructor: fx, isInstancedBufferGeometry: !0, copy: function (e) {
            return sd.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }
    }), mx.prototype = Object.assign(Object.create(Ym.prototype), {
        constructor: mx, isInstancedInterleavedBuffer: !0, copy: function (e) {
            return Ym.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), gx.prototype = Object.assign(Object.create(Dp.prototype), {
        constructor: gx, isInstancedBufferAttribute: !0, copy: function (e) {
            return Dp.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
        }
    }), Object.assign(function (e, t, i, n) {
        this.ray = new Bd(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {}, Line: {}, LOD: {}, Points: {threshold: 1}, Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }.prototype, {
        linePrecision: 1, set: function (e, t) {
            this.ray.set(e, t)
        }, setFromCamera: function (e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        }, intersectObject: function (e, t, i) {
            var n = i || [];
            return yx(e, this, n, t), n.sort(vx), n
        }, intersectObjects: function (e, t, i) {
            var n = i || [];
            if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
            for (var r = 0, a = e.length; r < a; r++) yx(e[r], this, n, t);
            return n.sort(vx), n
        }
    }), Object.assign(function (e) {
        this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }.prototype, {
        start: function () {
            this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
        }, stop: function () {
            this.getElapsedTime(), this.running = !1, this.autoStart = !1
        }, getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        }, getDelta: function () {
            var e = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var t = ("undefined" == typeof performance ? Date : performance).now();
                e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
            }
            return e
        }
    }), Object.assign(_x.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.phi = t, this.theta = i, this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
        }, makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        }, setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }, setFromCartesianCoords: function (e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(fu.clamp(t / this.radius, -1, 1))), this
        }
    }), Object.assign(function (e, t, i) {
        return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this
    }.prototype, {
        set: function (e, t, i) {
            return this.radius = e, this.theta = t, this.y = i, this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
        }, setFromVector3: function (e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }, setFromCartesianCoords: function (e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
        }
    }), Object.assign(xx.prototype, {
        set: function (e, t) {
            return this.min.copy(e), this.max.copy(t), this
        }, setFromPoints: function (e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
            return this
        }, setFromCenterAndSize: (k_ = new mu, function (e, t) {
            var i = k_.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
        }), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.min.copy(e.min), this.max.copy(e.max), this
        }, makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }, getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new mu), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new mu), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        }, expandByPoint: function (e) {
            return this.min.min(e), this.max.max(e), this
        }, expandByVector: function (e) {
            return this.min.sub(e), this.max.add(e), this
        }, expandByScalar: function (e) {
            return this.min.addScalar(-e), this.max.addScalar(e), this
        }, containsPoint: function (e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        }, containsBox: function (e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        }, getParameter: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new mu), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        }, intersectsBox: function (e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        }, clampPoint: function (e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new mu), t.copy(e).clamp(this.min, this.max)
        }, distanceToPoint: (N_ = new mu, function (e) {
            return N_.copy(e).clamp(this.min, this.max).sub(e).length()
        }), intersect: function (e) {
            return this.min.max(e.min), this.max.min(e.max), this
        }, union: function (e) {
            return this.min.min(e.min), this.max.max(e.max), this
        }, translate: function (e) {
            return this.min.add(e), this.max.add(e), this
        }, equals: function (e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }), Object.assign(bx.prototype, {
        set: function (e, t) {
            return this.start.copy(e), this.end.copy(t), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (e) {
            return this.start.copy(e.start), this.end.copy(e.end), this
        }, getCenter: function (e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new yu), e.addVectors(this.start, this.end).multiplyScalar(.5)
        }, delta: function (e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new yu), e.subVectors(this.end, this.start)
        }, distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        }, distance: function () {
            return this.start.distanceTo(this.end)
        }, at: function (e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new yu), this.delta(t).multiplyScalar(e).add(this.start)
        }, closestPointToPointParameter: (U_ = new yu, D_ = new yu, function (e, t) {
            U_.subVectors(e, this.start), D_.subVectors(this.end, this.start);
            var i = D_.dot(D_), n = D_.dot(U_) / i;
            return t && (n = fu.clamp(n, 0, 1)), n
        }), closestPointToPoint: function (e, t, i) {
            var n = this.closestPointToPointParameter(e, t);
            return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new yu), this.delta(i).multiplyScalar(n).add(this.start)
        }, applyMatrix4: function (e) {
            return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
        }, equals: function (e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }), ((wx.prototype = Object.create(Pp.prototype)).constructor = wx).prototype.isImmediateRenderObject = !0, ((Tx.prototype = Object.create(ng.prototype)).constructor = Tx).prototype.update = (z_ = new yu, B_ = new yu, H_ = new _u, function () {
        var e = ["a", "b", "c"];
        this.object.updateMatrixWorld(!0), H_.getNormalMatrix(this.object.matrixWorld);
        var t = this.object.matrixWorld, i = this.geometry.attributes.position, n = this.object.geometry;
        if (n && n.isGeometry) for (var r = n.vertices, a = n.faces, o = 0, s = 0, l = a.length; s < l; s++) for (var h = a[s], c = 0, u = h.vertexNormals.length; c < u; c++) {
            var p = r[h[e[c]]], d = h.vertexNormals[c];
            z_.copy(p).applyMatrix4(t), B_.copy(d).applyMatrix3(H_).normalize().multiplyScalar(this.size).add(z_), i.setXYZ(o, z_.x, z_.y, z_.z), o += 1, i.setXYZ(o, B_.x, B_.y, B_.z), o += 1
        } else if (n && n.isBufferGeometry) {
            var f = n.attributes.position, m = n.attributes.normal;
            for (c = o = 0, u = f.count; c < u; c++) z_.set(f.getX(c), f.getY(c), f.getZ(c)).applyMatrix4(t), B_.set(m.getX(c), m.getY(c), m.getZ(c)), B_.applyMatrix3(H_).normalize().multiplyScalar(this.size).add(z_), i.setXYZ(o, z_.x, z_.y, z_.z), o += 1, i.setXYZ(o, B_.x, B_.y, B_.z), o += 1
        }
        i.needsUpdate = !0
    }), ((Sx.prototype = Object.create(Pp.prototype)).constructor = Sx).prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, Sx.prototype.update = (G_ = new yu, j_ = new yu, function () {
        this.light.updateMatrixWorld();
        var e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), G_.setFromMatrixPosition(this.light.matrixWorld), j_.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(j_.sub(G_)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }), ((Ex.prototype = Object.create(ng.prototype)).constructor = Ex).prototype.updateMatrixWorld = (V_ = new yu, X_ = new gu, W_ = new gu, function (e) {
        var t = this.bones, i = this.geometry, n = i.getAttribute("position");
        W_.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < t.length; r++) {
            var o = t[r];
            o.parent && o.parent.isBone && (X_.multiplyMatrices(W_, o.matrixWorld), V_.setFromMatrixPosition(X_), n.setXYZ(a, V_.x, V_.y, V_.z), X_.multiplyMatrices(W_, o.parent.matrixWorld), V_.setFromMatrixPosition(X_), n.setXYZ(a + 1, V_.x, V_.y, V_.z), a += 2)
        }
        i.getAttribute("position").needsUpdate = !0, Pp.prototype.updateMatrixWorld.call(this, e)
    }), ((Ax.prototype = Object.create(jd.prototype)).constructor = Ax).prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, Ax.prototype.update = function () {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, ((Mx.prototype = Object.create(Pp.prototype)).constructor = Mx).prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Mx.prototype.update = function () {
        var e = .5 * this.light.width, t = .5 * this.light.height, i = this.line.geometry.attributes.position,
            n = i.array;
        n[0] = e, n[1] = -t, n[2] = 0, n[3] = e, n[4] = t, n[5] = 0, n[6] = -e, n[7] = t, n[8] = 0, n[9] = -e, n[10] = -t, n[11] = 0, n[12] = e, n[13] = -t, n[14] = 0, i.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
    }, ((Px.prototype = Object.create(Pp.prototype)).constructor = Px).prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Px.prototype.update = (Y_ = new yu, q_ = new $u, Q_ = new $u, function () {
        var e = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color); else {
            var t = e.geometry.getAttribute("color");
            q_.copy(this.light.color), Q_.copy(this.light.groundColor);
            for (var i = 0, n = t.count; i < n; i++) {
                var r = i < n / 2 ? q_ : Q_;
                t.setXYZ(i, r.r, r.g, r.b)
            }
            t.needsUpdate = !0
        }
        e.lookAt(Y_.setFromMatrixPosition(this.light.matrixWorld).negate())
    }), (Lx.prototype = Object.create(ng.prototype)).constructor = Lx, (Cx.prototype = Object.create(ng.prototype)).constructor = Cx, ((Ix.prototype = Object.create(ng.prototype)).constructor = Ix).prototype.update = (Z_ = new yu, J_ = new yu, K_ = new _u, function () {
        this.object.updateMatrixWorld(!0), K_.getNormalMatrix(this.object.matrixWorld);
        for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, i = this.object.geometry, n = i.vertices, r = i.faces, a = 0, o = 0, s = r.length; o < s; o++) {
            var l = r[o], h = l.normal;
            Z_.copy(n[l.a]).add(n[l.b]).add(n[l.c]).divideScalar(3).applyMatrix4(e), J_.copy(h).applyMatrix3(K_).normalize().multiplyScalar(this.size).add(Z_), t.setXYZ(a, Z_.x, Z_.y, Z_.z), a += 1, t.setXYZ(a, J_.x, J_.y, J_.z), a += 1
        }
        t.needsUpdate = !0
    }), ((Rx.prototype = Object.create(Pp.prototype)).constructor = Rx).prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Rx.prototype.update = ($_ = new yu, ex = new yu, tx = new yu, function () {
        $_.setFromMatrixPosition(this.light.matrixWorld), ex.setFromMatrixPosition(this.light.target.matrixWorld), tx.subVectors(ex, $_), this.lightPlane.lookAt(tx), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(tx), this.targetLine.scale.z = tx.length()
    }), ((Ox.prototype = Object.create(ng.prototype)).constructor = Ox).prototype.update = function () {
        var l, h, c = new yu, u = new Dm;

        function e(e, t, i, n) {
            c.set(t, i, n).unproject(u);
            var r = h[e];
            if (void 0 !== r) for (var a = l.getAttribute("position"), o = 0, s = r.length; o < s; o++) a.setXYZ(r[o], c.x, c.y, c.z)
        }

        return function () {
            l = this.geometry, h = this.pointMap;
            u.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), l.getAttribute("position").needsUpdate = !0
        }
    }(), ((Fx.prototype = Object.create(ng.prototype)).constructor = Fx).prototype.update = (ix = new ju, function (e) {
        if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && ix.setFromObject(this.object), !ix.isEmpty()) {
            var t = ix.min, i = ix.max, n = this.geometry.attributes.position, r = n.array;
            r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
        }
    }), Fx.prototype.setFromObject = function (e) {
        return this.object = e, this.update(), this
    }, ((Nx.prototype = Object.create(ng.prototype)).constructor = Nx).prototype.updateMatrixWorld = function (e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), Pp.prototype.updateMatrixWorld.call(this, e))
    }, ((kx.prototype = Object.create(ig.prototype)).constructor = kx).prototype.updateMatrixWorld = function (e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? lh : sh, this.lookAt(this.plane.normal), Pp.prototype.updateMatrixWorld.call(this, e)
    }, ((Ux.prototype = Object.create(Pp.prototype)).constructor = Ux).prototype.setDirection = (ox = new yu, function (e) {
        .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (ox.set(e.z, 0, -e.x).normalize(), ax = Math.acos(e.y), this.quaternion.setFromAxisAngle(ox, ax))
    }), Ux.prototype.setLength = function (e, t, i) {
        void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
    }, Ux.prototype.setColor = function (e) {
        this.line.material.color.copy(e), this.cone.material.color.copy(e)
    }, (Dx.prototype = Object.create(ng.prototype)).constructor = Dx, Gv.create = function (e, t) {
        return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Gv.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e
    }, Object.assign(ly.prototype, {
        createPointsGeometry: function (e) {
            console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getPoints(e);
            return this.createGeometry(t)
        }, createSpacedPointsGeometry: function (e) {
            console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            var t = this.getSpacedPoints(e);
            return this.createGeometry(t)
        }, createGeometry: function (e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new Up, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.vertices.push(new yu(r.x, r.y, r.z || 0))
            }
            return t
        }
    }), Object.assign(hy.prototype, {
        fromPoints: function (e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
        }
    }), zx.prototype = Object.create(Zv.prototype), Object.assign(zx.prototype, {
        initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        }, getControlPointsArray: function () {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        }, reparametrizeByArcLength: function () {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Lx.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Ex.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(Vy.prototype, {
        extractUrlBase: function (e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xy(e)
        }
    }), Object.assign(Wy.prototype, {
        setTexturePath: function (e) {
            return console.warn("THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
        }
    }), Object.assign(xx.prototype, {
        center: function (e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
        }, empty: function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, isIntersectionBox: function (e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        }, size: function (e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), Object.assign(ju.prototype, {
        center: function (e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
        }, empty: function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, isIntersectionBox: function (e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        }, isIntersectionSphere: function (e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }, size: function (e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
        }
    }), bx.prototype.center = function (e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
    }, Object.assign(fu, {
        random16: function () {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        }, nearestPowerOfTwo: function (e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), fu.floorPowerOfTwo(e)
        }, nextPowerOfTwo: function (e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), fu.ceilPowerOfTwo(e)
        }
    }), Object.assign(_u.prototype, {
        flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        }, multiplyVector3: function (e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
        }, multiplyVector3Array: function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, applyToBuffer: function (e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        }, applyToVector3Array: function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(gu.prototype, {
        extractPosition: function (e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
        }, flattenToArrayOffset: function (e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
        }, getPosition: function () {
            return void 0 === sx && (sx = new yu), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), sx.setFromMatrixColumn(this, 3)
        }, setRotationFromQuaternion: function (e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
        }, multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, multiplyVector3: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        }, multiplyVector4: function (e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        }, multiplyVector3Array: function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, rotateAxis: function (e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
        }, crossVector: function (e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
        }, translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, applyToBuffer: function (e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
        }, applyToVector3Array: function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, makeFrustum: function (e, t, i, n, r, a) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, a)
        }
    }), Xu.prototype.isIntersectionLine = function (e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
    }, vu.prototype.multiplyVector3 = function (e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
    }, Object.assign(Bd.prototype, {
        isIntersectionBox: function (e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
        }, isIntersectionPlane: function (e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
        }, isIntersectionSphere: function (e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
        }
    }), Object.assign(Hd.prototype, {
        area: function () {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, barycoordFromPoint: function (e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
        }, midpoint: function (e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
        }, normal: function (e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
        }, plane: function (e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
        }
    }), Object.assign(Hd, {
        barycoordFromPoint: function (e, t, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Hd.getBarycoord(e, t, i, n, r)
        }, normal: function (e, t, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Hd.getNormal(e, t, i, n)
        }
    }), Object.assign(cy.prototype, {
        extractAllPoints: function (e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
        }, extrude: function (e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ev(this, e)
        }, makeGeometry: function (e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new pv(this, e)
        }
    }), Object.assign(mu.prototype, {
        fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }, distanceToManhattan: function (e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(yu.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, getPositionFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
        }, getScaleFromMatrix: function (e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
        }, getColumnFromMatrix: function (e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
        }, applyProjection: function (e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
        }, fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }, distanceToManhattan: function (e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(zu.prototype, {
        fromAttribute: function (e, t, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(Up.prototype, {
        computeTangents: function () {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        }, computeLineDistances: function () {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(Pp.prototype, {
        getChildByName: function (e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
        }, renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, translate: function (e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
        }, getWorldRotation: function () {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(Pp.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            }, set: function (e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
            }
        }, useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }, set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(Jm.prototype, {
        objects: {
            get: function () {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(Km.prototype, "useVertexTexture", {
        get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }, set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), Object.defineProperty(Gv.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        }, set: function (e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
        }
    }), zm.prototype.setLens = function (e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
    }, Object.defineProperties(uy.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        }, shadowCameraFov: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
            }
        }, shadowCameraLeft: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
            }
        }, shadowCameraRight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
            }
        }, shadowCameraTop: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
            }
        }, shadowCameraBottom: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
            }
        }, shadowCameraNear: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
            }
        }, shadowCameraFar: {
            set: function (e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
            }
        }, shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        }, shadowBias: {
            set: function (e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
            }
        }, shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        }, shadowMapWidth: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
            }
        }, shadowMapHeight: {
            set: function (e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
            }
        }
    }), Object.defineProperties(Dp.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }, copyIndicesArray: function () {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(sd.prototype, {
        addIndex: function (e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
        }, addDrawCall: function (e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
        }, clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        }, computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(sd.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        }, offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(tv.prototype, {
        getArrays: function () {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        }, addShapeList: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        }, addShape: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(dx.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        }, onUpdate: {
            value: function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(Dd.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }, set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        }, wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new $u
            }
        }, shading: {
            get: function () {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            }, set: function (e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e
            }
        }
    }), Object.defineProperties(Mv.prototype, {
        metal: {
            get: function () {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            }, set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(zd.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            }, set: function (e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
            }
        }
    }), Object.assign(jm.prototype, {
        clearTarget: function (e, t, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n)
        }, animate: function (e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
        }, getCurrentRenderTarget: function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, getMaxAnisotropy: function () {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, getPrecision: function () {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, resetGLState: function () {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, supportsFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, supportsHalfFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, supportsStandardDerivatives: function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, supportsCompressedTextureS3TC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, supportsCompressedTexturePVRTC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, supportsBlendMinMax: function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, supportsVertexTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, supportsInstancedArrays: function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, enableScissorTest: function (e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
        }, initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, setFaceCulling: function () {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }), Object.defineProperties(jm.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            }, set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
            }
        }, shadowMapType: {
            get: function () {
                return this.shadowMap.type
            }, set: function (e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
            }
        }, shadowMapCullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(Om.prototype, {
        cullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        }, renderReverseSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        }, renderSingleSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(Bu.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
            }
        }, wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
            }
        }, magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
            }
        }, minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
            }
        }, anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
            }
        }, offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
            }
        }, repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
            }
        }, format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
            }
        }, type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
            }
        }, generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            }, set: function (e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
            }
        }
    }), Object.defineProperties(Hm.prototype, {
        standing: {
            set: function () {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }, userHeight: {
            set: function () {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), w_.prototype.load = function (e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new __).load(e, function (e) {
            t.setBuffer(e)
        }), this
    }, S_.prototype.getData = function () {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, x_.prototype.updateCubeMap = function (e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
    }, ku.crossOrigin = void 0, ku.loadTexture = function (e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new Hv;
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(e, i, void 0, n);
        return t && (a.mapping = t), a
    }, ku.loadTextureCube = function (e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Bv;
        r.setCrossOrigin(this.crossOrigin);
        var a = r.load(e, i, void 0, n);
        return t && (a.mapping = t), a
    }, ku.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, ku.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    var Bx = {
        uniforms: {tDiffuse: {value: null}, opacity: {value: 1}},
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 texel = texture2D( tDiffuse, vUv );", "gl_FragColor = opacity * texel;", "}"].join("\n")
    };

    function Hx() {
        this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
    }

    function Gx(e, t) {
        Hx.call(this), this.textureID = void 0 !== t ? t : "tDiffuse", e instanceof zd ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Ju.clone(e.uniforms), this.material = new zd({
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })), this.camera = new vy(-1, 1, 1, -1, 0, 1), this.scene = new Wm, this.quad = new jd(new ud(2, 2), null), this.quad.frustumCulled = !1, this.scene.add(this.quad)
    }

    function jx(e, t) {
        Hx.call(this), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1
    }

    function Vx() {
        Hx.call(this), this.needsSwap = !1
    }

    function Xx(e, t) {
        if (this.renderer = e, void 0 === t) {
            var i = {minFilter: lc, magFilter: lc, format: Ec, stencilBuffer: !1}, n = e.getDrawingBufferSize();
            (t = new Bu(n.width, n.height, i)).texture.name = "EffectComposer.rt1"
        }
        this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.passes = [], void 0 === Bx && console.error("THREE.EffectComposer relies on THREE.CopyShader"), void 0 === Gx && console.error("THREE.EffectComposer relies on THREE.ShaderPass"), this.copyPass = new Gx(Bx)
    }

    function Wx(e, t, i, n, r) {
        Hx.call(this), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1
    }

    Object.assign(Hx.prototype, {
        setSize: function (e, t) {
        }, render: function (e, t, i, n, r) {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
    }), Gx.prototype = Object.assign(Object.create(Hx.prototype), {
        constructor: Gx, render: function (e, t, i, n, r) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.quad.material = this.material, this.renderToScreen ? e.render(this.scene, this.camera) : e.render(this.scene, this.camera, t, this.clear)
        }
    }), jx.prototype = Object.assign(Object.create(Hx.prototype), {
        constructor: jx, render: function (e, t, i, n, r) {
            var a, o, s = e.context, l = e.state;
            l.buffers.color.setMask(!1), l.buffers.depth.setMask(!1), l.buffers.color.setLocked(!0), l.buffers.depth.setLocked(!0), o = this.inverse ? (a = 0, 1) : (a = 1, 0), l.buffers.stencil.setTest(!0), l.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), l.buffers.stencil.setFunc(s.ALWAYS, a, 4294967295), l.buffers.stencil.setClear(o), e.render(this.scene, this.camera, i, this.clear), e.render(this.scene, this.camera, t, this.clear), l.buffers.color.setLocked(!1), l.buffers.depth.setLocked(!1), l.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), l.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP)
        }
    }), Vx.prototype = Object.create(Hx.prototype), Object.assign(Vx.prototype, {
        render: function (e, t, i, n, r) {
            e.state.buffers.stencil.setTest(!1)
        }
    }), Object.assign(Xx.prototype, {
        swapBuffers: function () {
            var e = this.readBuffer;
            this.readBuffer = this.writeBuffer, this.writeBuffer = e
        }, addPass: function (e) {
            this.passes.push(e);
            var t = this.renderer.getDrawingBufferSize();
            e.setSize(t.width, t.height)
        }, insertPass: function (e, t) {
            this.passes.splice(t, 0, e)
        }, render: function (e) {
            var t, i, n = !1, r = this.passes.length;
            for (i = 0; i < r; i++) if (!1 !== (t = this.passes[i]).enabled) {
                if (t.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), t.needsSwap) {
                    if (n) {
                        var a = this.renderer.context;
                        a.stencilFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), a.stencilFunc(a.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                void 0 !== jx && (t instanceof jx ? n = !0 : t instanceof Vx && (n = !1))
            }
        }, reset: function (e) {
            if (void 0 === e) {
                var t = this.renderer.getDrawingBufferSize();
                (e = this.renderTarget1.clone()).setSize(t.width, t.height)
            }
            this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
        }, setSize: function (e, t) {
            this.renderTarget1.setSize(e, t), this.renderTarget2.setSize(e, t);
            for (var i = 0; i < this.passes.length; i++) this.passes[i].setSize(e, t)
        }
    }), Wx.prototype = Object.assign(Object.create(Hx.prototype), {
        constructor: Wx, render: function (e, t, i, n, r) {
            var a, o, s = e.autoClear;
            e.autoClear = !1, this.scene.overrideMaterial = this.overrideMaterial, this.clearColor && (a = e.getClearColor().getHex(), o = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && e.clearDepth(), e.render(this.scene, this.camera, this.renderToScreen ? null : i, this.clear), this.clearColor && e.setClearColor(a, o), this.scene.overrideMaterial = null, e.autoClear = s
        }
    });
    var Yx = {
        uniforms: {tDiffuse: {value: null}, resolution: {value: new mu(1 / 1024, 1 / 512)}},
        vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["precision highp float;", "", "uniform sampler2D tDiffuse;", "", "uniform vec2 resolution;", "", "varying vec2 vUv;", "", "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)", "", "//----------------------------------------------------------------------------------", "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag", "// SDK Version: v3.00", "// Email:       gameworks@nvidia.com", "// Site:        http://developer.nvidia.com/", "//", "// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.", "//", "// Redistribution and use in source and binary forms, with or without", "// modification, are permitted provided that the following conditions", "// are met:", "//  * Redistributions of source code must retain the above copyright", "//    notice, this list of conditions and the following disclaimer.", "//  * Redistributions in binary form must reproduce the above copyright", "//    notice, this list of conditions and the following disclaimer in the", "//    documentation and/or other materials provided with the distribution.", "//  * Neither the name of NVIDIA CORPORATION nor the names of its", "//    contributors may be used to endorse or promote products derived", "//    from this software without specific prior written permission.", "//", "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY", "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR", "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR", "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,", "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,", "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR", "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY", "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT", "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE", "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.", "//", "//----------------------------------------------------------------------------------", "", "#define FXAA_PC 1", "#define FXAA_GLSL_100 1", "#define FXAA_QUALITY_PRESET 12", "", "#define FXAA_GREEN_AS_LUMA 1", "", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_PC_CONSOLE", "    //", "    // The console algorithm for PC is included", "    // for developers targeting really low spec machines.", "    // Likely better to just run FXAA_PC, and use a really low preset.", "    //", "    #define FXAA_PC_CONSOLE 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_120", "    #define FXAA_GLSL_120 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GLSL_130", "    #define FXAA_GLSL_130 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_3", "    #define FXAA_HLSL_3 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_4", "    #define FXAA_HLSL_4 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_HLSL_5", "    #define FXAA_HLSL_5 0", "#endif", "/*==========================================================================*/", "#ifndef FXAA_GREEN_AS_LUMA", "    //", "    // For those using non-linear color,", "    // and either not able to get luma in alpha, or not wanting to,", "    // this enables FXAA to run using green as a proxy for luma.", "    // So with this enabled, no need to pack luma in alpha.", "    //", "    // This will turn off AA on anything which lacks some amount of green.", "    // Pure red and blue or combination of only R and B, will get no AA.", "    //", "    // Might want to lower the settings for both,", "    //    fxaaConsoleEdgeThresholdMin", "    //    fxaaQualityEdgeThresholdMin", "    // In order to insure AA does not get turned off on colors", "    // which contain a minor amount of green.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_GREEN_AS_LUMA 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_EARLY_EXIT", "    //", "    // Controls algorithm's early exit path.", "    // On PS3 turning this ON adds 2 cycles to the shader.", "    // On 360 turning this OFF adds 10ths of a millisecond to the shader.", "    // Turning this off on console will result in a more blurry image.", "    // So this defaults to on.", "    //", "    // 1 = On.", "    // 0 = Off.", "    //", "    #define FXAA_EARLY_EXIT 1", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_DISCARD", "    //", "    // Only valid for PC OpenGL currently.", "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.", "    //", "    // 1 = Use discard on pixels which don't need AA.", "    //     For APIs which enable concurrent TEX+ROP from same surface.", "    // 0 = Return unchanged color on pixels which don't need AA.", "    //", "    #define FXAA_DISCARD 0", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_FAST_PIXEL_OFFSET", "    //", "    // Used for GLSL 120 only.", "    //", "    // 1 = GL API supports fast pixel offsets", "    // 0 = do not use fast pixel offsets", "    //", "    #ifdef GL_EXT_gpu_shader4", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_FAST_PIXEL_OFFSET 1", "    #endif", "    #ifndef FXAA_FAST_PIXEL_OFFSET", "        #define FXAA_FAST_PIXEL_OFFSET 0", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#ifndef FXAA_GATHER4_ALPHA", "    //", "    // 1 = API supports gather4 on alpha channel.", "    // 0 = API does not support gather4 on alpha channel.", "    //", "    #if (FXAA_HLSL_5 == 1)", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_ARB_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifdef GL_NV_gpu_shader5", "        #define FXAA_GATHER4_ALPHA 1", "    #endif", "    #ifndef FXAA_GATHER4_ALPHA", "        #define FXAA_GATHER4_ALPHA 0", "    #endif", "#endif", "", "", "/*============================================================================", "                        FXAA QUALITY - TUNING KNOBS", "------------------------------------------------------------------------------", "NOTE the other tuning knobs are now in the shader function inputs!", "============================================================================*/", "#ifndef FXAA_QUALITY_PRESET", "    //", "    // Choose the quality preset.", "    // This needs to be compiled into the shader as it effects code.", "    // Best option to include multiple presets is to", "    // in each shader define the preset, then include this file.", "    //", "    // OPTIONS", "    // -----------------------------------------------------------------------", "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)", "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)", "    // 39       - no dither, very expensive", "    //", "    // NOTES", "    // -----------------------------------------------------------------------", "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)", "    // 13 = about same speed as FXAA 3.9 and better than 12", "    // 23 = closest to FXAA 3.9 visually and performance wise", "    //  _ = the lowest digit is directly related to performance", "    // _  = the highest digit is directly related to style", "    //", "    #define FXAA_QUALITY_PRESET 12", "#endif", "", "", "/*============================================================================", "", "                           FXAA QUALITY - PRESETS", "", "============================================================================*/", "", "/*============================================================================", "                     FXAA QUALITY - MEDIUM DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 10)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 3.0", "    #define FXAA_QUALITY_P2 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 11)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 3.0", "    #define FXAA_QUALITY_P3 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 12)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 4.0", "    #define FXAA_QUALITY_P4 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 13)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 4.0", "    #define FXAA_QUALITY_P5 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 14)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 4.0", "    #define FXAA_QUALITY_P6 12.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 15)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 12.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - LOW DITHER PRESETS", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 20)", "    #define FXAA_QUALITY_PS 3", "    #define FXAA_QUALITY_P0 1.5", "    #define FXAA_QUALITY_P1 2.0", "    #define FXAA_QUALITY_P2 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 21)", "    #define FXAA_QUALITY_PS 4", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 22)", "    #define FXAA_QUALITY_PS 5", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 23)", "    #define FXAA_QUALITY_PS 6", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 24)", "    #define FXAA_QUALITY_PS 7", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 3.0", "    #define FXAA_QUALITY_P6 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 25)", "    #define FXAA_QUALITY_PS 8", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 4.0", "    #define FXAA_QUALITY_P7 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 26)", "    #define FXAA_QUALITY_PS 9", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 4.0", "    #define FXAA_QUALITY_P8 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 27)", "    #define FXAA_QUALITY_PS 10", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 4.0", "    #define FXAA_QUALITY_P9 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 28)", "    #define FXAA_QUALITY_PS 11", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 4.0", "    #define FXAA_QUALITY_P10 8.0", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_QUALITY_PRESET == 29)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.5", "    #define FXAA_QUALITY_P2 2.0", "    #define FXAA_QUALITY_P3 2.0", "    #define FXAA_QUALITY_P4 2.0", "    #define FXAA_QUALITY_P5 2.0", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "/*============================================================================", "                     FXAA QUALITY - EXTREME QUALITY", "============================================================================*/", "#if (FXAA_QUALITY_PRESET == 39)", "    #define FXAA_QUALITY_PS 12", "    #define FXAA_QUALITY_P0 1.0", "    #define FXAA_QUALITY_P1 1.0", "    #define FXAA_QUALITY_P2 1.0", "    #define FXAA_QUALITY_P3 1.0", "    #define FXAA_QUALITY_P4 1.0", "    #define FXAA_QUALITY_P5 1.5", "    #define FXAA_QUALITY_P6 2.0", "    #define FXAA_QUALITY_P7 2.0", "    #define FXAA_QUALITY_P8 2.0", "    #define FXAA_QUALITY_P9 2.0", "    #define FXAA_QUALITY_P10 4.0", "    #define FXAA_QUALITY_P11 8.0", "#endif", "", "", "", "/*============================================================================", "", "                                API PORTING", "", "============================================================================*/", "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)", "    #define FxaaBool bool", "    #define FxaaDiscard discard", "    #define FxaaFloat float", "    #define FxaaFloat2 vec2", "    #define FxaaFloat3 vec3", "    #define FxaaFloat4 vec4", "    #define FxaaHalf float", "    #define FxaaHalf2 vec2", "    #define FxaaHalf3 vec3", "    #define FxaaHalf4 vec4", "    #define FxaaInt2 ivec2", "    #define FxaaSat(x) clamp(x, 0.0, 1.0)", "    #define FxaaTex sampler2D", "#else", "    #define FxaaBool bool", "    #define FxaaDiscard clip(-1)", "    #define FxaaFloat float", "    #define FxaaFloat2 float2", "    #define FxaaFloat3 float3", "    #define FxaaFloat4 float4", "    #define FxaaHalf half", "    #define FxaaHalf2 half2", "    #define FxaaHalf3 half3", "    #define FxaaHalf4 half4", "    #define FxaaSat(x) saturate(x)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_100 == 1)", "  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)", "  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_120 == 1)", "    // Requires,", "    //  #version 120", "    // And at least,", "    //  #extension GL_EXT_gpu_shader4 : enable", "    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)", "    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)", "    #if (FXAA_FAST_PIXEL_OFFSET == 1)", "        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)", "    #else", "        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)", "    #endif", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_GLSL_130 == 1)", '    // Requires "#version 130" or better', "    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)", "    #if (FXAA_GATHER4_ALPHA == 1)", "        // use #extension GL_ARB_gpu_shader5 : enable", "        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)", "        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)", "        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)", "        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)", "    #endif", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_3 == 1)", "    #define FxaaInt2 float2", "    #define FxaaTex sampler2D", "    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))", "    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_4 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "#endif", "/*--------------------------------------------------------------------------*/", "#if (FXAA_HLSL_5 == 1)", "    #define FxaaInt2 int2", "    struct FxaaTex { SamplerState smpl; Texture2D tex; };", "    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)", "    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)", "    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)", "    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)", "    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)", "    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)", "#endif", "", "", "/*============================================================================", "                   GREEN AS LUMA OPTION SUPPORT FUNCTION", "============================================================================*/", "#if (FXAA_GREEN_AS_LUMA == 0)", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }", "#else", "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }", "#endif", "", "", "", "", "/*============================================================================", "", "                             FXAA3 QUALITY - PC", "", "============================================================================*/", "#if (FXAA_PC == 1)", "/*--------------------------------------------------------------------------*/", "FxaaFloat4 FxaaPixelShader(", "    //", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy} = center of pixel", "    FxaaFloat2 pos,", "    //", "    // Used only for FXAA Console, and not used on the 360 version.", "    // Use noperspective interpolation here (turn off perspective interpolation).", "    // {xy_} = upper left of pixel", "    // {_zw} = lower right of pixel", "    FxaaFloat4 fxaaConsolePosPos,", "    //", "    // Input color texture.", "    // {rgb_} = color in linear or perceptual color space", "    // if (FXAA_GREEN_AS_LUMA == 0)", "    //     {__a} = luma in perceptual color space (not linear)", "    FxaaTex tex,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 2nd sampler.", "    // This sampler needs to have an exponent bias of -1.", "    FxaaTex fxaaConsole360TexExpBiasNegOne,", "    //", "    // Only used on the optimized 360 version of FXAA Console.", '    // For everything but 360, just use the same input here as for "tex".', "    // For 360, same texture, just alias with a 3nd sampler.", "    // This sampler needs to have an exponent bias of -2.", "    FxaaTex fxaaConsole360TexExpBiasNegTwo,", "    //", "    // Only used on FXAA Quality.", "    // This must be from a constant/uniform.", "    // {x_} = 1.0/screenWidthInPixels", "    // {_y} = 1.0/screenHeightInPixels", "    FxaaFloat2 fxaaQualityRcpFrame,", "    //", "    // Only used on FXAA Console.", "    // This must be from a constant/uniform.", "    // This effects sub-pixel AA quality and inversely sharpness.", "    //   Where N ranges between,", "    //     N = 0.50 (default)", "    //     N = 0.33 (sharper)", "    // {x__} = -N/screenWidthInPixels", "    // {_y_} = -N/screenHeightInPixels", "    // {_z_} =  N/screenWidthInPixels", "    // {__w} =  N/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt,", "    //", "    // Only used on FXAA Console.", "    // Not used on 360, but used on PS3 and PC.", "    // This must be from a constant/uniform.", "    // {x__} = -2.0/screenWidthInPixels", "    // {_y_} = -2.0/screenHeightInPixels", "    // {_z_} =  2.0/screenWidthInPixels", "    // {__w} =  2.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,", "    //", "    // Only used on FXAA Console.", "    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.", "    // This must be from a constant/uniform.", "    // {x__} =  8.0/screenWidthInPixels", "    // {_y_} =  8.0/screenHeightInPixels", "    // {_z_} = -4.0/screenWidthInPixels", "    // {__w} = -4.0/screenHeightInPixels", "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_SUBPIX define.", "    // It is here now to allow easier tuning.", "    // Choose the amount of sub-pixel aliasing removal.", "    // This can effect sharpness.", "    //   1.00 - upper limit (softer)", "    //   0.75 - default amount of filtering", "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)", "    //   0.25 - almost off", "    //   0.00 - completely off", "    FxaaFloat fxaaQualitySubpix,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // The minimum amount of local contrast required to apply algorithm.", "    //   0.333 - too little (faster)", "    //   0.250 - low quality", "    //   0.166 - default", "    //   0.125 - high quality", "    //   0.063 - overkill (slower)", "    FxaaFloat fxaaQualityEdgeThreshold,", "    //", "    // Only used on FXAA Quality.", "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    //   0.0833 - upper limit (default, the start of visible unfiltered edges)", "    //   0.0625 - high quality (faster)", "    //   0.0312 - visible limit (slower)", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaQualityEdgeThresholdMin,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only three safe values here: 2 and 4 and 8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // For all other platforms can be a non-power of two.", "    //   8.0 is sharper (default!!!)", "    //   4.0 is softer", "    //   2.0 is really soft (good only for vector graphics inputs)", "    FxaaFloat fxaaConsoleEdgeSharpness,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.", "    // It is here now to allow easier tuning.", "    // This does not effect PS3, as this needs to be compiled in.", "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.", "    //   Due to the PS3 being ALU bound,", "    //   there are only two safe values here: 1/4 and 1/8.", "    //   These options use the shaders ability to a free *|/ by 2|4|8.", "    // The console setting has a different mapping than the quality setting.", "    // Other platforms can use other values.", "    //   0.125 leaves less aliasing, but is softer (default!!!)", "    //   0.25 leaves more aliasing, and is sharper", "    FxaaFloat fxaaConsoleEdgeThreshold,", "    //", "    // Only used on FXAA Console.", "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.", "    // It is here now to allow easier tuning.", "    // Trims the algorithm from processing darks.", "    // The console setting has a different mapping than the quality setting.", "    // This only applies when FXAA_EARLY_EXIT is 1.", "    // This does not apply to PS3,", "    // PS3 was simplified to avoid more shader instructions.", "    //   0.06 - faster but more aliasing in darks", "    //   0.05 - default", "    //   0.04 - slower and less aliasing in darks", "    // Special notes when using FXAA_GREEN_AS_LUMA,", "    //   Likely want to set this to zero.", "    //   As colors that are mostly not-green", "    //   will appear very dark in the green channel!", "    //   Tune by looking at mostly non-green content,", "    //   then start at zero and increase until aliasing is a problem.", "    FxaaFloat fxaaConsoleEdgeThresholdMin,", "    //", "    // Extra constants for 360 FXAA Console only.", "    // Use zeros or anything else for other platforms.", "    // These must be in physical constant registers and NOT immedates.", "    // Immedates will result in compiler un-optimizing.", "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)", "    FxaaFloat4 fxaaConsole360ConstDir", ") {", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posM;", "    posM.x = pos.x;", "    posM.y = pos.y;", "    #if (FXAA_GATHER4_ALPHA == 1)", "        #if (FXAA_DISCARD == 0)", "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "            #if (FXAA_GREEN_AS_LUMA == 0)", "                #define lumaM rgbyM.w", "            #else", "                #define lumaM rgbyM.y", "            #endif", "        #endif", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));", "        #else", "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);", "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));", "        #endif", "        #if (FXAA_DISCARD == 1)", "            #define lumaM luma4A.w", "        #endif", "        #define lumaE luma4A.z", "        #define lumaS luma4A.x", "        #define lumaSE luma4A.y", "        #define lumaNW luma4B.w", "        #define lumaN luma4B.z", "        #define lumaW luma4B.x", "    #else", "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);", "        #if (FXAA_GREEN_AS_LUMA == 0)", "            #define lumaM rgbyM.w", "        #else", "            #define lumaM rgbyM.y", "        #endif", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));", "        #endif", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat maxSM = max(lumaS, lumaM);", "    FxaaFloat minSM = min(lumaS, lumaM);", "    FxaaFloat maxESM = max(lumaE, maxSM);", "    FxaaFloat minESM = min(lumaE, minSM);", "    FxaaFloat maxWN = max(lumaN, lumaW);", "    FxaaFloat minWN = min(lumaN, lumaW);", "    FxaaFloat rangeMax = max(maxWN, maxESM);", "    FxaaFloat rangeMin = min(minWN, minESM);", "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;", "    FxaaFloat range = rangeMax - rangeMin;", "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);", "    FxaaBool earlyExit = range < rangeMaxClamped;", "/*--------------------------------------------------------------------------*/", "    if(earlyExit)", "        #if (FXAA_DISCARD == 1)", "            FxaaDiscard;", "        #else", "            return rgbyM;", "        #endif", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_GATHER4_ALPHA == 0)", "        #if (FXAA_GLSL_100 == 1)", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));", "        #else", "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));", "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "        #endif", "    #else", "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));", "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));", "    #endif", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNS = lumaN + lumaS;", "    FxaaFloat lumaWE = lumaW + lumaE;", "    FxaaFloat subpixRcpRange = 1.0/range;", "    FxaaFloat subpixNSWE = lumaNS + lumaWE;", "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;", "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNESE = lumaNE + lumaSE;", "    FxaaFloat lumaNWNE = lumaNW + lumaNE;", "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;", "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat lumaNWSW = lumaNW + lumaSW;", "    FxaaFloat lumaSWSE = lumaSW + lumaSE;", "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);", "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);", "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;", "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;", "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;", "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;", "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;", "    FxaaBool horzSpan = edgeHorz >= edgeVert;", "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;", "/*--------------------------------------------------------------------------*/", "    if(!horzSpan) lumaN = lumaW;", "    if(!horzSpan) lumaS = lumaE;", "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;", "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat gradientN = lumaN - lumaM;", "    FxaaFloat gradientS = lumaS - lumaM;", "    FxaaFloat lumaNN = lumaN + lumaM;", "    FxaaFloat lumaSS = lumaS + lumaM;", "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);", "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));", "    if(pairN) lengthSign = -lengthSign;", "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posB;", "    posB.x = posM.x;", "    posB.y = posM.y;", "    FxaaFloat2 offNP;", "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;", "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;", "    if(!horzSpan) posB.x += lengthSign * 0.5;", "    if( horzSpan) posB.y += lengthSign * 0.5;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat2 posN;", "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;", "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat2 posP;", "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;", "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;", "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;", "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));", "    FxaaFloat subpixE = subpixC * subpixC;", "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));", "/*--------------------------------------------------------------------------*/", "    if(!pairN) lumaNN = lumaSS;", "    FxaaFloat gradientScaled = gradient * 1.0/4.0;", "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;", "    FxaaFloat subpixF = subpixD * subpixE;", "    FxaaBool lumaMLTZero = lumaMM < 0.0;", "/*--------------------------------------------------------------------------*/", "    lumaEndN -= lumaNN * 0.5;", "    lumaEndP -= lumaNN * 0.5;", "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;", "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;", "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;", "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;", "    FxaaBool doneNP = (!doneN) || (!doneP);", "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;", "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;", "/*--------------------------------------------------------------------------*/", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 3)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 4)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 5)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 6)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;", "/*--------------------------------------------------------------------------*/", "                        #if (FXAA_QUALITY_PS > 7)", "                        if(doneNP) {", "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                            doneN = abs(lumaEndN) >= gradientScaled;", "                            doneP = abs(lumaEndP) >= gradientScaled;", "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;", "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;", "                            doneNP = (!doneN) || (!doneP);", "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;", "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;", "/*--------------------------------------------------------------------------*/", "    #if (FXAA_QUALITY_PS > 8)", "    if(doneNP) {", "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "        doneN = abs(lumaEndN) >= gradientScaled;", "        doneP = abs(lumaEndP) >= gradientScaled;", "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;", "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;", "        doneNP = (!doneN) || (!doneP);", "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;", "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;", "/*--------------------------------------------------------------------------*/", "        #if (FXAA_QUALITY_PS > 9)", "        if(doneNP) {", "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "            doneN = abs(lumaEndN) >= gradientScaled;", "            doneP = abs(lumaEndP) >= gradientScaled;", "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;", "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;", "            doneNP = (!doneN) || (!doneP);", "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;", "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;", "/*--------------------------------------------------------------------------*/", "            #if (FXAA_QUALITY_PS > 10)", "            if(doneNP) {", "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                doneN = abs(lumaEndN) >= gradientScaled;", "                doneP = abs(lumaEndP) >= gradientScaled;", "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;", "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;", "                doneNP = (!doneN) || (!doneP);", "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;", "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;", "/*--------------------------------------------------------------------------*/", "                #if (FXAA_QUALITY_PS > 11)", "                if(doneNP) {", "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                    doneN = abs(lumaEndN) >= gradientScaled;", "                    doneP = abs(lumaEndP) >= gradientScaled;", "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;", "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;", "                    doneNP = (!doneN) || (!doneP);", "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;", "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;", "/*--------------------------------------------------------------------------*/", "                    #if (FXAA_QUALITY_PS > 12)", "                    if(doneNP) {", "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));", "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));", "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;", "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;", "                        doneN = abs(lumaEndN) >= gradientScaled;", "                        doneP = abs(lumaEndP) >= gradientScaled;", "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;", "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;", "                        doneNP = (!doneN) || (!doneP);", "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;", "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "    #endif", "/*--------------------------------------------------------------------------*/", "                        }", "                        #endif", "/*--------------------------------------------------------------------------*/", "                    }", "                    #endif", "/*--------------------------------------------------------------------------*/", "                }", "                #endif", "/*--------------------------------------------------------------------------*/", "            }", "            #endif", "/*--------------------------------------------------------------------------*/", "        }", "        #endif", "/*--------------------------------------------------------------------------*/", "    }", "/*--------------------------------------------------------------------------*/", "    FxaaFloat dstN = posM.x - posN.x;", "    FxaaFloat dstP = posP.x - posM.x;", "    if(!horzSpan) dstN = posM.y - posN.y;", "    if(!horzSpan) dstP = posP.y - posM.y;", "/*--------------------------------------------------------------------------*/", "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;", "    FxaaFloat spanLength = (dstP + dstN);", "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;", "    FxaaFloat spanLengthRcp = 1.0/spanLength;", "/*--------------------------------------------------------------------------*/", "    FxaaBool directionN = dstN < dstP;", "    FxaaFloat dst = min(dstN, dstP);", "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;", "    FxaaFloat subpixG = subpixF * subpixF;", "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;", "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;", "/*--------------------------------------------------------------------------*/", "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;", "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);", "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;", "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;", "    #if (FXAA_DISCARD == 1)", "        return FxaaTexTop(tex, posM);", "    #else", "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);", "    #endif", "}", "/*==========================================================================*/", "#endif", "", "void main() {", "  gl_FragColor = FxaaPixelShader(", "    vUv,", "    vec4(0.0),", "    tDiffuse,", "    tDiffuse,", "    tDiffuse,", "    resolution,", "    vec4(0.0),", "    vec4(0.0),", "    vec4(0.0),", "    0.75,", "    0.166,", "    0.0833,", "    0.0,", "    0.0,", "    0.0,", "    vec4(0.0)", "  );", "", "  // TODO avoid querying texture twice for same texel", "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;", "}"].join("\n")
    };
    var qx = 100, Qx = 1, Zx = .75 * Qx, Jx = qx - 2 * Zx, Kx = null, $x = null, eb = null, tb = null, ib = null,
        nb = null;
    var rb = {
        SIZE: qx, HEIGHT: Qx, create: function () {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : pl;
            Kx || function () {
                var e = new cy;
                e.moveTo(Zx, Zx), e.lineTo(Zx + Jx, Zx), e.lineTo(Zx + Jx, Zx + Jx), e.lineTo(Zx, Zx + Jx), e.lineTo(Zx, Zx);
                var t = new cy;
                t.moveTo(0, 0), t.lineTo(0, qx), t.lineTo(qx, qx), t.lineTo(qx, 0), t.lineTo(0, 0), t.holes.push(e), Kx = new tv(t, {
                    steps: 1, depth: Qx, bevelEnabled: !1
                })
            }(), e !== pl || $x || (($x = new Mv({color: 11451595})).emissive = new $u(67084)), e !== ul || eb || ((eb = new Mv({color: 16777215})).emissive = new $u(15461098)), tb || (tb = new ld(Jx, Jx, Qx)), e !== pl || ib || (ib = new Gd({color: new $u(67084)})), e !== ul || nb || (nb = new Gd({color: new $u(16777215)}));
            var t = e === pl ? $x : eb, i = e === pl ? ib : nb, n = new Pp;
            n.position.x = .5 * -qx, n.position.z = .5 * -qx;
            var r = new jd(Kx, t);
            n.add(r);
            var a = new jd(tb, i);
            return a.position.x = .5 * Jx + Zx, a.position.y = .5 * Jx + Zx, a.position.z = .5 * Qx, n.add(a), n
        }, dispose: function () {
            $x && ($x.dispose(), $x = null), eb && (eb.dispose(), eb = null), Kx && (Kx.dispose(), Kx = null), ib && (ib.dispose(), ib = null), nb && (nb.dispose(), nb = null), tb && (tb.dispose(), tb = null)
        }
    };

    function ab(e, t) {
        var i, n, r, a, o;
        this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new yu, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !1, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = {
            LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40
        }, this.mouseButtons = {
            LEFT: $l, MIDDLE: eh, RIGHT: th
        }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function () {
            return f.phi
        }, this.getAzimuthalAngle = function () {
            return f.theta
        }, this.saveState = function () {
            s.target0.copy(s.target), s.position0.copy(s.object.position), s.zoom0 = s.object.zoom
        }, this.reset = function () {
            s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(l), s.update(), p = u.NONE
        }, this.update = (i = new yu, n = (new vu).setFromUnitVectors(e.up, new yu(0, 1, 0)), r = n.clone().inverse(), a = new yu, o = new vu, function () {
            var e = s.object.position;
            return i.copy(e).sub(s.target), i.applyQuaternion(n), f.setFromVector3(i), s.autoRotate && p === u.NONE && L(2 * Math.PI / 60 / 60 * s.autoRotateSpeed), f.theta += m.theta, f.phi += m.phi, f.theta = Math.max(s.minAzimuthAngle, Math.min(s.maxAzimuthAngle, f.theta)), f.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= g, f.radius = Math.max(s.minDistance, Math.min(s.maxDistance, f.radius)), s.target.add(v), i.setFromSpherical(f), i.applyQuaternion(r), e.copy(s.target).add(i), s.object.lookAt(s.target), !0 === s.enableDamping ? (m.theta *= 1 - s.dampingFactor, m.phi *= 1 - s.dampingFactor, v.multiplyScalar(1 - s.dampingFactor)) : (m.set(0, 0, 0), v.set(0, 0, 0)), g = 1, !(!(y || a.distanceToSquared(s.object.position) > d || 8 * (1 - o.dot(s.object.quaternion)) > d) || (s.dispatchEvent(l), a.copy(s.object.position), o.copy(s.object.quaternion), y = !1))
        }), this.dispose = function () {
            s.domElement.removeEventListener("contextmenu", q, !1), s.domElement.removeEventListener("mousedown", B, !1), s.domElement.removeEventListener("wheel", j, !1), s.domElement.removeEventListener("touchstart", X, !1), s.domElement.removeEventListener("touchend", Y, !1), s.domElement.removeEventListener("touchmove", W, !1), document.removeEventListener("mousemove", H, !1), document.removeEventListener("mouseup", G, !1), window.removeEventListener("keydown", V, !1)
        };
        var s = this, l = {type: "change"}, h = {type: "start"}, c = {type: "end"},
            u = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4}, p = u.NONE, d = 1e-6,
            f = new _x, m = new _x, g = 1, v = new yu, y = !1, _ = new mu, x = new mu, b = new mu, w = new mu,
            T = new mu, S = new mu, E = new mu, A = new mu, M = new mu;

        function P() {
            return Math.pow(.95, s.zoomSpeed)
        }

        function L(e) {
            m.theta -= e
        }

        function C(e) {
            m.phi -= e
        }

        var I, R, O, F = (I = new yu, function (e, t) {
            I.setFromMatrixColumn(t, 0), I.multiplyScalar(-e), v.add(I)
        }), N = (R = new yu, function (e, t) {
            !0 === s.screenSpacePanning ? R.setFromMatrixColumn(t, 1) : (R.setFromMatrixColumn(t, 0), R.crossVectors(s.object.up, R)), R.multiplyScalar(e), v.add(R)
        }), k = (O = new yu, function (e, t) {
            var i = s.domElement === document ? s.domElement.body : s.domElement;
            if (s.object.isPerspectiveCamera) {
                var n = s.object.position;
                O.copy(n).sub(s.target);
                var r = O.length();
                r *= Math.tan(s.object.fov / 2 * Math.PI / 180), F(2 * e * r / i.clientHeight, s.object.matrix), N(2 * t * r / i.clientHeight, s.object.matrix)
            } else s.object.isOrthographicCamera ? (F(e * (s.object.right - s.object.left) / s.object.zoom / i.clientWidth, s.object.matrix), N(t * (s.object.top - s.object.bottom) / s.object.zoom / i.clientHeight, s.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = !1)
        });

        function U(e) {
            s.object.isPerspectiveCamera ? g /= e : s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * e)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
        }

        function D(e) {
            s.object.isPerspectiveCamera ? g *= e : s.object.isOrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / e)), s.object.updateProjectionMatrix(), y = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1)
        }

        function z(e) {
            w.set(e.clientX, e.clientY)
        }

        function B(e) {
            if (!1 !== s.enabled) {
                switch (e.preventDefault(), e.button) {
                    case s.mouseButtons.LEFT:
                        if (e.ctrlKey || e.metaKey) {
                            if (!1 === s.enablePan) return;
                            z(e), p = u.PAN
                        } else {
                            if (!1 === s.enableRotate) return;
                            i = e, _.set(i.clientX, i.clientY), p = u.ROTATE
                        }
                        break;
                    case s.mouseButtons.MIDDLE:
                        if (!1 === s.enableZoom) return;
                        t = e, E.set(t.clientX, t.clientY), p = u.DOLLY;
                        break;
                    case s.mouseButtons.RIGHT:
                        if (!1 === s.enablePan) return;
                        z(e), p = u.PAN
                }
                var t, i;
                p !== u.NONE && (document.addEventListener("mousemove", H, !1), document.addEventListener("mouseup", G, !1), s.dispatchEvent(h))
            }
        }

        function H(e) {
            var t, i;
            if (!1 !== s.enabled) switch (e.preventDefault(), p) {
                case u.ROTATE:
                    if (!1 === s.enableRotate) return;
                    !function (e) {
                        x.set(e.clientX, e.clientY), b.subVectors(x, _).multiplyScalar(s.rotateSpeed);
                        var t = s.domElement === document ? s.domElement.body : s.domElement;
                        L(2 * Math.PI * b.x / t.clientHeight), C(2 * Math.PI * b.y / t.clientHeight), _.copy(x), s.update()
                    }(e);
                    break;
                case u.DOLLY:
                    if (!1 === s.enableZoom) return;
                    i = e, A.set(i.clientX, i.clientY), M.subVectors(A, E), 0 < M.y ? U(P()) : M.y < 0 && D(P()), E.copy(A), s.update();
                    break;
                case u.PAN:
                    if (!1 === s.enablePan) return;
                    t = e, T.set(t.clientX, t.clientY), S.subVectors(T, w).multiplyScalar(s.panSpeed), k(S.x, S.y), w.copy(T), s.update()
            }
        }

        function G(e) {
            !1 !== s.enabled && (document.removeEventListener("mousemove", H, !1), document.removeEventListener("mouseup", G, !1), s.dispatchEvent(c), p = u.NONE)
        }

        function j(e) {
            var t;
            !1 === s.enabled || !1 === s.enableZoom || p !== u.NONE && p !== u.ROTATE || (e.preventDefault(), e.stopPropagation(), s.dispatchEvent(h), (t = e).deltaY < 0 ? D(P()) : 0 < t.deltaY && U(P()), s.update(), s.dispatchEvent(c))
        }

        function V(e) {
            !1 !== s.enabled && !1 !== s.enableKeys && !1 !== s.enablePan && function (e) {
                switch (e.keyCode) {
                    case s.keys.UP:
                        k(0, s.keyPanSpeed), s.update();
                        break;
                    case s.keys.BOTTOM:
                        k(0, -s.keyPanSpeed), s.update();
                        break;
                    case s.keys.LEFT:
                        k(s.keyPanSpeed, 0), s.update();
                        break;
                    case s.keys.RIGHT:
                        k(-s.keyPanSpeed, 0), s.update()
                }
            }(e)
        }

        function X(e) {
            if (!1 !== s.enabled) {
                switch (e.preventDefault(), e.touches.length) {
                    case 1:
                        if (!1 === s.enableRotate) return;
                        t = e, _.set(t.touches[0].pageX, t.touches[0].pageY), p = u.TOUCH_ROTATE;
                        break;
                    case 2:
                        if (!1 === s.enableZoom && !1 === s.enablePan) return;
                        !function (e) {
                            if (s.enableZoom) {
                                var t = e.touches[0].pageX - e.touches[1].pageX,
                                    i = e.touches[0].pageY - e.touches[1].pageY, n = Math.sqrt(t * t + i * i);
                                E.set(0, n)
                            }
                            if (s.enablePan) {
                                var r = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                                    a = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                                w.set(r, a)
                            }
                        }(e), p = u.TOUCH_DOLLY_PAN;
                        break;
                    default:
                        p = u.NONE
                }
                var t;
                p !== u.NONE && s.dispatchEvent(h)
            }
        }

        function W(e) {
            if (!1 !== s.enabled) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) {
                case 1:
                    if (!1 === s.enableRotate) return;
                    if (p !== u.TOUCH_ROTATE) return;
                    !function (e) {
                        x.set(e.touches[0].pageX, e.touches[0].pageY), b.subVectors(x, _).multiplyScalar(s.rotateSpeed);
                        var t = s.domElement === document ? s.domElement.body : s.domElement;
                        L(2 * Math.PI * b.x / t.clientHeight), C(2 * Math.PI * b.y / t.clientHeight), _.copy(x), s.update()
                    }(e);
                    break;
                case 2:
                    if (!1 === s.enableZoom && !1 === s.enablePan) return;
                    if (p !== u.TOUCH_DOLLY_PAN) return;
                    !function (e) {
                        if (s.enableZoom) {
                            var t = e.touches[0].pageX - e.touches[1].pageX,
                                i = e.touches[0].pageY - e.touches[1].pageY, n = Math.sqrt(t * t + i * i);
                            A.set(0, n), M.set(0, Math.pow(A.y / E.y, s.zoomSpeed)), U(M.y), E.copy(A)
                        }
                        if (s.enablePan) {
                            var r = .5 * (e.touches[0].pageX + e.touches[1].pageX),
                                a = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                            T.set(r, a), S.subVectors(T, w).multiplyScalar(s.panSpeed), k(S.x, S.y), w.copy(T)
                        }
                        s.update()
                    }(e);
                    break;
                default:
                    p = u.NONE
            }
        }

        function Y(e) {
            !1 !== s.enabled && (s.dispatchEvent(c), p = u.NONE)
        }

        function q(e) {
            !1 !== s.enabled && e.preventDefault()
        }

        if (false) {
            s.domElement.addEventListener("contextmenu", q, !1), s.domElement.addEventListener("mousedown", B, !1), s.domElement.addEventListener("wheel", j, !1), s.domElement.addEventListener("touchstart", X, !1), s.domElement.addEventListener("touchend", Y, !1), s.domElement.addEventListener("touchmove", W, !1), window.addEventListener("keydown", V, !1), this.update()
        }

    }

    (ab.prototype = Object.create(Il.prototype)).constructor = ab, Object.defineProperties(ab.prototype, {
        center: {
            get: function () {
                return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target
            }
        }, noZoom: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e
            }
        }, noRotate: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e
            }
        }, noPan: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e
            }
        }, noKeys: {
            get: function () {
                return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e
            }
        }, staticMoving: {
            get: function () {
                return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e
            }
        }, dynamicDampingFactor: {
            get: function () {
                return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor
            }, set: function (e) {
                console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e
            }
        }
    });
    var ob = function () {
        function a(e) {
            es(this, a);
            var t = {
                uniforms: {uColor: {type: "v3", value: e.color}, uOpacity: {type: "f", value: 1}},
                vertexShader: "#define GLSLIFY 1\nvoid main(){\n  gl_Position = vec4(position, 1.0);\n}",
                fragmentShader: "#define GLSLIFY 1\nuniform vec3 uColor;\nuniform float uOpacity;\n    \nvoid main(){\n  gl_FragColor = vec4(uColor, uOpacity);\n}",
                depthWrite: !1,
                fog: !1
            };
            if (e.hasOwnProperty("material")) for (var i in e.material) t[i] = e.material[i];
            var n = new zd(t), r = new ud(2, 2, 1, 1);
            this.mesh = new jd(r, n), this.mesh.frustumCulled = !1, this.mesh.renderOrder = -1
        }

        return is(a, [{
            key: "dispose", value: function () {
            }
        }, {
            key: "opacity", get: function () {
                return this.mesh.material.uniforms.uOpacity.value
            }, set: function (e) {
                this.mesh.material.uniforms.uOpacity.value = e
            }
        }]), a
    }(), sb = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this, e))).index = e.index, t.color = e.color, t.owner = e.owner, t.mouseX = 0, t.mouseY = 0, t.mousePosition = new yu(t.mouseX, t.mouseY, .5), t.mouseEnabled = !1, t.onMouseMoveCallback = t.onMouseMove.bind(ss(ss(t))), t.timeline = null, t.scene = new Wm, t.background = null, t.mouseControlPosition = new mu(t.mouseX, t.mouseY), t.cameraPositionInit = new yu, t.cameraTargetPositionInit = new yu, t.mouseControlDirection = new mu(1, 1), t.slowMovementIsRunning = !1, t.slowMovementStartTime = 0, t.slowMovementDuration = 40, t.slowMovementProgress = 0, t.slowMovementDirection = 1, t.initCamera(), t.initLights(), t.initMeshes(), t
        }

        return ns(i, bs), is(i, [{
            key: "initCamera", value: function () {
                this.cameraPivot = new Pp, this.cameraPivot.position.set(-5, 10, 5), this.scene.add(this.cameraPivot), this.camera = new zm(37, window.innerWidth / window.innerHeight, .1, 1e3), this.camera.zoom = 1.5625, this.camera.updateProjectionMatrix(), this.cameraPivot.add(this.camera), this.cameraTarget = new Pp, this.cameraPivot.add(this.cameraTarget), this.cameraTargetPosition = new yu, this.cameraWorldPosition = new yu
            }
        }, {
            key: "initLights", value: function () {
                this.cameraPivot.updateMatrixWorld(), this.camera.getWorldPosition(this.cameraWorldPosition);
                var e = this.color === ul ? .4 : 2;
                this.mouseLight = new my(3423042, e, 70, fu.degToRad(12), 1, 2), this.mouseLight.position.copy(this.cameraWorldPosition), this.scene.add(this.mouseLight), this.scene.add(this.mouseLight.target)
            }
        }, {
            key: "initMeshes", value: function () {
                this.boxes = [], this.color === ul && (this.background = new ob({color: new $u(16777215)}), this.scene.add(this.background.mesh));
                for (var e = 0; e < 13; e++) {
                    var t = rb.create(this.color);
                    t.position.y = e * (6 + rb.HEIGHT) * -1 - 17, t.rotation.x = fu.degToRad(90), this.scene.add(t), this.boxes.push(t)
                }
            }
        }, {
            key: "dispose", value: function () {
                this.disableMouse(), this.disposeLights(), this.disposeMeshes()
            }
        }, {
            key: "disposeLights", value: function () {
            }
        }, {
            key: "disposeMeshes", value: function () {
                for (this.background && (this.background.dispose(), this.scene.remove(this.background), this.background = null); this.boxes.length;) {
                    var e = this.boxes.shift();
                    this.scene.remove(e)
                }
            }
        }, {
            key: "enableMouse", value: function () {
                this.mouseEnabled || (this.mouseEnabled = !0, window.addEventListener("mousemove", this.onMouseMoveCallback))
            }
        }, {
            key: "disableMouse", value: function () {
                this.mouseEnabled && (this.mouseEnabled = !1, window.removeEventListener("mousemove", this.onMouseMoveCallback))
            }
        }, {
            key: "createAnimIn", value: function (e) {
                this.timeline = new TimelineLite({onComplete: e}), this.enableMouse()
            }
        }, {
            key: "createAnimOut", value: function (e) {
                this.timeline = new TimelineLite({onComplete: e}), this.disableMouse(), this.pauseSlowMovement()
            }
        }, {
            key: "updateMouseLight", value: function () {
                this.camera.getWorldPosition(this.cameraWorldPosition), this.mouseLight.position.copy(this.cameraWorldPosition), this.mousePosition.x = this.mouseX, this.mousePosition.y = this.mouseY, this.mousePosition.unproject(this.camera);
                var e = this.mousePosition.sub(this.cameraWorldPosition).normalize(),
                    t = -this.cameraWorldPosition.z / e.z,
                    i = this.cameraWorldPosition.clone().add(e.multiplyScalar(t));
                this.mouseLight.target.position.x += .08 * (i.x - this.mouseLight.target.position.x), this.mouseLight.target.position.y += .08 * (i.y - this.mouseLight.target.position.y)
            }
        }, {
            key: "updateMouseControl", value: function () {
                var e = this.mouseX, t = this.mouseY;
                this.mouseControlPosition.x += .08 * (e - this.mouseControlPosition.x), this.mouseControlPosition.y += .08 * (t - this.mouseControlPosition.y), this.camera.position.x += this.mouseControlPosition.x * this.mouseControlDirection.x, this.camera.position.y += this.mouseControlPosition.y * this.mouseControlDirection.y
            }
        }, {
            key: "getCameraFov", value: function () {
                return e = window.innerWidth, t = window.innerHeight, void 0 === (i = 1920) && (i = 36), void 0 === (n = 1080) && (n = 24), n * (e / (i / 28)) / t;
                var e, t, i, n
            }
        }, {
            key: "render", value: function () {
                this.cameraTarget.getWorldPosition(this.cameraTargetPosition), this.renderCamera(), this.slowMovementIsRunning && this.updateSlowMovement(), this.mouseEnabled && (this.updateMouseLight(), this.timeline || this.updateMouseControl())
            }
        }, {
            key: "renderCamera", value: function () {
                this.camera.lookAt(this.cameraTargetPosition)
            }
        }, {
            key: "resize", value: function () {
                this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix()
            }
        }, {
            key: "startSlowMovement", value: function () {
                this.slowMovementIsRunning = !0, this.slowMovementStartTime = Date.now(), this.cameraPositionInit.copy(this.camera.position), this.cameraTargetPositionInit.copy(this.cameraTarget.position)
            }
        }, {
            key: "pauseSlowMovement", value: function () {
                this.slowMovementIsRunning = !1
            }
        }, {
            key: "updateSlowMovement", value: function () {
                var e = (Date.now() - this.slowMovementStartTime) / (1e3 * this.slowMovementDuration);
                this.slowMovementProgress = 1 === this.slowMovementDirection ? e : 1 - e, 1 < e && (this.slowMovementDirection *= -1, this.slowMovementStartTime = Date.now())
            }
        }, {
            key: "onMouseMove", value: function (e) {
                this.mouseX = e.clientX / window.innerWidth * 2 - 1, this.mouseY = e.clientY / window.innerHeight * -2 + 1
            }
        }, {
            key: "onAnimateInComplete", value: function (e) {
                hs(rs(i.prototype), "onAnimateInComplete", this).call(this, e), this.timeline = null, this.startSlowMovement()
            }
        }, {
            key: "onAnimateOutComplete", value: function (e) {
                hs(rs(i.prototype), "onAnimateOutComplete", this).call(this, e), this.disableMouse()
            }
        }]), i
    }(), lb = function (e) {
        function n(e) {
            var t;
            return es(this, n), (t = ls(this, rs(n).call(this, e))).mouseControlDirection.set(-1, -1), t
        }

        return ns(n, sb), is(n, [{
            key: "initCamera", value: function () {
                hs(rs(n.prototype), "initCamera", this).call(this), this.camera.position.set(-2.9, -105, 98), this.cameraTarget.position.set(-.8, -34, 15), this.cameraPivot.rotation.y = fu.degToRad(-43)
            }
        }, {
            key: "initLights", value: function () {
                hs(rs(n.prototype), "initLights", this).call(this), this.mouseLight.distance = 100;
                var e = new my(16777215, 1.5, 1.5 * rb.SIZE, fu.degToRad(90), 1, 1);
                e.position.set(-76.4, -31.6, 85.1), this.scene.add(e), this.scene.add(e.target), e.target.position.set(-42, 35, -43)
            }
        }, {
            key: "createAnimIn", value: function (e) {
                var i = this;
                hs(rs(n.prototype), "createAnimIn", this).call(this, e), this.timeline.from(this.camera.position, 3.2, {
                    y: "+=3", ease: Is.easeNone
                }, 0), this.boxes.forEach(function (e, t) {
                    i.timeline.from(e.rotation, 3, {z: fu.degToRad(20), ease: Power2.easeInOut}, -.15 * t)
                })
            }
        }, {
            key: "createAnimOut", value: function (e) {
                hs(rs(n.prototype), "createAnimOut", this).call(this, e), this.timeline.to(this.camera.position, 2, {
                    x: 13.1, y: -143.7, z: 85.8, ease: Power2.easeInOut
                }, 0), this.timeline.to(this.cameraTarget.position, 2, {
                    x: -1.2, y: -36.2, z: 13.7, ease: Power2.easeInOut
                }, 0)
            }
        }, {
            key: "updateSlowMovement", value: function () {
                hs(rs(n.prototype), "updateSlowMovement", this).call(this), this.camera.position.set(this.cameraPositionInit.x, this.cameraPositionInit.y - 15 * this.slowMovementProgress, this.cameraPositionInit.z)
            }
        }]), n
    }(), hb = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this, e))).slowMovementDuration = 70, t.mouseControlDirection.set(1, -1), t
        }

        return ns(i, sb), is(i, [{
            key: "initCamera", value: function () {
                hs(rs(i.prototype), "initCamera", this).call(this), this.camera.position.set(56.3, -49.5, -58.6), this.cameraTarget.position.set(-73.8, -64.7, -21.9), this.cameraPivot.rotation.x = fu.degToRad(-58), this.cameraPivot.rotation.y = fu.degToRad(-58)
            }
        }, {
            key: "initLights", value: function () {
                hs(rs(i.prototype), "initLights", this).call(this);
                var e = new my(16777215, .6, 0, .28, 1, 6);
                e.position.set(-68, 50, -81), this.scene.add(e), this.scene.add(e.target), e.target.position.set(-42, 35, -43)
            }
        }, {
            key: "createAnimIn", value: function (e) {
                hs(rs(i.prototype), "createAnimIn", this).call(this, e), this.timeline.from(this.camera.position, 3, {
                    x: 84.7, y: .7, z: -10.1, ease: Os.easeInOut
                }, 0).from(this.cameraTarget.position, 3, {x: -41.4, y: -65.2, z: -44.3, ease: Os.easeInOut}, 0)
            }
        }, {
            key: "createAnimOut", value: function (e) {
                hs(rs(i.prototype), "createAnimOut", this).call(this, e), 1 === (this.owner.currentScreen.index > this.index ? 1 : -1) ? (this.timeline.to(this.camera.position, 2, {
                    x: 37, y: -63, z: -74, ease: Os.easeInOut
                }, 0), this.timeline.to(this.cameraTarget.position, 2, {
                    x: -60.5, y: -67.3, z: -37.7, ease: Os.easeInOut
                }, 0)) : this.timeline.to(this.camera.position, 3, {
                    x: 84.7, y: .7, z: -10.1, ease: Os.easeInOut
                }, 0).to(this.cameraTarget.position, 3, {x: -41.4, y: -65.2, z: -44.3, ease: Os.easeInOut}, 0)
            }
        }, {
            key: "renderCamera", value: function () {
                hs(rs(i.prototype), "renderCamera", this).call(this), this.camera.rotateZ(fu.degToRad(-58))
            }
        }, {
            key: "updateSlowMovement", value: function () {
                hs(rs(i.prototype), "updateSlowMovement", this).call(this), this.camera.position.set(this.cameraPositionInit.x - 10 * this.slowMovementProgress, this.cameraPositionInit.y - 10 * this.slowMovementProgress, this.cameraPositionInit.z - 10 * this.slowMovementProgress), this.cameraTarget.position.set(this.cameraTargetPositionInit.x - 10 * this.slowMovementProgress, this.cameraTargetPositionInit.y - 10 * this.slowMovementProgress, this.cameraTargetPositionInit.z)
            }
        }]), i
    }(), cb = function () {
        function n(e) {
            es(this, n), this.path = e.path, this.width = e.width, this.height = e.height;
            var t = new zd({
                uniforms: {
                    uTexture: {type: "t", value: (new Hv).load(app.rootUrl + "/assets/img/" + e.path)},
                    uRatio: {type: "v2", value: this.getImageRatio()},
                    uTranslateX: {type: "f", value: 0},
                    uTranslateY: {type: "f", value: 0}
                },
                vertexShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform float uTranslateX;\nuniform float uTranslateY;\n\n// @see https://gist.github.com/jeanlescure/e27c93b73a10b64e85e4\n\nvoid main(){\n  vUv = uv;\n\n  float scale = 1.1;\n\n  // translate\n  mat4 tPos = mat4(\n    vec4(1.0,0.0,0.0,0.0),\n    vec4(0.0,1.0,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(uTranslateX,uTranslateY,0.0,1.0)\n  );\n\n  // scale\n  mat4 sPos = mat4(\n    vec4(scale,0.0,0.0,0.0),\n    vec4(0.0,scale,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(0.0,0.0,0.0,1.0)\n  );\n\n  mat4 vPosition = tPos * sPos;\n\n  gl_Position = vPosition * vec4(position, 1.0);\n}",
                fragmentShader: "#define GLSLIFY 1\nvarying vec2 vUv;\n    \nuniform sampler2D uTexture;\nuniform vec2 uRatio;\n    \nvoid main(){\n  vec2 uv = vec2(\n    vUv.x * uRatio.x + (1.0 - uRatio.x) * 0.5,\n    vUv.y * uRatio.y + (1.0 - uRatio.y) * 0.5\n  );\n\n  gl_FragColor = texture2D(uTexture , uv);\n}",
                depthWrite: !1,
                depthTest: !1,
                fog: !1,
                transparent: !0,
                blending: e.blending || null
            }), i = new ud(2, 2, 1, 1);
            this.mesh = new jd(i, t), this.mesh.frustumCulled = !1
        }

        return is(n, [{
            key: "dispose", value: function () {
            }
        }, {
            key: "getImageRatio", value: function () {
                return new mu(Math.min(window.innerWidth / window.innerHeight / (this.width / this.height), 1), Math.min(window.innerHeight / window.innerWidth / (this.height / this.width), 1))
            }
        }, {
            key: "resize", value: function () {
                this.mesh.material.uniforms.uRatio.value = this.getImageRatio()
            }
        }, {
            key: "x", get: function () {
                return this.mesh.material.uniforms.uTranslateX.value
            }, set: function (e) {
                this.mesh.material.uniforms.uTranslateX.value = e
            }
        }, {
            key: "y", get: function () {
                return this.mesh.material.uniforms.uTranslateY.value
            }, set: function (e) {
                this.mesh.material.uniforms.uTranslateY.value = e
            }
        }]), n
    }(), ub = function (e) {
        function r(e) {
            var t;
            return es(this, r), (t = ls(this, rs(r).call(this, e))).slowMovementDuration = 120, t
        }

        return ns(r, sb), is(r, [{
            key: "initCamera", value: function () {
                hs(rs(r.prototype), "initCamera", this).call(this), this.cameraPivot.rotation.x = fu.degToRad(-58), this.cameraPivot.rotation.y = fu.degToRad(-58), this.camera.position.set(16, -102, -78), this.cameraTarget.position.set(-91.8, -51.8, -51.1)
            }
        }, {
            key: "initLights", value: function () {
                hs(rs(r.prototype), "initLights", this).call(this);
                var e = new my(16777215, .16, 0, .37, 1, 6);
                e.position.set(-31, 53, 42), this.scene.add(e), this.scene.add(e.target), e.target.position.set(178, -651, 195)
            }
        }, {
            key: "initMeshes", value: function () {
                hs(rs(r.prototype), "initMeshes", this).call(this);
                var e = r.getImage(), t = e.path, i = e.width, n = e.height;
                this.image = new cb({
                    path: t, width: i, height: n, blending: dh
                }), this.scene.add(this.image.mesh), this.foreground = new ob({
                    color: new $u(16777215), material: {depthTest: !1, transparent: !0}
                }), this.foreground.mesh.renderOrder = 0, this.foreground.mesh.visible = !1, this.scene.add(this.foreground.mesh)
            }
        }, {
            key: "disposeMeshes", value: function () {
                hs(rs(r.prototype), "disposeMeshes", this).call(this), this.image.dispose(), this.scene.remove(this.image.mesh), this.image = null, this.foreground.dispose(), this.scene.remove(this.foreground), this.foreground = null
            }
        }, {
            key: "createAnimIn", value: function (e) {
                hs(rs(r.prototype), "createAnimIn", this).call(this, e);
                var t = this.owner.previousScreen && this.owner.previousScreen.index > this.owner.currentScreen.index ? -1 : 1;
                this.timeline.from(this.camera.position, 2, {
                    x: 32.6, y: -96.3, z: -73.9, ease: Os.easeInOut
                }, 0).from(this.cameraTarget.position, 2, {
                    x: -64.8, y: -58, z: -48, ease: Os.easeInOut
                }, 0).from(this.image, 2, {
                    y: -.5 * t, ease: Power3.easeInOut
                }, 0), this.owner.previousScreen && this.owner.previousScreen.color === ul && (this.foreground.mesh.visible = !0, this.timeline.to(this.foreground, 1.5, {
                    opacity: 0, ease: Os.easeInOut
                }, 0))
            }
        }, {
            key: "createAnimOut", value: function (e) {
                hs(rs(r.prototype), "createAnimOut", this).call(this, e);
                var t = this.owner.currentScreen.index > this.index ? 1 : -1;
                1 === t ? this.timeline.to(this.camera.position, 2, {
                    x: 0, y: -103, z: -73, ease: Os.easeInOut
                }, 0).to(this.cameraTarget.position, 2, {
                    x: -168, y: -55, z: -74, ease: Os.easeInOut
                }, 0) : this.timeline.to(this.camera.position, 2, {
                    x: 32.6, y: -96.3, z: -73.9, ease: Os.easeInOut
                }, 0).to(this.cameraTarget.position, 2, {
                    x: -64.8, y: -58, z: -48, ease: Os.easeInOut
                }, 0), this.timeline.to(this.image, 2, {
                    y: .5 * t, ease: Power3.easeInOut
                }, 0), this.owner.currentScreen && this.owner.currentScreen.color === ul && (this.foreground.mesh.visible = !0, this.timeline.fromTo(this.foreground, 1.5, {opacity: 0}, {
                    opacity: 1, ease: Os.easeInOut
                }, 0))
            }
        }, {
            key: "renderCamera", value: function () {
                hs(rs(r.prototype), "renderCamera", this).call(this), this.camera.rotateX(fu.degToRad(-6)), this.camera.rotateY(fu.degToRad(-7)), this.camera.rotateZ(fu.degToRad(-116))
            }
        }, {
            key: "resize", value: function () {
                hs(rs(r.prototype), "resize", this).call(this), this.image.resize()
            }
        }, {
            key: "updateSlowMovement", value: function () {
                hs(rs(r.prototype), "updateSlowMovement", this).call(this), this.camera.position.set(this.cameraPositionInit.x - 10 * this.slowMovementProgress, this.cameraPositionInit.y - 10 * this.slowMovementProgress, this.cameraPositionInit.z - 10 * this.slowMovementProgress), this.cameraTarget.position.set(this.cameraTargetPositionInit.x - 10 * this.slowMovementProgress, this.cameraTargetPositionInit.y - 10 * this.slowMovementProgress, this.cameraTargetPositionInit.z)
            }
        }, {
            key: "updateMouseControl", value: function () {
                hs(rs(r.prototype), "updateMouseControl", this).call(this), this.image.x = this.mouseControlPosition.x * this.mouseControlDirection.x * -.03, this.image.y = this.mouseControlPosition.y * this.mouseControlDirection.y * -.03
            }
        }, {
            key: "onAnimateInComplete", value: function (e) {
                hs(rs(r.prototype), "onAnimateInComplete", this).call(this, e), e || this.foreground && (this.foreground.mesh.visible = !1)
            }
        }], [{
            key: "getImage", value: function () {
                var e = 1024 < app.windowWidth ? 2 : 1, t = 1024 * e;
                return {width: t, height: 512 * e, path: "home-2-".concat(t, ".jpg")}
            }
        }]), r
    }(), pb = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this, e))).slowMovementDuration = 120, t
        }

        return ns(i, sb), is(i, [{
            key: "initCamera", value: function () {
                hs(rs(i.prototype), "initCamera", this).call(this), this.cameraPivot.rotation.x = fu.degToRad(-50), this.cameraPivot.rotation.y = fu.degToRad(-63), this.cameraPivot.rotation.z = fu.degToRad(30), this.camera.position.set(11.6, -86.6, -27.9), this.cameraTarget.position.set(-78.4, -61.4, -38), this.cameraPivot.position.set(15, 1.21, -6)
            }
        }, {
            key: "initLights", value: function () {
                hs(rs(i.prototype), "initLights", this).call(this);
                var e = new my(16777215, .21, 0, .59, 1, 6);
                e.position.set(68, 13, 68), this.scene.add(e), this.scene.add(e.target), e.target.position.set(-197, -474, -44)
            }
        }, {
            key: "createAnimIn", value: function (e) {
                hs(rs(i.prototype), "createAnimIn", this).call(this, e), this.timeline.from(this.camera.position, 2, {
                    x: -2.5, y: -88, z: -48, ease: Os.easeInOut
                }, 0)
            }
        }, {
            key: "createAnimOut", value: function (e) {
                hs(rs(i.prototype), "createAnimOut", this).call(this, e), 1 === (this.owner.currentScreen.index > this.index ? 1 : -1) ? (this.timeline.to(this.camera.position, 2, {
                    x: 1, y: -98, z: -31, ease: Os.easeInOut
                }, 0), this.timeline.to(this.cameraTarget.position, 2, {
                    x: -76, y: -60, z: -40, ease: Os.easeInOut
                }, 0)) : this.timeline.to(this.camera.position, 2, {x: -2.5, y: -88, z: -48, ease: Os.easeInOut}, 0)
            }
        }, {
            key: "renderCamera", value: function () {
                hs(rs(i.prototype), "renderCamera", this).call(this), this.camera.rotateX(fu.degToRad(24)), this.camera.rotateZ(fu.degToRad(-80))
            }
        }, {
            key: "updateSlowMovement", value: function () {
                hs(rs(i.prototype), "updateSlowMovement", this).call(this), this.camera.position.set(this.cameraPositionInit.x + 10 * this.slowMovementProgress, this.cameraPositionInit.y + 10 * this.slowMovementProgress, this.cameraPositionInit.z + 10 * this.slowMovementProgress), this.cameraTarget.position.set(this.cameraTargetPositionInit.x + 30 * this.slowMovementProgress, this.cameraTargetPositionInit.y + 10 * this.slowMovementProgress, this.cameraTargetPositionInit.z + 10 * this.slowMovementProgress)
            }
        }]), i
    }(), db = function (e) {
        function r(e) {
            var t;
            return es(this, r), (t = ls(this, rs(r).call(this, e))).slowMovementDuration = 120, t
        }

        return ns(r, sb), is(r, [{
            key: "initCamera", value: function () {
                hs(rs(r.prototype), "initCamera", this).call(this), this.cameraPivot.rotation.set(-.99, -1.31, .28), this.cameraPivot.position.set(15.2, 7.56, 9.57), this.camera.position.set(23.5, -54.5, -36), this.cameraTarget.position.set(-51.8, -45, -34)
            }
        }, {
            key: "initLights", value: function () {
                hs(rs(r.prototype), "initLights", this).call(this);
                var e = new my(16777215, .16, 0, 1.57, 1, 6);
                e.position.set(66, 9, 64), this.scene.add(e), this.scene.add(e.target), e.target.position.set(1, -16, -1)
            }
        }, {
            key: "initMeshes", value: function () {
                hs(rs(r.prototype), "initMeshes", this).call(this);
                var e = r.getImage(), t = e.path, i = e.width, n = e.height;
                this.image = new cb({path: t, width: i, height: n, blending: mh}), this.scene.add(this.image.mesh)
            }
        }, {
            key: "disposeMeshes", value: function () {
                hs(rs(r.prototype), "disposeMeshes", this).call(this), this.image.dispose(), this.scene.remove(this.image.mesh), this.image = null
            }
        }, {
            key: "createAnimIn", value: function (e) {
                hs(rs(r.prototype), "createAnimIn", this).call(this, e);
                var t = this.owner.previousScreen && this.owner.previousScreen.index > this.owner.currentScreen.index ? -1 : 1;
                this.timeline.from(this.camera.position, 2, {
                    x: 22, y: -59.7, z: -36, ease: Os.easeInOut
                }, 0).from(this.image, 2, {y: -.5 * t, ease: Power3.easeInOut}, 0)
            }
        }, {
            key: "createAnimOut", value: function (e) {
                hs(rs(r.prototype), "createAnimOut", this).call(this, e);
                var t = this.owner.currentScreen.index > this.index ? 1 : -1;
                1 === t ? this.timeline.to(this.camera.position, 2, {
                    x: 20, y: -60, z: -37, ease: Os.easeInOut
                }, 0).to(this.cameraTarget.position, 2, {
                    x: -72, y: -38, z: -32, ease: Os.easeInOut
                }, 0) : this.timeline.to(this.camera.position, 2, {
                    x: 22, y: -59.7, z: -36, ease: Os.easeInOut
                }, 0).to(this.image, 2, {
                    y: -.5 * t, ease: Power3.easeInOut
                }, 0), this.timeline.to(this.image, 2, {y: .5 * t, ease: Power3.easeInOut}, 0)
            }
        }, {
            key: "renderCamera", value: function () {
                hs(rs(r.prototype), "renderCamera", this).call(this), this.camera.rotateX(fu.degToRad(17)), this.camera.rotateY(fu.degToRad(9)), this.camera.rotateZ(fu.degToRad(-208))
            }
        }, {
            key: "updateSlowMovement", value: function () {
                hs(rs(r.prototype), "updateSlowMovement", this).call(this), this.camera.position.set(this.cameraPositionInit.x + 10 * this.slowMovementProgress, this.cameraPositionInit.y + 5 * this.slowMovementProgress, this.cameraPositionInit.z + 5 * this.slowMovementProgress), this.cameraTarget.position.set(this.cameraTargetPositionInit.x + 10 * this.slowMovementProgress, this.cameraTargetPositionInit.y + 5 * this.slowMovementProgress, this.cameraTargetPositionInit.z + 5 * this.slowMovementProgress)
            }
        }, {
            key: "updateMouseControl", value: function () {
                hs(rs(r.prototype), "updateMouseControl", this).call(this), this.image.x = this.mouseControlPosition.x * this.mouseControlDirection.x * -.03, this.image.y = this.mouseControlPosition.y * this.mouseControlDirection.y * -.03
            }
        }], [{
            key: "getImage", value: function () {
                var e = 1024 < app.windowWidth ? 2 : 1, t = 1024 * e;
                return {width: t, height: 512 * e, path: "home-4-".concat(t, ".jpg")}
            }
        }]), r
    }();

    function fb(e, t) {
        Hx.call(this), this.needsSwap = !1, this.clearColor = void 0 !== e ? e : 0, this.clearAlpha = void 0 !== t ? t : 0
    }

    fb.prototype = Object.assign(Object.create(Hx.prototype), {
        constructor: fb, render: function (e, t, i, n, r) {
            var a, o;
            this.clearColor && (a = e.getClearColor().getHex(), o = e.getClearAlpha(), e.setClearColor(this.clearColor, this.clearAlpha)), e.setRenderTarget(this.renderToScreen ? null : i), e.clear(), this.clearColor && e.setClearColor(a, o)
        }
    });
    var mb, gb, vb,
        yb = "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        _b = "#define GLSLIFY 1\n// first inspiration\n// @see https://simonharris.co/2018/06/10/making-a-noise-film-grain-post-processing-effect-from-scratch-in-threejs/\n\nuniform float uAmount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n// @see https://thebookofshaders.com/10/\nfloat random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// @see https://github.com/jamieowen/glsl-blend/blob/master/overlay.glsl\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvoid main () {\n  vec4 color = texture2D( tDiffuse, vUv );\n  float rnd = random(vUv * uAmount);\n  vec3 blend = vec3(rnd * .5);\n  vec3 base = vec3(color.rgb);\n  vec3 result = blendOverlay(base, blend, .5);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
        xb = 1, bb = 1, wb = 1.5 * xb, Tb = 1.5 * bb, Sb = 0, Eb = 0;

    function Ab() {
        var e = new cd(wb, Tb);
        (vb = new jd(e, new Gd({color: 16777215}))).rotation.z = fu.degToRad(10);
        var t = (new ju).setFromObject(vb);
        Sb = t.max.y + .5 * bb, Eb = t.min.y - .5 * bb
    }

    var Mb = {
        VIEW_WIDTH: xb, VIEW_HEIGHT: bb, WIDTH: wb, HEIGHT: Tb, get minY() {
            return vb || Ab(), Sb
        }, get maxY() {
            return vb || Ab(), Eb
        }, get camera() {
            return mb || ((mb = new vy(xb / -2, xb / 2, bb / 2, bb / -2, 1, 1e3)).position.z = 1), mb
        }, get scene() {
            return gb || (gb = new Wm, vb || Ab(), gb.add(vb)), gb
        }, get y() {
            return vb || Ab(), vb.position.y
        }, set y(e) {
            vb || Ab(), vb.position.y = e
        }
    }, Pb = [lb, hb, ub, pb, db], Lb = function () {
        function t(e) {
            es(this, t), this.element = e.element, this.numScreens = e.screenElements.length, this.isRunning = !1, this.renderCallback = this.render.bind(this), this.initRenderer(), this.initComposer(), this.initScreenNavigator(e.screenElements)
        }

        return is(t, [{
            key: "initRenderer", value: function () {
                this.renderer = new jm({
                    antialias: !1, canvas: this.element.querySelector(".home__background")
                }), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.setClearColor(67084), this.renderer.autoClear = !1
            }
        }, {
            key: "initComposer", value: function () {
                var e = {minFilter: lc, magFilter: lc, format: Sc, stencilBuffer: !0},
                    t = new Bu(window.innerWidth, window.innerHeight, e);
                this.composer = new Xx(this.renderer, t), this.currentScreenRenderPass = new Wx, this.currentScreenRenderPass.clear = !1, this.currentScreenRenderPass.enabled = !1, this.currentScreenMaskPass = new jx(Mb.scene, Mb.camera), this.currentScreenMaskPass.enabled = !1, this.previousScreenMaskPass = new jx(Mb.scene, Mb.camera), this.previousScreenMaskPass.enabled = !1, this.previousScreenMaskPass.inverse = !0, this.clearMaskPass = new Vx, this.clearMaskPass.enabled = !1, this.previousScreenRenderPass = new Wx, this.previousScreenRenderPass.clear = !1, this.previousScreenRenderPass.enabled = !1;
                var i = new Gx(Yx), n = new Gx(Bx);
                n.renderToScreen = !0;
                var r = new fb;
                this.noiseCounter = 0;
                var a = {
                    uniforms: {tDiffuse: {value: null}, uAmount: {value: this.noiseCounter}},
                    vertexShader: yb,
                    fragmentShader: _b
                };
                this.noisePass = new Gx(a), this.composer.addPass(r), this.composer.addPass(this.currentScreenMaskPass), this.composer.addPass(this.currentScreenRenderPass), this.composer.addPass(this.clearMaskPass), this.composer.addPass(this.previousScreenMaskPass), this.composer.addPass(this.previousScreenRenderPass), this.composer.addPass(this.clearMaskPass), this.composer.addPass(i), this.composer.addPass(this.noisePass), this.composer.addPass(n)
            }
        }, {
            key: "initScreenNavigator", value: function (e) {
                this.screenNavigator = new ws, this.screenNavigator.transitionType = xs.OutAndIn, this.screenNavigator.on("transitionStart", this.onScreenNavigatorTransitionStart.bind(this)), this.screenNavigator.on("transitionComplete", this.onScreenNavigatorTransitionComplete.bind(this));
                for (var t = 0; t < this.numScreens; t++) {
                    var i = Pb[t] || lb, n = e[t].classList.contains("home__screen--light") ? ul : pl,
                        r = new ds(i, {arguments: [{index: t, color: n, owner: this.screenNavigator}]});
                    this.screenNavigator.addScreen(t.toString(), r)
                }
            }
        }, {
            key: "dispose", value: function () {
                this.stop(), this.disposeRenderer(), this.disposeComposer(), this.disposeScreenNavigator(), rb.dispose()
            }
        }, {
            key: "disposeRenderer", value: function () {
                this.renderer.dispose()
            }
        }, {
            key: "disposeComposer", value: function () {
                this.composer.renderer = null, this.composer.renderTarget = null
            }
        }, {
            key: "disposeScreenNavigator", value: function () {
                this.screenNavigator.off("transitionStart"), this.screenNavigator.dispose()
            }
        }, {
            key: "animateIn", value: function () {
                var t = this;
                return new Promise(function (e) {
                    Ss.from(t.element, 1, {opacity: 0, ease: Cs.easeNone, onComplete: e})
                })
            }
        }, {
            key: "start", value: function () {
                this.isRunning || (this.isRunning = !0, Ss.ticker.addEventListener("tick", this.renderCallback))
            }
        }, {
            key: "stop", value: function () {
                this.isRunning && (this.isRunning = !1, Ss.ticker.removeEventListener("tick", this.renderCallback))
            }
        }, {
            key: "render", value: function () {
                this.screenNavigator.currentScreen.render(), this.noiseCounter += .01, this.noisePass.uniforms.uAmount.value = this.noiseCounter, this.composer.render()
            }
        }, {
            key: "resize", value: function () {
                this.screenNavigator.currentScreen.resize(), this.renderer.setSize(window.innerWidth, window.innerHeight)
            }
        }, {
            key: "showScreen", value: function (e) {
                this.start(), this.screenNavigator.showScreen(e.toString())
            }
        }, {
            key: "onScreenNavigatorTransitionStart", value: function () {
                var e = this.screenNavigator.currentScreen, t = this.screenNavigator.previousScreen;
                if (this.currentScreenRenderPass.scene = e.scene, this.currentScreenRenderPass.camera = e.camera, this.currentScreenRenderPass.enabled = !0, t) {
                    var i = t.index < e.index ? 1 : -1;
                    this.previousScreenRenderPass.scene = t.scene, this.previousScreenRenderPass.camera = t.camera, this.previousScreenRenderPass.enabled = !0, this.currentScreenMaskPass.enabled = !0, this.previousScreenMaskPass.enabled = !0, this.clearMaskPass.enabled = !0, Ss.fromTo(Mb, 2, {y: 1 === i ? Mb.maxY : Mb.minY}, {
                        y: 0, ease: Os.easeInOut
                    })
                }
            }
        }, {
            key: "onScreenNavigatorTransitionComplete", value: function () {
                this.previousScreenRenderPass.enabled = !1, this.currentScreenMaskPass.enabled = !1, this.previousScreenMaskPass.enabled = !1, this.clearMaskPass.enabled = !1
            }
        }]), t
    }(), Cb = Ws("transform"), Ib = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).element = e.parentElement.querySelector(".home__pagination"), t.textElement = t.element.querySelector(".home__pagination__text"), t.textCurrentElement = t.element.querySelector(".home__pagination__text__current"), t.barElement = t.element.querySelector(".home__pagination__bar"), t.progressElement = t.element.querySelector(".home__pagination__bar__progress"), t.itemElements = t.element.querySelectorAll(".home__pagination__item"), t.currentIndex = 1, t.total = e.total, t.isVisible = !1, t.timeline = null, t.progressTween = null, t.initDraggable(), t.initRollOver(), t
        }

        return ns(i, ps), is(i, [{
            key: "initDraggable", value: function () {
                this.isDraggable = !app.isMobile, this.isDraggable && (this.isDragging = !1, this.mouseDownCallback = this.onMouseDown.bind(this), this.mouseMoveCallback = this.onMouseMove.bind(this), this.mouseUpCallback = this.onMouseUp.bind(this), this.frameCallback = this.onFrame.bind(this), this.mouseY = 0, this.barY = 0, this.barHeight = 0, this.progressY = 0, this.oldProgressY = 0, this.barElement.addEventListener("mousedown", this.mouseDownCallback), this.resizeDraggable())
            }
        }, {
            key: "initRollOver", value: function () {
                this.isHovered = !1, this.hoveredIndex = -1, this.rollOverCallback = this.onRollOver.bind(this), this.rollOutCallback = this.onRollOut.bind(this), this.hoverElement = this.element.querySelector(".home__pagination__bar__hover"), this.barElement.addEventListener("mouseenter", this.rollOverCallback), this.barElement.addEventListener("mouseleave", this.rollOutCallback)
            }
        }, {
            key: "dispose", value: function () {
                this.disposeTimeline(), this.disposeDraggable(), this.disposeRollOver()
            }
        }, {
            key: "disposeTimeline", value: function () {
                this.timeline && (this.timeline.kill(), Ds(this.timeline), this.timeline = null)
            }
        }, {
            key: "disposeDraggable", value: function () {
                this.isDraggable && (this.stopDrag(), this.removeMouseListeners(), this.barElement.removeEventListener("mousedown", this.mouseDownCallback))
            }
        }, {
            key: "disposeRollOver", value: function () {
                this.removeMouseListeners(), this.barElement.removeEventListener("mouseenter", this.rollOverCallback), this.barElement.removeEventListener("mouseleave", this.rollOutCallback)
            }
        }, {
            key: "resize", value: function () {
                this.resizeDraggable()
            }
        }, {
            key: "resizeDraggable", value: function () {
                if (this.isDraggable) {
                    var e = this.barElement.getBoundingClientRect();
                    this.barY = e.y, this.barHeight = e.height
                }
            }
        }, {
            key: "show", value: function () {
                this.isVisible || (this.isVisible = !0, this.animateIn())
            }
        }, {
            key: "hide", value: function () {
                this.isVisible && (this.isVisible = !1, this.animateOut())
            }
        }, {
            key: "animateIn", value: function () {
                var e = this.currentIndex / this.total;
                this.disposeTimeline(), this.timeline = new Us({onComplete: this.onTimelineComplete.bind(this)}).from(this.barElement, .9, {
                    scaleY: 0, yPercent: 100, ease: Fs.easeInOut
                }, 0).fromTo(this.progressElement, .9, {scaleY: 0, yPercent: 100}, {
                    scaleY: 1, yPercent: 0, data: {clear: !1}, ease: Fs.easeInOut
                }, "-=.4").to(this.progressElement, .8, {
                    scaleY: e, ease: Fs.easeInOut, data: {clear: !1}
                }).addLabel("text", "-=.8").fromTo(this.textElement, 1, {yPercent: 50}, {
                    yPercent: 100 * e, ease: Fs.easeInOut, data: {clear: !1}
                }, "text").fromTo(this.textElement, 1, {opacity: 0}, {
                    opacity: 1, ease: Fs.easeInOut
                }, "text").set(this.textElement, {transition: "none"}, 0)
            }
        }, {
            key: "animateOut", value: function () {
                this.timeline = new Us({onComplete: this.onTimelineComplete.bind(this)}).to(this.textElement, .5, {
                    opacity: 0, yPercent: 50, ease: Fs.easeInOut
                }, 0).to(this.progressElement, .5, {
                    scaleY: 0, yPercent: 100, ease: Fs.easeInOut
                }, 0).to(this.barElement, .9, {scaleY: 0, yPercent: 100, ease: Fs.easeInOut}, "-=.3")
            }
        }, {
            key: "setCurrentIndex", value: function (e) {
                if (this.currentIndex !== e) {
                    var t = e / this.total;
                    this.currentIndex = e, this.textCurrentElement.textContent = "0" + e, this.isVisible && !this.timeline && (Ss.to(this.textElement, .7, {
                        yPercent: 100 * t, ease: Fs.easeInOut
                    }), this.isDragging || (this.progressTween = Ss.to(this.progressElement, .7, {
                        scaleY: t, ease: Fs.easeInOut
                    })), this.emit("change", {index: e}))
                }
            }
        }, {
            key: "startDrag", value: function () {
                this.isDragging || (this.isDragging = !0, window.addEventListener("mouseup", this.mouseUpCallback))
            }
        }, {
            key: "stopDrag", value: function () {
                this.isDragging && (this.isDragging = !1, this.isHovered || this.removeMouseListeners(), window.removeEventListener("mouseup", this.mouseUpCallback))
            }
        }, {
            key: "updateDraggable", value: function () {
                var e = (this.mouseY - this.barY) / this.barHeight;
                1 < e ? e = 1 : e < 0 && (e = 0);
                var t = Math.round(e / .25);
                t < 1 && (t = 1), this.progressTween && (this.progressTween.kill(), this.progressTween = null), this.oldProgressY = this.progressY, this.progressY = e;
                var i = Math.abs(this.progressY - this.oldProgressY);
                this.progressElement.style[Cb] = "scaleY(".concat(e, ")"), t !== this.currentIndex && i < .01 && this.setCurrentIndex(t)
            }
        }, {
            key: "updateRollOver", value: function () {
                if (!this.timeline && this.isHovered) {
                    var e = (this.mouseY - this.barY) / this.barHeight;
                    1 < e ? e = 1 : e < 0 && (e = 0);
                    var t = Math.round(e / .25);
                    if (t < 1 && (t = 1), t !== this.hoveredIndex) {
                        var i = this.hoveredIndex;
                        this.hoveredIndex = t, Ss.to(this.hoverElement, .4, {scaleY: this.hoveredIndex * (1 / this.total)}), -1 !== i && Ss.to(this.itemElements[i], .4, {opacity: .3}), Ss.to(this.itemElements[this.hoveredIndex], .4, {opacity: 1})
                    }
                }
            }
        }, {
            key: "addMouseListeners", value: function () {
                window.addEventListener("mousemove", this.mouseMoveCallback), Ss.ticker.addEventListener("tick", this.frameCallback)
            }
        }, {
            key: "removeMouseListeners", value: function () {
                window.removeEventListener("mousemove", this.mouseMoveCallback), Ss.ticker.removeEventListener("tick", this.frameCallback)
            }
        }, {
            key: "onTimelineComplete", value: function () {
                this.disposeTimeline()
            }
        }, {
            key: "onMouseDown", value: function (e) {
                this.timeline || (this.mouseY = e.clientY, this.startDrag())
            }
        }, {
            key: "onMouseMove", value: function (e) {
                this.mouseY = e.clientY
            }
        }, {
            key: "onMouseUp", value: function (e) {
                this.stopDrag(), this.progressTween = Ss.fromTo(this.progressElement, .7, {scaleY: this.progressY}, {
                    scaleY: this.currentIndex / this.total, ease: Fs.easeInOut
                })
            }
        }, {
            key: "onRollOver", value: function (e) {
                this.mouseY = e.clientY, this.isHovered = !0, this.addMouseListeners()
            }
        }, {
            key: "onRollOut", value: function () {
                this.isHovered = !1, Ss.to(this.hoverElement, .4, {scaleY: this.currentIndex * (1 / this.total)}), Ss.to(this.itemElements[this.hoveredIndex], .4, {opacity: .3}), this.hoveredIndex = -1, this.isDragging || this.removeMouseListeners()
            }
        }, {
            key: "onFrame", value: function () {
                this.isDragging && this.updateDraggable(), this.isHovered && this.updateRollOver()
            }
        }]), i
    }(), Rb = function () {
        function i(e) {
            es(this, i), this.foregroundColor = e.color, this.element = e.element;
            var t = window.getComputedStyle(this.element).getPropertyValue("color").split("rgb(").join("").split(")").join("");
            this.backgroundColor = t.split(",").map(function (e) {
                return parseInt(e)
            }), this.isRunning = !1, this.pointerX = this.smoothPointerX = 0, this.pointerY = this.smoothPointerY = 0, this.frameCallback = this.onFrame.bind(this), this.mouseMoveCallback = this.onMouseMove.bind(this), this.touchCallback = this.onTouch.bind(this), this.charPositions = [], this.charColors = [], this.initChars()
        }

        return is(i, [{
            key: "initChars", value: function () {
                this.splitText = new Bs(this.element), this.numChars = this.splitText.chars.length;
                for (var e = 0; e < this.numChars; e++) {
                    var t = this.splitText.chars[e].getBoundingClientRect(), i = [];
                    i[0] = t.x, i[1] = window.pageYOffset + t.y, this.charPositions[e] = i
                }
            }
        }, {
            key: "dispose", value: function () {
                this.pause()
            }
        }, {
            key: "resize", value: function () {
                var e = this.isRunning;
                this.pause(), this.splitText && this.splitText.revert(), this.initChars(), e && this.start()
            }
        }, {
            key: "start", value: function () {
                this.isRunning || (this.isRunning = !0, Ss.ticker.addEventListener("tick", this.frameCallback), window.addEventListener("mousemove", this.mouseMoveCallback), app.hasTouch && (window.addEventListener("touchstart", this.touchCallback), window.addEventListener("touchmove", this.touchCallback)))
            }
        }, {
            key: "pause", value: function () {
                this.isRunning && (this.isRunning = !1, Ss.ticker.removeEventListener("tick", this.frameCallback), window.removeEventListener("mousemove", this.mouseMoveCallback), app.hasTouch && (window.removeEventListener("touchstart", this.touchCallback), window.removeEventListener("touchmove", this.touchCallback)))
            }
        }, {
            key: "onFrame", value: function () {
                this.smoothPointerX += .08 * (this.pointerX - this.smoothPointerX), this.smoothPointerY += .08 * (this.pointerY - this.smoothPointerY);
                for (var e = 0; e < this.numChars; e++) {
                    var t = this.splitText.chars[e], i = this.charPositions[e], n = this.smoothPointerX - i[0],
                        r = this.smoothPointerY - i[1], a = (150 - Math.sqrt(n * n + r * r)) / 150;
                    a < 0 && (a = 0);
                    var o = [this.backgroundColor[0] * (1 - a) + this.foregroundColor[0] * a, this.backgroundColor[1] * (1 - a) + this.foregroundColor[1] * a, this.backgroundColor[2] * (1 - a) + this.foregroundColor[2] * a];
                    this.charColors[e] && this.charColors[e][0] === o[0] && this.charColors[e][1] === o[1] && this.charColors[e][2] === o[2] || (this.charColors[e] = o, t.style.color = "rgb(" + o[0] + "," + o[1] + "," + o[2] + ")")
                }
            }
        }, {
            key: "onMouseMove", value: function (e) {
                this.pointerX = e.pageX, this.pointerY = e.pageY
            }
        }, {
            key: "onTouch", value: function (e) {
                this.pointerX = e.touches[0].pageX, this.pointerY = e.touches[0].pageY
            }
        }]), i
    }(), Ob = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).element = e.element, t.onClickCallback = t.onClick.bind(ss(ss(t))), t.element.addEventListener("touchstart", t.onClickCallback), t.element.addEventListener("click", t.onClickCallback), t
        }

        return ns(i, ps), is(i, [{
            key: "dispose", value: function () {
                this.element.removeEventListener("touchstart", this.onClickCallback), this.element.removeEventListener("click", this.onClickCallback)
            }
        }, {
            key: "onClick", value: function () {
                this.emit("click")
            }
        }]), i
    }(), Fb = e(function (Ve) {
        !function (a, s, e, m) {
            var o, l = ["", "webkit", "Moz", "MS", "ms", "o"], t = s.createElement("div"), i = "function",
                h = Math.round, g = Math.abs, v = Date.now;

            function c(e, t, i) {
                return setTimeout(y(e, i), t)
            }

            function n(e, t, i) {
                return !!Array.isArray(e) && (u(e, i[t], i), !0)
            }

            function u(e, t, i) {
                var n;
                if (e) if (e.forEach) e.forEach(t, i); else if (e.length !== m) for (n = 0; n < e.length;) t.call(i, e[n], n, e), n++; else for (n in e) e.hasOwnProperty(n) && t.call(i, e[n], n, e)
            }

            function r(n, e, t) {
                var r = "DEPRECATED METHOD: " + e + "\n" + t + " AT \n";
                return function () {
                    var e = new Error("get-stack-trace"),
                        t = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                        i = a.console && (a.console.warn || a.console.log);
                    return i && i.call(a.console, r, t), n.apply(this, arguments)
                }
            }

            o = "function" != typeof Object.assign ? function (e) {
                if (e === m || null === e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), i = 1; i < arguments.length; i++) {
                    var n = arguments[i];
                    if (n !== m && null !== n) for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r])
                }
                return t
            } : Object.assign;
            var p = r(function (e, t, i) {
                for (var n = Object.keys(t), r = 0; r < n.length;) (!i || i && e[n[r]] === m) && (e[n[r]] = t[n[r]]), r++;
                return e
            }, "extend", "Use `assign`."), d = r(function (e, t) {
                return p(e, t, !0)
            }, "merge", "Use `assign`.");

            function f(e, t, i) {
                var n, r = t.prototype;
                (n = e.prototype = Object.create(r)).constructor = e, n._super = r, i && o(n, i)
            }

            function y(e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            }

            function _(e, t) {
                return typeof e == i ? e.apply(t && t[0] || m, t) : e
            }

            function x(e, t) {
                return e === m ? t : e
            }

            function b(t, e, i) {
                u(E(e), function (e) {
                    t.addEventListener(e, i, !1)
                })
            }

            function w(t, e, i) {
                u(E(e), function (e) {
                    t.removeEventListener(e, i, !1)
                })
            }

            function T(e, t) {
                for (; e;) {
                    if (e == t) return !0;
                    e = e.parentNode
                }
                return !1
            }

            function S(e, t) {
                return -1 < e.indexOf(t)
            }

            function E(e) {
                return e.trim().split(/\s+/g)
            }

            function A(e, t, i) {
                if (e.indexOf && !i) return e.indexOf(t);
                for (var n = 0; n < e.length;) {
                    if (i && e[n][i] == t || !i && e[n] === t) return n;
                    n++
                }
                return -1
            }

            function M(e) {
                return Array.prototype.slice.call(e, 0)
            }

            function P(e, i, t) {
                for (var n = [], r = [], a = 0; a < e.length;) {
                    var o = i ? e[a][i] : e[a];
                    A(r, o) < 0 && n.push(e[a]), r[a] = o, a++
                }
                return t && (n = i ? n.sort(function (e, t) {
                    return e[i] > t[i]
                }) : n.sort()), n
            }

            function L(e, t) {
                for (var i, n, r = t[0].toUpperCase() + t.slice(1), a = 0; a < l.length;) {
                    if ((n = (i = l[a]) ? i + r : t) in e) return n;
                    a++
                }
                return m
            }

            var C = 1;

            function I(e) {
                var t = e.ownerDocument || e;
                return t.defaultView || t.parentWindow || a
            }

            var R = "ontouchstart" in a, O = L(a, "PointerEvent") !== m,
                F = R && /mobile|tablet|ip(ad|hone|od)|android/i.test(navigator.userAgent), N = "touch", k = 25, U = 1,
                D = 4, z = 8, B = 1, H = 2, G = 4, j = 8, V = 16, X = H | G, W = j | V, Y = X | W, q = ["x", "y"],
                Q = ["clientX", "clientY"];

            function Z(t, e) {
                var i = this;
                this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) {
                    _(t.options.enable, [t]) && i.handler(e)
                }, this.init()
            }

            function J(e, t, i) {
                var n = i.pointers.length, r = i.changedPointers.length, a = t & U && n - r == 0,
                    o = t & (D | z) && n - r == 0;
                i.isFirst = !!a, i.isFinal = !!o, a && (e.session = {}), i.eventType = t, function (e, t) {
                    var i = e.session, n = t.pointers, r = n.length;
                    i.firstInput || (i.firstInput = K(t));
                    1 < r && !i.firstMultiple ? i.firstMultiple = K(t) : 1 === r && (i.firstMultiple = !1);
                    var a = i.firstInput, o = i.firstMultiple, s = o ? o.center : a.center, l = t.center = $(n);
                    t.timeStamp = v(), t.deltaTime = t.timeStamp - a.timeStamp, t.angle = ne(s, l), t.distance = ie(s, l), function (e, t) {
                        var i = t.center, n = e.offsetDelta || {}, r = e.prevDelta || {}, a = e.prevInput || {};
                        t.eventType !== U && a.eventType !== D || (r = e.prevDelta = {
                            x: a.deltaX || 0, y: a.deltaY || 0
                        }, n = e.offsetDelta = {x: i.x, y: i.y});
                        t.deltaX = r.x + (i.x - n.x), t.deltaY = r.y + (i.y - n.y)
                    }(i, t), t.offsetDirection = te(t.deltaX, t.deltaY);
                    var h = ee(t.deltaTime, t.deltaX, t.deltaY);
                    t.overallVelocityX = h.x, t.overallVelocityY = h.y, t.overallVelocity = g(h.x) > g(h.y) ? h.x : h.y, t.scale = o ? (p = o.pointers, d = n, ie(d[0], d[1], Q) / ie(p[0], p[1], Q)) : 1, t.rotation = o ? (c = o.pointers, u = n, ne(u[1], u[0], Q) + ne(c[1], c[0], Q)) : 0, t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length, function (e, t) {
                        var i, n, r, a, o = e.lastInterval || t, s = t.timeStamp - o.timeStamp;
                        if (t.eventType != z && (k < s || o.velocity === m)) {
                            var l = t.deltaX - o.deltaX, h = t.deltaY - o.deltaY, c = ee(s, l, h);
                            n = c.x, r = c.y, i = g(c.x) > g(c.y) ? c.x : c.y, a = te(l, h), e.lastInterval = t
                        } else i = o.velocity, n = o.velocityX, r = o.velocityY, a = o.direction;
                        t.velocity = i, t.velocityX = n, t.velocityY = r, t.direction = a
                    }(i, t);
                    var c, u;
                    var p, d;
                    var f = e.element;
                    T(t.srcEvent.target, f) && (f = t.srcEvent.target);
                    t.target = f
                }(e, i), e.emit("hammer.input", i), e.recognize(i), e.session.prevInput = i
            }

            function K(e) {
                for (var t = [], i = 0; i < e.pointers.length;) t[i] = {
                    clientX: h(e.pointers[i].clientX), clientY: h(e.pointers[i].clientY)
                }, i++;
                return {timeStamp: v(), pointers: t, center: $(t), deltaX: e.deltaX, deltaY: e.deltaY}
            }

            function $(e) {
                var t = e.length;
                if (1 === t) return {x: h(e[0].clientX), y: h(e[0].clientY)};
                for (var i = 0, n = 0, r = 0; r < t;) i += e[r].clientX, n += e[r].clientY, r++;
                return {x: h(i / t), y: h(n / t)}
            }

            function ee(e, t, i) {
                return {x: t / e || 0, y: i / e || 0}
            }

            function te(e, t) {
                return e === t ? B : g(e) >= g(t) ? e < 0 ? H : G : t < 0 ? j : V
            }

            function ie(e, t, i) {
                i || (i = q);
                var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
                return Math.sqrt(n * n + r * r)
            }

            function ne(e, t, i) {
                i || (i = q);
                var n = t[i[0]] - e[i[0]], r = t[i[1]] - e[i[1]];
                return 180 * Math.atan2(r, n) / Math.PI
            }

            Z.prototype = {
                handler: function () {
                }, init: function () {
                    this.evEl && b(this.element, this.evEl, this.domHandler), this.evTarget && b(this.target, this.evTarget, this.domHandler), this.evWin && b(I(this.element), this.evWin, this.domHandler)
                }, destroy: function () {
                    this.evEl && w(this.element, this.evEl, this.domHandler), this.evTarget && w(this.target, this.evTarget, this.domHandler), this.evWin && w(I(this.element), this.evWin, this.domHandler)
                }
            };
            var re = {mousedown: U, mousemove: 2, mouseup: D}, ae = "mousedown", oe = "mousemove mouseup";

            function se() {
                this.evEl = ae, this.evWin = oe, this.pressed = !1, Z.apply(this, arguments)
            }

            f(se, Z, {
                handler: function (e) {
                    var t = re[e.type];
                    t & U && 0 === e.button && (this.pressed = !0), 2 & t && 1 !== e.which && (t = D), this.pressed && (t & D && (this.pressed = !1), this.callback(this.manager, t, {
                        pointers: [e], changedPointers: [e], pointerType: "mouse", srcEvent: e
                    }))
                }
            });
            var le = {pointerdown: U, pointermove: 2, pointerup: D, pointercancel: z, pointerout: z},
                he = {2: N, 3: "pen", 4: "mouse", 5: "kinect"}, ce = "pointerdown",
                ue = "pointermove pointerup pointercancel";

            function pe() {
                this.evEl = ce, this.evWin = ue, Z.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
            }

            a.MSPointerEvent && !a.PointerEvent && (ce = "MSPointerDown", ue = "MSPointerMove MSPointerUp MSPointerCancel"), f(pe, Z, {
                handler: function (e) {
                    var t = this.store, i = !1, n = e.type.toLowerCase().replace("ms", ""), r = le[n],
                        a = he[e.pointerType] || e.pointerType, o = a == N, s = A(t, e.pointerId, "pointerId");
                    r & U && (0 === e.button || o) ? s < 0 && (t.push(e), s = t.length - 1) : r & (D | z) && (i = !0), s < 0 || (t[s] = e, this.callback(this.manager, r, {
                        pointers: t, changedPointers: [e], pointerType: a, srcEvent: e
                    }), i && t.splice(s, 1))
                }
            });
            var de = {touchstart: U, touchmove: 2, touchend: D, touchcancel: z};

            function fe() {
                this.evTarget = "touchstart", this.evWin = "touchstart touchmove touchend touchcancel", this.started = !1, Z.apply(this, arguments)
            }

            f(fe, Z, {
                handler: function (e) {
                    var t = de[e.type];
                    if (t === U && (this.started = !0), this.started) {
                        var i = function (e, t) {
                            var i = M(e.touches), n = M(e.changedTouches);
                            t & (D | z) && (i = P(i.concat(n), "identifier", !0));
                            return [i, n]
                        }.call(this, e, t);
                        t & (D | z) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, t, {
                            pointers: i[0], changedPointers: i[1], pointerType: N, srcEvent: e
                        })
                    }
                }
            });
            var me = {touchstart: U, touchmove: 2, touchend: D, touchcancel: z},
                ge = "touchstart touchmove touchend touchcancel";

            function ve() {
                this.evTarget = ge, this.targetIds = {}, Z.apply(this, arguments)
            }

            f(ve, Z, {
                handler: function (e) {
                    var t = me[e.type], i = function (e, t) {
                        var i = M(e.touches), n = this.targetIds;
                        if (t & (2 | U) && 1 === i.length) return n[i[0].identifier] = !0, [i, i];
                        var r, a, o = M(e.changedTouches), s = [], l = this.target;
                        if (a = i.filter(function (e) {
                            return T(e.target, l)
                        }), t === U) for (r = 0; r < a.length;) n[a[r].identifier] = !0, r++;
                        r = 0;
                        for (; r < o.length;) n[o[r].identifier] && s.push(o[r]), t & (D | z) && delete n[o[r].identifier], r++;
                        return s.length ? [P(a.concat(s), "identifier", !0), s] : void 0
                    }.call(this, e, t);
                    i && this.callback(this.manager, t, {
                        pointers: i[0], changedPointers: i[1], pointerType: N, srcEvent: e
                    })
                }
            });
            var ye = 2500;

            function _e() {
                Z.apply(this, arguments);
                var e = y(this.handler, this);
                this.touch = new ve(this.manager, e), this.mouse = new se(this.manager, e), this.primaryTouch = null, this.lastTouches = []
            }

            function xe(e) {
                var t = e.changedPointers[0];
                if (t.identifier === this.primaryTouch) {
                    var i = {x: t.clientX, y: t.clientY};
                    this.lastTouches.push(i);
                    var n = this.lastTouches;
                    setTimeout(function () {
                        var e = n.indexOf(i);
                        -1 < e && n.splice(e, 1)
                    }, ye)
                }
            }

            f(_e, Z, {
                handler: function (e, t, i) {
                    var n = i.pointerType == N, r = "mouse" == i.pointerType;
                    if (!(r && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) {
                        if (n) (function (e, t) {
                            e & U ? (this.primaryTouch = t.changedPointers[0].identifier, xe.call(this, t)) : e & (D | z) && xe.call(this, t)
                        }).call(this, t, i); else if (r && function (e) {
                            for (var t = e.srcEvent.clientX, i = e.srcEvent.clientY, n = 0; n < this.lastTouches.length; n++) {
                                var r = this.lastTouches[n], a = Math.abs(t - r.x), o = Math.abs(i - r.y);
                                if (a <= 25 && o <= 25) return !0
                            }
                            return !1
                        }.call(this, i)) return;
                        this.callback(e, t, i)
                    }
                }, destroy: function () {
                    this.touch.destroy(), this.mouse.destroy()
                }
            });
            var be = L(t.style, "touchAction"), we = be !== m, Te = "manipulation", Se = "none", Ee = "pan-x",
                Ae = "pan-y", Me = function () {
                    if (!we) return !1;
                    var t = {}, i = a.CSS && a.CSS.supports;
                    return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (e) {
                        t[e] = !i || a.CSS.supports("touch-action", e)
                    }), t
                }();

            function Pe(e, t) {
                this.manager = e, this.set(t)
            }

            Pe.prototype = {
                set: function (e) {
                    "compute" == e && (e = this.compute()), we && this.manager.element.style && Me[e] && (this.manager.element.style[be] = e), this.actions = e.toLowerCase().trim()
                }, update: function () {
                    this.set(this.manager.options.touchAction)
                }, compute: function () {
                    var t = [];
                    return u(this.manager.recognizers, function (e) {
                        _(e.options.enable, [e]) && (t = t.concat(e.getTouchAction()))
                    }), function (e) {
                        if (S(e, Se)) return Se;
                        var t = S(e, Ee), i = S(e, Ae);
                        if (t && i) return Se;
                        if (t || i) return t ? Ee : Ae;
                        if (S(e, Te)) return Te;
                        return "auto"
                    }(t.join(" "))
                }, preventDefaults: function (e) {
                    var t = e.srcEvent, i = e.offsetDirection;
                    if (this.manager.session.prevented) t.preventDefault(); else {
                        var n = this.actions, r = S(n, Se) && !Me.none, a = S(n, Ae) && !Me[Ae],
                            o = S(n, Ee) && !Me[Ee];
                        if (r) {
                            var s = 1 === e.pointers.length, l = e.distance < 2, h = e.deltaTime < 250;
                            if (s && l && h) return
                        }
                        if (!o || !a) return r || a && i & X || o && i & W ? this.preventSrc(t) : void 0
                    }
                }, preventSrc: function (e) {
                    this.manager.session.prevented = !0, e.preventDefault()
                }
            };
            var Le = 1;

            function Ce(e) {
                this.options = o({}, this.defaults, e || {}), this.id = C++, this.manager = null, this.options.enable = x(this.options.enable, !0), this.state = Le, this.simultaneous = {}, this.requireFail = []
            }

            function Ie(e) {
                return 16 & e ? "cancel" : 8 & e ? "end" : 4 & e ? "move" : 2 & e ? "start" : ""
            }

            function Re(e) {
                return e == V ? "down" : e == j ? "up" : e == H ? "left" : e == G ? "right" : ""
            }

            function Oe(e, t) {
                var i = t.manager;
                return i ? i.get(e) : e
            }

            function Fe() {
                Ce.apply(this, arguments)
            }

            function Ne() {
                Fe.apply(this, arguments), this.pX = null, this.pY = null
            }

            function ke() {
                Fe.apply(this, arguments)
            }

            function Ue() {
                Ce.apply(this, arguments), this._timer = null, this._input = null
            }

            function De() {
                Fe.apply(this, arguments)
            }

            function ze() {
                Fe.apply(this, arguments)
            }

            function Be() {
                Ce.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
            }

            function He(e, t) {
                return (t = t || {}).recognizers = x(t.recognizers, He.defaults.preset), new Ge(e, t)
            }

            Ce.prototype = {
                defaults: {}, set: function (e) {
                    return o(this.options, e), this.manager && this.manager.touchAction.update(), this
                }, recognizeWith: function (e) {
                    if (n(e, "recognizeWith", this)) return this;
                    var t = this.simultaneous;
                    return t[(e = Oe(e, this)).id] || (t[e.id] = e).recognizeWith(this), this
                }, dropRecognizeWith: function (e) {
                    return n(e, "dropRecognizeWith", this) || (e = Oe(e, this), delete this.simultaneous[e.id]), this
                }, requireFailure: function (e) {
                    if (n(e, "requireFailure", this)) return this;
                    var t = this.requireFail;
                    return -1 === A(t, e = Oe(e, this)) && (t.push(e), e.requireFailure(this)), this
                }, dropRequireFailure: function (e) {
                    if (n(e, "dropRequireFailure", this)) return this;
                    e = Oe(e, this);
                    var t = A(this.requireFail, e);
                    return -1 < t && this.requireFail.splice(t, 1), this
                }, hasRequireFailures: function () {
                    return 0 < this.requireFail.length
                }, canRecognizeWith: function (e) {
                    return !!this.simultaneous[e.id]
                }, emit: function (t) {
                    var i = this, e = this.state;

                    function n(e) {
                        i.manager.emit(e, t)
                    }

                    e < 8 && n(i.options.event + Ie(e)), n(i.options.event), t.additionalEvent && n(t.additionalEvent), 8 <= e && n(i.options.event + Ie(e))
                }, tryEmit: function (e) {
                    if (this.canEmit()) return this.emit(e);
                    this.state = 32
                }, canEmit: function () {
                    for (var e = 0; e < this.requireFail.length;) {
                        if (!(this.requireFail[e].state & (32 | Le))) return !1;
                        e++
                    }
                    return !0
                }, recognize: function (e) {
                    var t = o({}, e);
                    if (!_(this.options.enable, [this, t])) return this.reset(), void (this.state = 32);
                    56 & this.state && (this.state = Le), this.state = this.process(t), 30 & this.state && this.tryEmit(t)
                }, process: function (e) {
                }, getTouchAction: function () {
                }, reset: function () {
                }
            }, f(Fe, Ce, {
                defaults: {pointers: 1}, attrTest: function (e) {
                    var t = this.options.pointers;
                    return 0 === t || e.pointers.length === t
                }, process: function (e) {
                    var t = this.state, i = e.eventType, n = 6 & t, r = this.attrTest(e);
                    return n && (i & z || !r) ? 16 | t : n || r ? i & D ? 8 | t : 2 & t ? 4 | t : 2 : 32
                }
            }), f(Ne, Fe, {
                defaults: {event: "pan", threshold: 10, pointers: 1, direction: Y}, getTouchAction: function () {
                    var e = this.options.direction, t = [];
                    return e & X && t.push(Ae), e & W && t.push(Ee), t
                }, directionTest: function (e) {
                    var t = this.options, i = !0, n = e.distance, r = e.direction, a = e.deltaX, o = e.deltaY;
                    return r & t.direction || (n = t.direction & X ? (r = 0 === a ? B : a < 0 ? H : G, i = a != this.pX, Math.abs(e.deltaX)) : (r = 0 === o ? B : o < 0 ? j : V, i = o != this.pY, Math.abs(e.deltaY))), e.direction = r, i && n > t.threshold && r & t.direction
                }, attrTest: function (e) {
                    return Fe.prototype.attrTest.call(this, e) && (2 & this.state || !(2 & this.state) && this.directionTest(e))
                }, emit: function (e) {
                    this.pX = e.deltaX, this.pY = e.deltaY;
                    var t = Re(e.direction);
                    t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e)
                }
            }), f(ke, Fe, {
                defaults: {event: "pinch", threshold: 0, pointers: 2}, getTouchAction: function () {
                    return [Se]
                }, attrTest: function (e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || 2 & this.state)
                }, emit: function (e) {
                    if (1 !== e.scale) {
                        var t = e.scale < 1 ? "in" : "out";
                        e.additionalEvent = this.options.event + t
                    }
                    this._super.emit.call(this, e)
                }
            }), f(Ue, Ce, {
                defaults: {event: "press", pointers: 1, time: 251, threshold: 9}, getTouchAction: function () {
                    return ["auto"]
                }, process: function (e) {
                    var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold,
                        r = e.deltaTime > t.time;
                    if (this._input = e, !n || !i || e.eventType & (D | z) && !r) this.reset(); else if (e.eventType & U) this.reset(), this._timer = c(function () {
                        this.state = 8, this.tryEmit()
                    }, t.time, this); else if (e.eventType & D) return 8;
                    return 32
                }, reset: function () {
                    clearTimeout(this._timer)
                }, emit: function (e) {
                    8 === this.state && (e && e.eventType & D ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = v(), this.manager.emit(this.options.event, this._input)))
                }
            }), f(De, Fe, {
                defaults: {event: "rotate", threshold: 0, pointers: 2}, getTouchAction: function () {
                    return [Se]
                }, attrTest: function (e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || 2 & this.state)
                }
            }), f(ze, Fe, {
                defaults: {event: "swipe", threshold: 10, velocity: .3, direction: X | W, pointers: 1},
                getTouchAction: function () {
                    return Ne.prototype.getTouchAction.call(this)
                },
                attrTest: function (e) {
                    var t, i = this.options.direction;
                    return i & (X | W) ? t = e.overallVelocity : i & X ? t = e.overallVelocityX : i & W && (t = e.overallVelocityY), this._super.attrTest.call(this, e) && i & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && g(t) > this.options.velocity && e.eventType & D
                },
                emit: function (e) {
                    var t = Re(e.offsetDirection);
                    t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e)
                }
            }), f(Be, Ce, {
                defaults: {
                    event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10
                }, getTouchAction: function () {
                    return [Te]
                }, process: function (e) {
                    var t = this.options, i = e.pointers.length === t.pointers, n = e.distance < t.threshold,
                        r = e.deltaTime < t.time;
                    if (this.reset(), e.eventType & U && 0 === this.count) return this.failTimeout();
                    if (n && r && i) {
                        if (e.eventType != D) return this.failTimeout();
                        var a = !this.pTime || e.timeStamp - this.pTime < t.interval,
                            o = !this.pCenter || ie(this.pCenter, e.center) < t.posThreshold;
                        if (this.pTime = e.timeStamp, this.pCenter = e.center, o && a ? this.count += 1 : this.count = 1, this._input = e, 0 === this.count % t.taps) return this.hasRequireFailures() ? (this._timer = c(function () {
                            this.state = 8, this.tryEmit()
                        }, t.interval, this), 2) : 8
                    }
                    return 32
                }, failTimeout: function () {
                    return this._timer = c(function () {
                        this.state = 32
                    }, this.options.interval, this), 32
                }, reset: function () {
                    clearTimeout(this._timer)
                }, emit: function () {
                    8 == this.state && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                }
            }), He.VERSION = "2.0.7", He.defaults = {
                domEvents: !1,
                touchAction: "compute",
                enable: !0,
                inputTarget: null,
                inputClass: null,
                preset: [[De, {enable: !1}], [ke, {enable: !1}, ["rotate"]], [ze, {direction: X}], [Ne, {direction: X}, ["swipe"]], [Be], [Be, {
                    event: "doubletap", taps: 2
                }, ["tap"]], [Ue]],
                cssProps: {
                    userSelect: "none",
                    touchSelect: "none",
                    touchCallout: "none",
                    contentZooming: "none",
                    userDrag: "none",
                    tapHighlightColor: "rgba(0,0,0,0)"
                }
            };

            function Ge(e, t) {
                var i;
                this.options = o({}, He.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new ((i = this).options.inputClass || (O ? pe : F ? ve : R ? _e : se))(i, J), this.touchAction = new Pe(this, this.options.touchAction), je(this, !0), u(this.options.recognizers, function (e) {
                    var t = this.add(new e[0](e[1]));
                    e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3])
                }, this)
            }

            function je(i, n) {
                var r, a = i.element;
                a.style && (u(i.options.cssProps, function (e, t) {
                    r = L(a.style, t), a.style[r] = n ? (i.oldCssProps[r] = a.style[r], e) : i.oldCssProps[r] || ""
                }), n || (i.oldCssProps = {}))
            }

            Ge.prototype = {
                set: function (e) {
                    return o(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this
                }, stop: function (e) {
                    this.session.stopped = e ? 2 : 1
                }, recognize: function (e) {
                    var t = this.session;
                    if (!t.stopped) {
                        var i;
                        this.touchAction.preventDefaults(e);
                        var n = this.recognizers, r = t.curRecognizer;
                        (!r || r && 8 & r.state) && (r = t.curRecognizer = null);
                        for (var a = 0; a < n.length;) i = n[a], 2 === t.stopped || r && i != r && !i.canRecognizeWith(r) ? i.reset() : i.recognize(e), !r && 14 & i.state && (r = t.curRecognizer = i), a++
                    }
                }, get: function (e) {
                    if (e instanceof Ce) return e;
                    for (var t = this.recognizers, i = 0; i < t.length; i++) if (t[i].options.event == e) return t[i];
                    return null
                }, add: function (e) {
                    if (n(e, "add", this)) return this;
                    var t = this.get(e.options.event);
                    return t && this.remove(t), this.recognizers.push(e), (e.manager = this).touchAction.update(), e
                }, remove: function (e) {
                    if (n(e, "remove", this)) return this;
                    if (e = this.get(e)) {
                        var t = this.recognizers, i = A(t, e);
                        -1 !== i && (t.splice(i, 1), this.touchAction.update())
                    }
                    return this
                }, on: function (e, t) {
                    if (e !== m && t !== m) {
                        var i = this.handlers;
                        return u(E(e), function (e) {
                            i[e] = i[e] || [], i[e].push(t)
                        }), this
                    }
                }, off: function (e, t) {
                    if (e !== m) {
                        var i = this.handlers;
                        return u(E(e), function (e) {
                            t ? i[e] && i[e].splice(A(i[e], t), 1) : delete i[e]
                        }), this
                    }
                }, emit: function (e, t) {
                    var i, n, r;
                    this.options.domEvents && (i = e, n = t, (r = s.createEvent("Event")).initEvent(i, !0, !0), (r.gesture = n).target.dispatchEvent(r));
                    var a = this.handlers[e] && this.handlers[e].slice();
                    if (a && a.length) {
                        t.type = e, t.preventDefault = function () {
                            t.srcEvent.preventDefault()
                        };
                        for (var o = 0; o < a.length;) a[o](t), o++
                    }
                }, destroy: function () {
                    this.element && je(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
                }
            }, o(He, {
                INPUT_START: U,
                INPUT_MOVE: 2,
                INPUT_END: D,
                INPUT_CANCEL: z,
                STATE_POSSIBLE: Le,
                STATE_BEGAN: 2,
                STATE_CHANGED: 4,
                STATE_ENDED: 8,
                STATE_RECOGNIZED: 8,
                STATE_CANCELLED: 16,
                STATE_FAILED: 32,
                DIRECTION_NONE: B,
                DIRECTION_LEFT: H,
                DIRECTION_RIGHT: G,
                DIRECTION_UP: j,
                DIRECTION_DOWN: V,
                DIRECTION_HORIZONTAL: X,
                DIRECTION_VERTICAL: W,
                DIRECTION_ALL: Y,
                Manager: Ge,
                Input: Z,
                TouchAction: Pe,
                TouchInput: ve,
                MouseInput: se,
                PointerEventInput: pe,
                TouchMouseInput: _e,
                SingleTouchInput: fe,
                Recognizer: Ce,
                AttrRecognizer: Fe,
                Tap: Be,
                Pan: Ne,
                Swipe: ze,
                Pinch: ke,
                Rotate: De,
                Press: Ue,
                on: b,
                off: w,
                each: u,
                merge: d,
                extend: p,
                assign: o,
                inherit: f,
                bindFn: y,
                prefixed: L
            }), (void 0 !== a ? a : "undefined" != typeof self ? self : {}).Hammer = He, "function" == typeof m && m.amd ? m(function () {
                return He
            }) : Ve.exports ? Ve.exports = He : a.Hammer = He
        }(window, document)
    }), Nb = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).element = e.element, t.owner = e.owner, t.index = e.index, t.isAjaxPage = e.isAjaxPage, t.color = e.color, t.timeline = null, t.titleElement = t.element.querySelector(".home__screen__title"), t.interactiveTitle = null, t.bodyElement = t.element.querySelector(".home__screen__body__text"), t.splitBody = null, t.separatorElement = t.element.querySelector(".home__screen__separator"), t.separatorLineElement = t.separatorElement.querySelector("div:nth-child(2)"), t.logoRectBeforeTransition = null, t.initNextButton(), t.initGesture(), t
        }

        return ns(i, bs), is(i, [{
            key: "initInteractiveTitle", value: function () {
                this.interactiveTitle = new Rb({
                    element: this.titleElement,
                    color: 3 === this.index || 4 === this.index ? [213, 241, 247] : [255, 255, 255]
                })
            }
        }, {
            key: "initSplitBody", value: function () {
                this.splitBody = new SplitText(this.bodyElement, {type: "lines"})
            }
        }, {
            key: "initNextButton", value: function () {
                var e = this.element.querySelector(".home__next-btn");
                e && (this.nextBtn = new Ob({element: e}), this.nextBtn.on("click", this.onNextButtonClick.bind(this)))
            }
        }, {
            key: "initGesture", value: function () {
                app.hasTouch && (this.hammer = new Fb.Manager(this.element, {
                    touchAction: app.windowWidth < app.screenS ? "auto" : "pan-x",
                    recognizers: [[Fb.Swipe, {direction: Fb.DIRECTION_VERTICAL}]]
                }), this.hammer.on("swipe", this.onSwipe.bind(this)))
            }
        }, {
            key: "dispose", value: function () {
                hs(rs(i.prototype), "dispose", this).call(this), this.disposeTimeline(), this.disposeInteractiveTitle(), this.disposeSplitBody(), this.disposeNextButton(), this.disposeGesture()
            }
        }, {
            key: "disposeTimeline", value: function () {
                this.timeline && (this.timeline.kill(), Ds(this.timeline), this.timeline = null)
            }
        }, {
            key: "disposeInteractiveTitle", value: function () {
                this.interactiveTitle && (this.interactiveTitle.dispose(), this.interactiveTitle = null)
            }
        }, {
            key: "disposeSplitBody", value: function () {
                this.splitBody && (this.splitBody.revert(), this.splitBody = null)
            }
        }, {
            key: "disposeNextButton", value: function () {
                this.nextBtn && (this.nextBtn.off("click"), this.nextBtn.dispose())
            }
        }, {
            key: "disposeGesture", value: function () {
                this.hammer && (this.hammer.destroy(), this.hammer = null)
            }
        }, {
            key: "updateLogoRectBeforeTransition", value: function () {
                this.logoRectBeforeTransition = fl.element.getBoundingClientRect()
            }
        }, {
            key: "animateOut", value: function () {
                hs(rs(i.prototype), "animateOut", this).call(this), this.interactiveTitle && this.interactiveTitle.pause()
            }
        }, {
            key: "createAnimIn", value: function (e) {
                this.initInteractiveTitle(), this.initSplitBody();
                var t = this.splitBody.lines.slice(), i = this.element.querySelector(".home__screen__more");
                i && t.push(i), this.timeline = new TimelineLite({onComplete: e}).staggerFrom(this.interactiveTitle.splitText.lines, .9, {
                    opacity: 0, y: 50, ease: Ns.easeOut
                }, .1, .8).addLabel("separator", .9).from(this.separatorElement, .9, {
                    scaleX: 0, xPercent: 100, ease: Ns.easeOut
                }, "separator").from(this.separatorElement, .9, {
                    y: 50, ease: Ns.easeOut
                }, "separator+=.5").from(this.separatorLineElement, .9, {
                    scaleX: 1, ease: Ns.easeOut
                }, "separator+=.5").staggerFrom(t, .9, {
                    opacity: 0, y: 50, transition: "none", ease: Ns.easeOut
                }, .1, "separator+=.5"), app.windowWidth < app.screenS && Ss.to(window, .6, {
                    scrollTo: {
                        y: 0, autoKill: !1
                    }
                }), this.owner.previousScreen && this.timeline.shiftChildren(.6), this.timeline.add(this.createLogoAnimIn(), 0)
            }
        }, {
            key: "createLogoAnimIn", value: function () {
                var e = fl.element.getBoundingClientRect(), t = new TimelineLite;
                return window.innerWidth >= app.screenS && this.owner.previousScreen && 0 === this.owner.previousScreen.index && t.fromTo(fl.element, .4, {
                    y: this.logoRectBeforeTransition.y - e.y,
                    x: this.logoRectBeforeTransition.x - e.x,
                    scaleX: this.logoRectBeforeTransition.width / e.width,
                    scaleY: this.logoRectBeforeTransition.height / e.height
                }, {y: "-=50", ease: Os.easeIn}, 0).to(fl.shapePath, .4, {
                    drawSVG: "100% 100%", ease: Os.easeInOut
                }, 0).set(fl.element, {
                    clearProps: "x,y,scaleX,scaleY", immediateRender: !1
                }), (window.innerWidth >= app.screenS && !this.owner.previousScreen || 0 === this.owner.previousScreen.index) && t.addLabel("in").from(fl.element, .7, {
                    y: 80, ease: Ns.easeOut, immediateRender: !1
                }, "in").fromTo(fl.shapePath, 1, {drawSVG: 0}, {
                    drawSVG: "100%", ease: Fs.easeInOut, immediateRender: !1
                }, "in"), t
            }
        }, {
            key: "createAnimOut", value: function (e) {
                var t = this.owner.currentScreen && this.owner.currentScreen.index > this.index ? 1 : -1;
                this.interactiveTitle && this.interactiveTitle.pause(), this.splitBody.split();
                var i = this.splitBody.lines.slice();
                i.splice(0, 0, this.separatorElement);
                var n = this.element.querySelector(".home__screen__more");
                n && i.push(n), this.timeline = new TimelineLite({onComplete: e}).set(this.element, {visibility: "inherit"}).staggerTo(this.interactiveTitle.splitText.lines, .6, {
                    opacity: 0, y: -50 * t, ease: Fs.easeIn
                }, .05 * t, 0).addLabel("separator", .3).to(this.separatorElement, .6, {
                    scaleX: 0, xPercent: 100, ease: Fs.easeOut
                }, "separator+=.3").to(this.separatorLineElement, .6, {
                    scaleX: 1, ease: Fs.easeOut
                }, "separator").staggerTo(i, .6, {opacity: 0, y: -50 * t, ease: Fs.easeIn}, .05 * t, "separator")
            }
        }, {
            key: "resize", value: function () {
                this.interactiveTitle && this.interactiveTitle.resize(), this.hammer && this.hammer.set({touchAction: app.windowWidth < app.screenS ? "auto" : "pan-x"})
            }
        }, {
            key: "onAnimateInComplete", value: function (e) {
                hs(rs(i.prototype), "onAnimateInComplete", this).call(this, e), this.interactiveTitle && this.interactiveTitle.start(), this.splitBody && this.splitBody.revert(), this.disposeTimeline()
            }
        }, {
            key: "onNextButtonClick", value: function () {
                this.onComplete()
            }
        }, {
            key: "onComplete", value: function () {
                this.emit("complete")
            }
        }, {
            key: "onSwipe", value: function (e) {
                app.windowWidth < app.screenS && 0 < window.pageYOffset && window.pageYOffset < this.element.scrollHeight - app.windowHeight || this.emit("swipe", e)
            }
        }]), i
    }(), kb = function (e) {
        function i(e) {
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this, e))).backgroundElement = t.element.querySelector(".home__screen__background"), t.scrollCTA = new Hs({element: t.element.querySelector(".scroll-cta")}), t.splitTitle = null, t
        }

        return ns(i, Nb), is(i, [{
            key: "initSplitTitle", value: function () {
                this.splitTitle = new Bs(this.titleElement, {type: "lines"})
            }
        }, {
            key: "dispose", value: function () {
                hs(rs(i.prototype), "dispose", this).call(this), this.scrollCTA.dispose(), this.scrollCTA = null, this.disposeSplitTitle()
            }
        }, {
            key: "disposeSplitTitle", value: function () {
                this.splitTitle && (this.splitTitle.revert(), this.splitTitle = null)
            }
        }, {
            key: "createAnimIn", value: function (e) {
                var t = 0, i = fl.element.getBoundingClientRect();
                (app.windowWidth < app.screenS && window.scrollTo(0, 0), this.owner.previousScreen || this.isAjaxPage) || (t = document.querySelector(".main-loading__logo").getBoundingClientRect().y - i.y);
                this.initSplitTitle(), this.initSplitBody(), this.timeline = new Us({onComplete: e}).from(fl.element, 1.2, {
                    y: t, ease: Fs.easeInOut
                }, 0).fromTo(fl.maskRect, 1.2, {attr: {width: 0}}, {
                    attr: {width: 1}, onUpdate: "safari" !== app.browser ? null : function () {
                        fl.element.style.display = "none", fl.element.offsetHeight, fl.element.style.display = ""
                    }, ease: Fs.easeInOut
                }, .3).fromTo(fl.shapePath, 1.2, {drawSVG: 0}, {
                    drawSVG: "100%", ease: Fs.easeInOut
                }, this.owner.previousScreen ? .5 : .3).staggerFrom(this.splitTitle.lines, .9, {
                    opacity: 0, y: 50, ease: Ns.easeOut
                }, .1, .8).from(this.backgroundElement, 1.2, {
                    opacity: 0, scaleY: 0, ease: Fs.easeInOut
                }, 0).addLabel("separator", .9).from(this.separatorElement, .9, {
                    scaleY: 0, yPercent: 100, ease: Ns.easeOut
                }, "separator").from(this.separatorLineElement, .9, {
                    scaleY: 1, ease: Ns.easeOut
                }, "separator+=.7").staggerFrom(this.splitBody.lines, .9, {
                    opacity: 0, y: 50, ease: Ns.easeOut
                }, .1, 1.2), window.innerWidth >= app.screenS && this.timeline.add(this.scrollCTA.animateIn(), 1.5)
            }
        }, {
            key: "createAnimOut", value: function (e) {
                this.splitTitle.split(), this.splitBody.split(), this.timeline = new Us({onComplete: e}).set(this.element, {visibility: "inherit"}).to(this.backgroundElement, .8, {opacity: 0}, .4).staggerTo(this.splitTitle.lines, .6, {
                    opacity: 0, y: -50, ease: Fs.easeIn
                }, .1, 0).addLabel("separator", .3).to(this.separatorElement, .6, {
                    scaleY: 0, yPercent: -100, ease: Fs.easeIn
                }, "separator").to(this.separatorLineElement, .6, {
                    scaleY: 1, ease: Fs.easeIn
                }, "separator+=.3").staggerTo(this.splitBody.lines, .6, {
                    opacity: 0, y: -50, ease: Fs.easeIn
                }, .1, "separator"), window.innerWidth >= app.screenS && this.timeline.add(this.scrollCTA.animateOut(), .2)
            }
        }, {
            key: "onAnimateInComplete", value: function (e) {
                hs(rs(i.prototype), "onAnimateInComplete", this).call(this, e), this.splitTitle && this.splitTitle.revert()
            }
        }]), i
    }(), Ub = function (e) {
        function i(e) {
            console.log('helooooooo')
            var t;
            return es(this, i), (t = ls(this, rs(i).call(this))).element = e, t.isActive = !1, t.needsResize = !0, t.selected = !1, t.forceReflow = !1, t.keyupCallback = t.onKeyUp.bind(ss(ss(t))), t.clickCallback = t.onClick.bind(ss(ss(t))), t.initSelect(), t.initLabel(), t.initList(), t.initItems(), t.value = t.select.value, t
        }

        return ns(i, ps), is(i, [{
            key: "initSelect", value: function () {
                this.select = this.element.querySelector(".select__select"), this.selectChangeCallback = this.onSelectChange.bind(this), this.select.addEventListener("change", this.selectChangeCallback)
            }
        }, {
            key: "initLabel", value: function () {
                this.label = this.element.querySelector(".select__label"), this.labelText = this.element.querySelector(".select__label__text"), this.labelClickCallback = this.onLabelClick.bind(this), this.label.addEventListener("click", this.labelClickCallback)
            }
        }, {
            key: "initList", value: function () {
                this.list = this.element.querySelector(".select__list")
            }
        }, {
            key: "initItems", value: function () {
                var t = this;
                this.items = this.element.querySelectorAll(".select__item"), this.itemClickCallback = this.onItemClick.bind(this), cs(this.items).forEach(function (e) {
                    e.addEventListener("click", t.itemClickCallback)
                })
            }
        }, {
            key: "dispose", value: function () {
                this.disposeSelect(), this.disposeLabel(), this.disposeItems(), this.deactivate()
            }
        }, {
            key: "disposeSelect", value: function () {
                this.select.removeEventListener("change", this.selectChangeCallback)
            }
        }, {
            key: "disposeLabel", value: function () {
                this.label.removeEventListener("click", this.labelClickCallback)
            }
        }, {
            key: "disposeItems", value: function () {
                var t = this;
                cs(this.items).forEach(function (e) {
                    e.removeEventListener("click", t.itemClickCallback)
                })
            }
        }, {
            key: "resize", value: function () {
                this.isActive ? (this.needsResize = !1, this.element.classList.add("select--active"), this.list.style.height = "", this.forceReflow && (this.list.style.display = "none", this.list.offsetHeight, this.list.style.display = ""), this.list.height = this.list.offsetHeight, this.element.classList.remove("select--active"), this.list.style.display = "none", this.list.offsetHeight, this.list.style.display = "") : this.needsResize = !0
            }
        }, {
            key: "toggle", value: function () {
                this.isActive ? this.deactivate() : this.activate()
            }
        }, {
            key: "activate", value: function () {
                var e = this;
                this.isActive || (this.isActive = !0, this.needsResize && this.resize(), setTimeout(function () {
                    e.element.classList.add("select--active"), window.addEventListener("keyup", e.keyupCallback), window.addEventListener("click", e.clickCallback)
                }), this.emit("activate", {currentTarget: this}))
            }
        }, {
            key: "deactivate", value: function () {
                this.isActive && (this.isActive = !1, this.element.classList.remove("select--active"), window.removeEventListener("keyup", this.keyupCallback), window.removeEventListener("click", this.clickCallback), this.emit("deactivate", {currentTarget: this}))
            }
        }, {
            key: "onLabelClick", value: function () {
                this.toggle()
            }
        }, {
            key: "onItemClick", value: function (e) {
                var t = e.currentTarget.getAttribute("data-value");
                this.select.value = t, this.onSelectChange()
            }
        }, {
            key: "onSelectChange", value: function () {
                var i, n = this;
                this.value = this.select.value, this.selected || (this.selected = !0, this.element.classList.add("select--selected")), cs(this.items).forEach(function (e) {
                    var t = e.getAttribute("data-value") === n.value;
                    e.classList.toggle("select__item--selected", t), t && (i = e)
                }), this.labelText.textContent = i.textContent, this.deactivate(), this.emit("change", {
                    currentTarget: this, value: this.value, item: i
                })
            }
        }, {
            key: "onKeyUp", value: function (e) {
                27 === e.keyCode && this.deactivate()
            }
        }, {
            key: "onClick", value: function () {
                this.deactivate()
            }
        }]), i
    }();
    var Db = new yu(-12.4, -89, 98), zb = new yu(8, -38, -4.7), Bb = function () {
            function e() {
                es(this, e), this.isRunning = !1, this.element = document.querySelector(".nav__background"), this.mouseX = 0, this.mouseY = 0, this.tickCallback = this.onTick.bind(this), this.onMouseMoveCallback = this.onMouseMove.bind(this), this.scene = new Wm, this.mouseControlPosition = new mu(this.mouseX, this.mouseY), this.mouseControlDirection = new mu(1, 1), this.initRenderer(), this.initCamera(), this.initLights(), this.initMeshes(), this.initComposer()
            }

            return is(e, [{
                key: "initRenderer", value: function () {
                    this.renderer = new jm({
                        antialias: !1, canvas: this.element
                    }), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.setClearColor(67084), this.renderer.autoClear = !1
                }
            }, {
                key: "initCamera", value: function () {
                    this.cameraPivot = new Pp, this.cameraPivot.position.set(-5, 10, 5), this.cameraPivot.rotation.y = fu.degToRad(-43), this.scene.add(this.cameraPivot), this.camera = new zm(37, window.innerWidth / window.innerHeight, .1, 1e3), this.camera.zoom = 1.1, this.camera.updateProjectionMatrix(), this.camera.position.copy(Db), this.cameraPivot.add(this.camera), this.cameraTarget = new Pp, this.cameraTarget.position.copy(zb), this.cameraPivot.add(this.cameraTarget), this.cameraTargetPosition = new yu, this.cameraWorldPosition = new yu
                }
            }, {
                key: "initLights", value: function () {
                    var e = new my(16777215, .6, 0, .06, 1, 6);
                    e.position.set(-972, -70, 965), this.scene.add(e), this.scene.add(e.target), e.target.position.set(41.4, -29.5, 14)
                }
            }, {
                key: "initMeshes", value: function () {
                    this.boxes = [], this.boxesY = [];
                    for (var e = 0; e < 13; e++) {
                        var t = rb.create();
                        t.position.y = e * (6 + rb.HEIGHT) * -1 - 17, t.rotation.x = fu.degToRad(90), this.boxesY.push(t.position.y), this.scene.add(t), this.boxes.push(t)
                    }
                }
            }, {
                key: "initComposer", value: function () {
                    var e = {minFilter: lc, magFilter: lc, format: Sc, stencilBuffer: !0},
                        t = new Bu(window.innerWidth, window.innerHeight, e);
                    this.composer = new Xx(this.renderer, t);
                    var i = new Wx(this.scene, this.camera);
                    i.clear = !1;
                    var n = new Gx(Yx), r = new Gx(Bx);
                    r.renderToScreen = !0;
                    var a = new fb;
                    this.noiseCounter = 0;
                    var o = {
                        uniforms: {tDiffuse: {value: null}, uAmount: {value: this.noiseCounter}},
                        vertexShader: yb,
                        fragmentShader: _b
                    };
                    this.noisePass = new Gx(o), this.composer.addPass(a), this.composer.addPass(i), this.composer.addPass(n), this.composer.addPass(this.noisePass), this.composer.addPass(r)
                }
            }, {
                key: "start", value: function () {
                    this.isRunning || (this.isRunning = !0, Ss.ticker.addEventListener("tick", this.tickCallback), window.addEventListener("mousemove", this.onMouseMoveCallback))
                }
            }, {
                key: "pause", value: function () {
                    this.isRunning && (this.isRunning = !1, Ss.ticker.removeEventListener("tick", this.tickCallback), window.removeEventListener("mousemove", this.onMouseMoveCallback))
                }
            }, {
                key: "resize", value: function () {
                    this.renderer.setSize(window.innerWidth, window.innerHeight), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix()
                }
            }, {
                key: "animateIn", value: function () {
                    return this.timeline = new Us({onComplete: this.onAnimInComplete.bind(this)}).fromTo(this.camera.position, 2.8, {
                        x: Db.x, y: -112, z: 44
                    }, {x: Db.x, y: Db.y, z: Db.z, ease: Os.easeOut}, 0).fromTo(this.cameraTarget.position, 2, {
                        x: zb.x, y: 22, z: zb.z
                    }, {x: zb.x, y: zb.y, z: zb.z, ease: Os.easeOut}, 0), this.timeline
                }
            }, {
                key: "animateOut", value: function () {
                    return this.timeline = new Us({onComplete: this.onAnimOutComplete.bind(this)}).to(this.camera.position, 1, {
                        x: 4, y: -112, z: 74, ease: Os.easeIn
                    }, 0).to(this.cameraTarget.position, 1, {x: -26, y: -36, z: -63, ease: Os.easeIn}, 0), this.timeline
                }
            }, {
                key: "offsetBoxes", value: function (e) {
                    var o = this, s = this.boxes.length - 1 - 3, l = s - e;
                    this.boxes.forEach(function (e, t) {
                        var i = l <= t ? -1 : 1, n = window.Math.abs(t - l);
                        -1 === i && (n += 1);
                        var r, a = (n - (r = 1)) / (s - r);
                        Ss.to(e.position, 1.1, {y: o.boxesY[t] + 2 * i * n - 6 * i * a, ease: Fs.easeInOut})
                    })
                }
            }, {
                key: "clearBoxesOffset", value: function () {
                    var i = this;
                    this.boxes.forEach(function (e, t) {
                        Ss.to(e.position, .8, {y: i.boxesY[t], ease: Fs.easeOut})
                    })
                }
            }, {
                key: "updateMouseControl", value: function () {
                    var e = Db.x + 2 * this.mouseY, t = Db.y + 2 * this.mouseX;
                    this.camera.position.x += .1 * (e - this.camera.position.x), this.camera.position.y += .1 * (t - this.camera.position.y)
                }
            }, {
                key: "onTick", value: function () {
                    this.cameraTarget.getWorldPosition(this.cameraTargetPosition), this.camera.lookAt(this.cameraTargetPosition), this.camera.rotateZ(fu.degToRad(89)), this.noiseCounter += .01, this.noisePass.uniforms.uAmount.value = this.noiseCounter, this.timeline || this.updateMouseControl(), this.composer.render()
                }
            }, {
                key: "onAnimInComplete", value: function () {
                    this.timeline = null
                }
            }, {
                key: "onAnimOutComplete", value: function () {
                    this.timeline = null
                }
            }, {
                key: "onMouseMove", value: function (e) {
                    this.mouseX = e.clientX / window.innerWidth * 2 - 1, this.mouseY = e.clientY / window.innerHeight * -2 + 1
                }
            }]), e
        }(), Hb = new (function (e) {
            function i() {
                var t;
                return es(this, i), (t = ls(this, rs(i).call(this))).element = document.querySelector(".nav"), t.isVisible = !1, t.onKeyUpHandler = t.onKeyUp.bind(ss(ss(t))), t.previousSelectedItem = null, t.selectedItem = t.element.querySelector(".nav__item--selected"), t.hoveredItem = null, t.clearHoveredItemTimeout = -1, t.itemLine = t.element.querySelector(".nav__item-line"), t.itemLines = t.itemLine.querySelectorAll(".nav__item-line div"), t.itemLineIsVisible = !1, t.itemLine2Rect = t.itemLines[1].getBoundingClientRect(), t.itemsElement = t.element.querySelector(".nav__items"), t.itemsX = 0, t.itemElements = t.element.querySelectorAll(".nav__item"), t.mouseDirection = 1, cs(t.itemElements).forEach(function (e) {
                    e.addEventListener("mouseenter", t.onItemRollOver.bind(ss(ss(t)))), e.addEventListener("mouseleave", t.onItemRollOut.bind(ss(ss(t))))
                }), t.selectedItem || (t.itemLine.style.visibility = "hidden"), t.background = new Bb, t.timeline = null, t.initLangSelect(), t
            }

            return ns(i, ps), is(i, [{
                key: "initLangSelect", value: function () {
                    var e = this.element.querySelector(".nav__lang");
                    e && (this.langSelect = new Ub(e), this.langSelect.on("change", this.onLangSelectChange.bind(this)))
                }
            }, {
                key: "setSelectedItem", value: function (e) {
                    this.selectedItem && e === this.selectedItem.getAttribute("data-page") || (this.selectedItem ? (this.previousSelectedItem = this.selectedItem, this.selectedItem.classList.remove("nav__item--selected")) : (this.previousSelectedItem = null, this.itemLine.style.visibility = ""), this.selectedItem = document.querySelector('.nav__item[data-page="'.concat(e, '"]')), this.selectedItem && (this.selectedItem.classList.add("nav__item--selected"), this.resizeItemLine()))
                }
            }, {
                key: "setVisibility", value: function (e) {
                    e !== this.isVisible && (this.isVisible = e, document.querySelector('#__nuxt').classList.toggle("nav-visible", this.isVisible), this.emit("visibilityChange", {isVisible: this.isVisible}))
                }
            }, {
                key: "show", value: function () {
                    if (!this.isVisible) {
                        var e = fl.element.getBoundingClientRect();
                        this.setVisibility(!0), window.addEventListener("keyup", this.onKeyUpHandler), this.background.start(), this.animateIn(e)
                    }
                }
            }, {
                key: "hide", value: function () {
                    var t = this;
                    this.isVisible && (window.removeEventListener("keyup", this.onKeyUpHandler), setTimeout(function () {
                        var e = fl.element.getBoundingClientRect();
                        t.setVisibility(!1), t.animateOut(e)
                    }))
                }
            }, {
                key: "animateIn", value: function (e) {
                    console.log(e, 'e1')
                    this.timeline && (this.timeline.kill(), Ds(this.timeline));
                    var t = fl.element.getBoundingClientRect();
                    if (this.hoveredItem = null, this.itemLineIsVisible = !1, this.resizeItemLine(), this.timeline = new Us({
                        delay: .1, onComplete: this.onAnimateInComplete.bind(this)
                    }).fromTo(this.background.element, .4, {opacity: 0}, {
                        opacity: 1, ease: Cs.easeNone
                    }, 0).from(fl.element, 1.3, {
                        x: e.x - t.x, y: e.y - t.y, scale: e.width / t.width, ease: Ns.easeInOut
                    }, 0).fromTo(fl.maskRect, .7, {attr: {width: document.querySelector('#__nuxt').classList.contains("page-id-home-screen-0") ? 1 : 0}}, {
                        attr: {width: 1}, onUpdate: "safari" !== app.browser ? null : function () {
                            fl.element.style.display = "none", fl.element.offsetHeight, fl.element.style.display = ""
                        }, ease: Os.easeInOut
                    }, .3).addLabel("items", .3).staggerFrom(this.itemElements, .8, {
                        y: 30, opacity: 0, ease: Ns.easeOut
                    }, .08, "items").fromTo(this.element.querySelector(".nav__footer"), 1, {opacity: 0}, {
                        opacity: 1, ease: Cs.easeNone
                    }, .7).add(this.background.animateIn(), 0), this.selectedItem) {
                        var i = .08 * Array.prototype.indexOf.call(this.itemElements, this.selectedItem);
                        this.timeline.fromTo(this.itemLine, .4, {opacity: 0}, {
                            opacity: 1, ease: Cs.easeNone
                        }, "items+=" + i).fromTo(this.itemLine, .8, {y: 30}, {
                            y: 0, data: {clear: !1}, ease: Fs.easeOut
                        }, "items+=" + i).from(this.itemLines[0], .8, {
                            scaleX: 0, ease: Os.easeInOut, data: {clear: !1}
                        }, "items+=" + i).fromTo(this.itemLines[1], .8, {scaleX: 0, x: 0}, {
                            scaleX: 1, ease: Fs.easeOut, data: {clear: !1}
                        }, "items+=" + (i + .3))
                    } else Ss.set(this.itemLine, {y: 0})
                }
            }, {
                key: "animateOut", value: function (e) {
                    console.log(e, 'e2')
                    this.timeline && this.timeline.kill(), Ss.set(fl.element, {clearProps: "x, y, scale"});
                    var t = fl.element.getBoundingClientRect();
                    this.hoveredItem && this.background.clearBoxesOffset(), this.timeline = new Us({onComplete: this.onAnimateOutComplete.bind(this)}).set(this.element, {visibility: "inherit"}).to(this.background.element, .4, {
                        opacity: 0, ease: Cs.easeNone
                    }, .3).from(fl.element, 1.3, {
                        x: e.x - t.x, y: e.y - t.y, scale: e.width / t.width, ease: Ns.easeInOut
                    }, 0).set(fl.textPath, {visibility: "inherit"}, 0).to(fl.maskRect, .7, {
                        attr: {width: document.querySelector('#__nuxt').classList.contains("page-id-home-screen-0") ? 1 : 0},
                        onUpdate: "safari" !== app.browser ? null : function () {
                            fl.element.style.display = "none", fl.element.offsetHeight, fl.element.style.display = ""
                        },
                        ease: Os.easeInOut
                    }, .2).addLabel("items", .1).staggerTo(this.itemElements, .4, {
                        y: 30, opacity: 0, ease: Os.easeOut
                    }, app.windowWidth < app.screenM ? -.06 : .06, "items").to(this.element.querySelector(".nav__footer"), .5, {
                        opacity: 0, ease: Cs.easeNone
                    }, 0).add(this.background.animateOut(), 0);
                    var i = this.hoveredItem || this.selectedItem || this.previousSelectedItem;
                    if (i) {
                        var n = .06 * Array.prototype.indexOf.call(this.itemElements, i);
                        this.timeline.to(this.itemLine, .4, {
                            y: 30, opacity: 0, ease: Os.easeOut, data: {clear: !1}
                        }, "items+=" + n)
                    }
                }
            }, {
                key: "resize", value: function (e) {
                    var t = this.itemsElement.getBoundingClientRect();
                    this.itemsX = t.x, this.resizeItemLine(), e && this.background.resize()
                }
            }, {
                key: "resizeItemLine", value: function () {
                    if (this.selectedItem) {
                        var e = this.selectedItem.querySelector(".nav__item__link").getBoundingClientRect();
                        Ss.set(this.itemLine, {x: e.x - this.itemsX}), Ss.set(this.itemLines[0], {scaleX: e.width})
                    }
                }
            }, {
                key: "moveItemLineToItem", value: function (e) {
                    var t = e && e.querySelector(".nav__item__link"),
                        i = t ? t.getBoundingClientRect() : this.itemLine.getBoundingClientRect(),
                        n = this.itemLine._gsTransform ? this.itemLine._gsTransform.x : 0;
                    this.selectedItem || this.itemLineIsVisible ? this.mouseDirection = n < i.x ? 1 : -1 : (Ss.set(this.itemLine, {x: i.x - this.itemsX}), this.mouseDirection = 0);
                    var r = this.itemLines[0], a = this.itemLines[1];
                    Ss.killTweensOf([r, a, this.itemLine]);
                    var o = new Us;
                    0 === this.mouseDirection ? o.fromTo(a, .4, {scaleX: 0, x: 0}, {
                        scaleX: 1, ease: Fs.easeOut
                    }) : 1 === this.mouseDirection ? (o.fromTo(a, .4, {x: 0}, {
                        scaleX: i.width / this.itemLine2Rect.width, ease: Fs.easeOut, immediateRender: !1
                    }), e && o.to(a, .4, {
                        scaleX: 1, x: i.width - this.itemLine2Rect.width, ease: Fs.easeOut
                    })) : o.to(a, .4, {
                        scaleX: i.width / this.itemLine2Rect.width, x: 0, ease: Fs.easeOut, immediateRender: !1
                    }).to(a, .4, {scaleX: 1, ease: Fs.easeOut}), (new Us).to(r, .7, {
                        scaleX: i.width, ease: Fs.easeOut
                    }, 0).add(o, 0).set(this.itemLine, {
                        visibility: "inherit", opacity: 1
                    }, 0).to(this.itemLine, .7, {x: i.x - this.itemsX, ease: Fs.easeOut}, 0)
                }
            }, {
                key: "onKeyUp", value: function (e) {
                    27 === e.keyCode && this.hide()
                }
            }, {
                key: "onItemRollOver", value: function (e) {
                    if (this.isVisible && (clearTimeout(this.clearHoveredItemTimeout), (this.hoveredItem || e.currentTarget !== this.selectedItem) && this.hoveredItem !== e.currentTarget)) {
                        if (this.hoveredItem = e.currentTarget === this.selectedItem ? null : e.currentTarget, this.hoveredItem) {
                            var t = Array.prototype.indexOf.call(this.itemElements, this.hoveredItem);
                            this.background.offsetBoxes(t)
                        }
                        this.moveItemLineToItem(this.hoveredItem || this.selectedItem), this.itemLineIsVisible = !0
                    }
                }
            }, {
                key: "onItemRollOut", value: function (e) {
                    var t = this;
                    this.hoveredItem && this.isVisible && (this.clearHoveredItemTimeout = setTimeout(function () {
                        t.hoveredItem = null, t.background.clearBoxesOffset(), t.moveItemLineToItem(t.selectedItem), t.itemLineIsVisible = !1
                    }, 300))
                }
            }, {
                key: "onAnimateInComplete", value: function () {
                    Ds(this.timeline), this.timeline = null
                }
            }, {
                key: "onAnimateOutComplete", value: function () {
                    Ds(this.timeline), this.timeline = null, this.background.pause()
                }
            }, {
                key: "onLangSelectChange", value: function (e) {
                    window.location = e.item.href
                }
            }]), i
        }()), Gb = [kb, Nb, Nb, Nb, Nb], jb = function (e) {
            function t(e) {
                return es(this, t), ls(this, rs(t).call(this, e))
            }

            return ns(t, Cl), is(t, [{
                key: "initPage", value: function () {
                    hs(rs(t.prototype), "initPage", this).call(this), this.previousScreenIndex = -1, this.currentScreenIndex = 0, this.nextScreenIndex = -1, this.screenElements = this.element.querySelectorAll(".home__screen"), this.background = new Lb({
                        screenElements: this.screenElements, element: this.element
                    }), this.initScreenNavigator(), this.initNav(), this.initPagination(), this.logoClickCallback = this.onLogoClick.bind(this), fl.element.addEventListener("click", this.logoClickCallback), this.isAjax || this.addScreenClassName(this.currentScreenIndex)
                }
            }, {
                key: "initScrollCTA", value: function () {
                }
            }, {
                key: "initLine", value: function () {
                }
            }, {
                key: "initScroll", value: function () {
                }
            }, {
                key: "initScreenNavigator", value: function () {
                    var o = this;
                    this.screenNavigator = new ws, this.screenNavigator.transitionType = xs.OutAndIn, this.screenNavigator.on("transitionStart", this.onScreenNavigatorTransitionStart.bind(this)), this.screenNavigator.on("transitionComplete", this.onScreenNavigatorTransitionComplete.bind(this)), cs(this.screenElements).forEach(function (e, t) {
                        const BaseHomeScreen = []
                        var i = t.toString(), n = Gb[t] || BaseHomeScreen,
                            r = e.classList.contains("home__screen--light") ? ul : pl, a = new ds(n, {
                                arguments: [{
                                    element: e, index: t, owner: o.screenNavigator, isAjaxPage: o.isAjax, color: r
                                }], events: {swipe: o.onSwipe.bind(o), complete: o.onScreenComplete.bind(o)}
                            });
                        e.classList.contains("home__screen--current") && (o.currentScreenIndex = t), o.screenNavigator.addScreen(i, a)
                    })
                }
            }, {
                key: "initNav", value: function () {
                    this.onKeyUpCallback = this.onKeyUp.bind(this), this.onScrollCallback = this.onScroll.bind(this), window.addEventListener("keyup", this.onKeyUpCallback), window.addEventListener("wheel", this.onScrollCallback, {passive: !1})
                }
            }, {
                key: "initPagination", value: function () {
                    this.pagination = new Ib({
                        parentElement: this.element, total: this.screenElements.length - 1
                    }), this.pagination.on("change", this.onPaginationChange.bind(this))
                }
            }, {
                key: "dispose", value: function () {
                    hs(rs(t.prototype), "dispose", this).call(this), this.background && this.background.dispose(), this.disposeScreenNavigator(), this.disposeNav(), this.disposePagination(), fl.element.removeEventListener("click", this.logoClickCallback)
                }
            }, {
                key: "disposeScreenNavigator", value: function () {
                    this.screenNavigator && (this.screenNavigator.off("transitionStart"), this.screenNavigator.off("transitionComplete"), this.screenNavigator.dispose())
                }
            }, {
                key: "disposeNav", value: function () {
                    window.removeEventListener("keyup", this.onKeyUpCallback), window.removeEventListener("wheel", this.onScrollCallback)
                }
            }, {
                key: "disposePagination", value: function () {
                    this.pagination && (this.pagination.off("change"), this.pagination.dispose())
                }
            }, {
                key: "getScreenClassName", value: function (e) {

                    return "page-id-".concat(this.id, "-screen-").concat(e)


                }
            }, {
                key: "addScreenClassName", value: function (e) {
                    var t = this.getScreenClassName(e);
                    if (window.location.pathname === '/' || window.location.pathname === '') {
                        document.querySelector('#__nuxt').classList.add(t)
                    }
                }
            }, {
                key: "removeScreenClassName", value: function (e) {
                    var t = this.getScreenClassName(e);
                    document.querySelector('#__nuxt').classList.remove(t)
                }
            }, {
                key: "populateLoader", value: function (e, t) {
                    var r = this, i = [ub.getImage().path, db.getImage().path], n = i.map(function (e) {
                        var i = app.rootUrl + "/assets/img/" + e, n = new zv;
                        return new Promise(function (e, t) {
                            n.load(i, e, null, t)
                        }).then(r.onAssetLoaded.bind(r))
                    });
                    this.numAssetsToLoad = i.length, Promise.all(n).then(e).catch(t)
                }
            }, {
                key: "createAnimInContent", value: function () {
                    this.element.style.visibility = "inherit", this.isAjax && this.addScreenClassName(this.currentScreenIndex), this.screenNavigator.showScreen(this.currentScreenIndex.toString()), this.background.animateIn()
                }
            }, {
                key: "createAnimOut", value: function (e) {
                    hs(rs(t.prototype), "createAnimOut", this).call(this, e), this.background.stop()
                }
            }, {
                key: "resize", value: function (e) {
                    hs(rs(t.prototype), "resize", this).call(this, e), this.background && this.background.resize(), this.pagination && this.pagination.resize(), this.screenNavigator && this.screenNavigator.currentScreen.resize()
                }
            }, {
                key: "gotoScreen", value: function (e) {
                    e !== this.currentScreenIndex && (this.previousScreenIndex = this.currentScreenIndex, this.currentScreenIndex = e, this.screenNavigator.showScreen(e.toString()))
                }
            }, {
                key: "gotoNextScreen", value: function () {
                    var e = this.currentScreenIndex + 1;
                    Gb.length - 1 < e && (e = Gb.length - 1), this.gotoScreen(e)
                }
            }, {
                key: "gotoPrevScreen", value: function () {
                    var e = this.currentScreenIndex - 1;
                    e < 0 && (e = 0), this.gotoScreen(e)
                }
            }, {
                key: "onAnimateOutComplete", value: function () {
                    hs(rs(t.prototype), "onAnimateOutComplete", this).call(this), this.screenNavigator && this.removeScreenClassName(this.screenNavigator.currentItemId)
                }
            }, {
                key: "onScreenNavigatorTransitionStart", value: function () {
                    this.screenNavigator.currentScreen.updateLogoRectBeforeTransition(), app.isTablet && this.screenNavigator.currentScreen.resize(), this.background.showScreen(this.currentScreenIndex), this.screenNavigator.previousScreen && (this.screenElements[this.previousScreenIndex].classList.remove("home__screen--current"), this.screenElements[this.currentScreenIndex].classList.add("home__screen--current"), this.removeScreenClassName(this.screenNavigator.previousItemId), this.addScreenClassName(this.screenNavigator.currentItemId)), this.changeColor(this.screenNavigator.currentScreen.color), 0 !== this.currentScreenIndex ? (this.pagination.show(), this.pagination.setCurrentIndex(this.currentScreenIndex)) : this.screenNavigator.previousScreen && this.pagination.hide(), app.windowWidth < app.screenM && Ss.to(window, 1, {
                        scrollTo: 0, ease: Os.easeOut
                    })
                }
            }, {
                key: "onScreenNavigatorTransitionComplete", value: function () {
                    -1 !== this.nextScreenIndex && (this.gotoScreen(this.nextScreenIndex), this.nextScreenIndex = -1)
                }
            }, {
                key: "onKeyUp", value: function (e) {
                    console.log(window.location)
                    switch (e.keyCode) {
                        case 38:
                            if (window.location.pathname === '/' || window.location.pathname === '') {
                                this.gotoPrevScreen();
                            }
                            break;
                        case 40:
                            if (window.location.pathname === '/' || window.location.pathname === '') {
                                this.gotoNextScreen()
                            }

                    }
                }
            }, {
                key: "onScroll", value: function (e) {
                    if (window.location.pathname === '/' || window.location.pathname === '') {
                        window.innerWidth < app.screenS || (e.preventDefault(), this.screenNavigator.transition || Hb.isVisible || (e.wheelDelta && e.wheelDelta < 0 || e.detail && 0 < e.detail ? this.gotoNextScreen() : this.gotoPrevScreen()))

                    }
                }
            }, {
                key: "onPaginationChange", value: function (e) {
                    this.screenNavigator.transition && e.index !== this.currentScreenIndex ? this.nextScreenIndex = e.index : this.gotoScreen(e.index)
                }
            }, {
                key: "onLogoClick", value: function (e) {
                    e.preventDefault(), this.gotoScreen(0)
                }
            }, {
                key: "onScreenComplete", value: function () {
                    this.gotoNextScreen()
                }
            }, {
                key: "onSwipe", value: function (e) {
                    e.direction === Hammer.DIRECTION_UP ? this.gotoNextScreen() : e.direction === Hammer.DIRECTION_DOWN && this.gotoPrevScreen()
                }
            }]), t
        }(), Vb = function (e) {
            function i(e) {
                return es(this, i), ls(this, rs(i).call(this, e))
            }

            return ns(i, Cl), is(i, [{
                key: "initPage", value: function () {
                    hs(rs(i.prototype), "initPage", this).call(this), this.initInteractiveText()
                }
            }, {
                key: "initInteractiveText", value: function () {
                    var i = this, e = this.element.querySelectorAll(".page__section__head > p");
                    this.interactiveTextResizeTimeout = -1, this.interactiveTexts = [], cs(e).forEach(function (e) {
                        var t = new Rb({element: e, color: [179, 218, 226]});
                        i.interactiveTexts.push(t)
                    })
                }
            }, {
                key: "dispose", value: function () {
                    hs(rs(i.prototype), "dispose", this).call(this), this.disposeInteractiveTexts()
                }
            }, {
                key: "disposeInteractiveTexts", value: function () {
                    if (this.interactiveTexts) for (; this.interactiveTexts.length;) this.interactiveTexts.shift().dispose()
                }
            }, {
                key: "animateInContent", value: function () {
                    hs(rs(i.prototype), "animateInContent", this).call(this);
                    var e = this.element.querySelector(".page__background");
                    if (this.timeline.from(e, 2, {
                        x: .2 * app.windowWidth, y: .1 * app.windowWidth, rotationX: -10, rotationY: 30, ease: Os.easeOut
                    }, 0).from(e, 1, {opacity: 0}, 0), this.interactiveTexts) {
                        var t = [];
                        this.interactiveTexts.forEach(function (e) {
                            t = t.concat(e.splitText.lines.slice())
                        }), this.timeline.staggerFrom(t, .7, {y: 50, opacity: 0, ease: Power3.easeOut}, .06, .6)
                    }
                }
            }, {
                key: "resize", value: function (e) {
                    hs(rs(i.prototype), "resize", this).call(this, e), this.resizeInteractiveTexts()
                }
            }, {
                key: "resizeInteractiveTexts", value: function () {
                    var e = this;
                    this.interactiveTexts && (clearTimeout(this.interactiveTextResizeTimeout), this.interactiveTextResizeTimeout = setTimeout(function () {
                        e.interactiveTexts.forEach(function (e) {
                            e.resize()
                        })
                    }, 100))
                }
            }, {
                key: "onAnimateInContentComplete", value: function () {
                    hs(rs(i.prototype), "onAnimateInContentComplete", this).call(this), this.interactiveTexts && this.interactiveTexts.forEach(function (e) {
                        e.start()
                    })
                }
            }]), i
        }(), Xb = function (e) {
            function i(e) {
                var t;
                return es(this, i), (t = ls(this, rs(i).call(this))).element = e, t.changeCallback = t.onChange.bind(ss(ss(t))), t.element.addEventListener("input", t.changeCallback), t.element.addEventListener("paste", t.changeCallback), t
            }

            return ns(i, ps), is(i, [{
                key: "dispose", value: function () {
                    this.element.removeEventListener("input", this.changeCallback), this.element.removeEventListener("paste", this.changeCallback)
                }
            }, {
                key: "onChange", value: function () {
                    var e = 0 !== this.element.value.length;
                    this.element.classList.toggle("form__input--filled", e), this.emit("change", {
                        currentTarget: this, filled: e
                    })
                }
            }]), i
        }(), Wb = 0, Yb = 1, qb = function () {
            function t(e) {
                es(this, t), this.element = e, this.submitCallback = this.onSubmit.bind(this), this.element.addEventListener("submit", this.submitCallback), this.initSelects(), this.initTextInputs()
            }

            return is(t, [{
                key: "initSelects", value: function () {
                    this.selects = cs(this.element.querySelectorAll(".select")).map(function (e) {
                        return new Ub(e)
                    })
                }
            }, {
                key: "initTextInputs", value: function () {
                    this.textInputs = cs(this.element.querySelectorAll(".form__input")).map(function (e) {
                        return new Xb(e)
                    })
                }
            }, {
                key: "dispose", value: function () {
                    this.element.removeEventListener("submit", this.submitCallback), this.disposeSelects(), this.disposeTextInputs()
                }
            }, {
                key: "disposeSelects", value: function () {
                    for (; this.selects.length;) this.selects.shift().dispose()
                }
            }, {
                key: "disposeTextInputs", value: function () {
                    for (; this.textInputs.length;) this.textInputs.shift().dispose()
                }
            }, {
                key: "formatErrorsMessage", value: function (e) {
                    var t = '<ul class="form__message__errors">';
                    return e.forEach(function (e) {
                        t += '<li class="form__message__error">'.concat(e.message, "</li>")
                    }), t += "</ul>"
                }
            }, {
                key: "showMessage", value: function (e, t) {
                    var i = this.element.querySelector(".form__message"),
                        n = i.getBoundingClientRect().y + window.pageYOffset - .5 * app.windowHeight;
                    i.innerHTML = e, i.classList.toggle("form__message--success", t === Wb), i.classList.toggle("form__message--errors", t === Yb), Ss.to(window, .4, {
                        scrollTo: n, ease: Power2.easeOut
                    })
                }
            }, {
                key: "onSubmit", value: function (e) {
                    var t = this, i = new FormData(this.element);
                    e.preventDefault(), window.fetch(window.location.href, {
                        method: "POST", body: i, headers: {"X-Requested-With": "XMLHttpRequest"}
                    }).then(function (e) {
                        e.json().then(function (e) {
                            return t.onSubmitted(e)
                        })
                    })
                }
            }, {
                key: "onSubmitted", value: function (e) {
                    if (e.success) this.showMessage(e.message, Wb); else if (e.errors) {
                        var t = this.formatErrorsMessage(e.errors);
                        this.showMessage(t, Yb)
                    }
                }
            }]), t
        }(), Qb = {
            default: Cl, home: jb, about: Vb, invest: function (e) {
                function t(e) {
                    return es(this, t), ls(this, rs(t).call(this, e))
                }

                return ns(t, Cl), is(t, [{
                    key: "initPage", value: function () {
                        this.lineStepsSelector = ".form__submit", hs(rs(t.prototype), "initPage", this).call(this), this.initForm()
                    }
                }, {
                    key: "initForm", value: function () {
                        var t = this, e = this.element.querySelector(".form");
                        this.form = new qb(e), this.requiredInputs = e.querySelectorAll("[required]"), this.inputChangeCallback = this.onRequiredInputChange.bind(this), this.requiredFilledInputs = [], cs(this.requiredInputs).forEach(function (e) {
                            e.addEventListener("input", t.inputChangeCallback), e.addEventListener("paste", t.inputChangeCallback)
                        })
                    }
                }, {
                    key: "dispose", value: function () {
                        hs(rs(t.prototype), "dispose", this).call(this), this.disposeForm()
                    }
                }, {
                    key: "disposeForm", value: function () {
                        var t = this;
                        this.form && (this.form.dispose(), cs(this.requiredInputs).forEach(function (e) {
                            e.removeEventListener("input", t.inputChangeCallback), e.removeEventListener("paste", t.inputChangeCallback)
                        }))
                    }
                }, {
                    key: "createAnimInContent", value: function () {
                        hs(rs(t.prototype), "createAnimInContent", this).call(this);
                        var e = this.element.querySelector(".page__background");
                        this.timeline.from(e, 2, {
                            y: -400, scale: 1.5, rotationX: 25, rotationY: -7, ease: Os.easeOut
                        }, 0).from(e, 1, {opacity: 0}, 0)
                    }
                }, {
                    key: "onRequiredInputChange", value: function (e) {
                        var t = e.currentTarget, i = 0 !== t.value.length, n = this.requiredFilledInputs.indexOf(t);
                        i && -1 === n ? this.requiredFilledInputs.push(t) : i || -1 === n || this.requiredFilledInputs.splice(n, 1), this.form.element.classList.toggle("form--filled", this.requiredFilledInputs.length === this.requiredInputs.length)
                    }
                }]), t
            }(), team: function (e) {
                function t(e) {
                    return es(this, t), ls(this, rs(t).call(this, e))
                }

                return ns(t, Cl), is(t, [{
                    key: "initPage", value: function () {
                        hs(rs(t.prototype), "initPage", this).call(this), this.initMembers()
                    }
                }, {
                    key: "initMembers", value: function () {
                        var t = this;
                        this.memberRollOverCallback = this.onMemberRollOver.bind(this), this.memberElements = this.element.querySelectorAll(".team__member"), cs(this.memberElements).forEach(function (e) {
                            e.addEventListener("mouseenter", t.memberRollOverCallback)
                        })
                    }
                }, {
                    key: "dispose", value: function () {
                        hs(rs(t.prototype), "dispose", this).call(this), this.disposeMembers()
                    }
                }, {
                    key: "disposeMembers", value: function () {
                        var t = this;
                        this.memberElements && cs(this.memberElements).forEach(function (e) {
                            e.removeEventListener("mouseenter", t.memberRollOverCallback)
                        })
                    }
                }, {
                    key: "createAnimInContent", value: function () {
                        var i = this;
                        hs(rs(t.prototype), "createAnimInContent", this).call(this), this.timeline.from(this.element.querySelector(".team__members"), .7, {opacity: 0}, 0), cs(this.memberElements).forEach(function (e) {
                            var t = e.querySelectorAll(".team__member__name, .team__member__role, .team__member__contact");
                            i.timeline.staggerFrom(t, .9, {opacity: 0, y: 30, ease: Fs.easeOut}, .07, .4)
                        })
                    }
                }, {
                    key: "onMemberRollOver", value: function (e) {
                        var t = e.currentTarget.querySelectorAll(".team__member__name,.team__member__role,.team__member__email,.team__member__linkedin");
                        Ss.killTweensOf(t), (new Us).staggerFromTo(t, .7, {y: 30, opacity: 0}, {
                            y: 0, opacity: 1, ease: Fs.easeOut
                        }, .1)
                    }
                }]), t
            }(), partners: function (e) {
                function t(e) {
                    return es(this, t), ls(this, rs(t).call(this, e))
                }

                return ns(t, Cl), is(t, [{
                    key: "initPage", value: function () {
                        hs(rs(t.prototype), "initPage", this).call(this)
                    }
                }, {
                    key: "initPartners", value: function () {
                        var t = this;
                        this.partnerRollOverCallback = this.onPartnerRollOver.bind(this), this.partnerRollOutCallback = this.onPartnerRollOut.bind(this), this.partnerElements = this.element.querySelectorAll(".partners__list__item"), cs(this.partnerElements).forEach(function (e) {
                            e.addEventListener("mouseenter", t.partnerRollOverCallback), e.addEventListener("mouseleave", t.partnerRollOutCallback)
                        })
                    }
                }, {
                    key: "dispose", value: function () {
                        hs(rs(t.prototype), "dispose", this).call(this)
                    }
                }, {
                    key: "disposePartners", value: function () {
                        var t = this;
                        cs(this.partnerElements).forEach(function (e) {
                            e.removeEventListener("mouseenter", t.partnerRollOverCallback), e.removeEventListener("mouseleave", t.partnerRollOutCallback)
                        })
                    }
                }, {
                    key: "createAnimInContent", value: function () {
                        hs(rs(t.prototype), "createAnimInContent", this).call(this);
                        var e = this.element.querySelectorAll(".partners__list__item");
                        this.timeline.staggerFrom(e, .8, {y: 30, opacity: 0}, .1, .4)
                    }
                }, {
                    key: "getMouseDirection", value: function (e, t) {
                        var i = e.width, n = e.height, r = (t.x - e.left - i / 2) * (n < i ? n / i : 1),
                            a = (t.y - e.top - n / 2) * (i < n ? i / n : 1);
                        return Math.round((Math.atan2(a, r) * (180 / Math.PI) + 180) / 90 + 3) % 4
                    }
                }, {
                    key: "onPartnerRollOver", value: function (e) {
                        var t = e.currentTarget, i = t.querySelector(".partners__list__item__overlay"),
                            n = t.querySelector(".partners__list__item__overlay__background"),
                            r = {x: e.clientX, y: e.clientY}, a = this.getMouseDirection(t.getBoundingClientRect(), r);
                        Ss.killTweensOf([i, n]), (new Us).fromTo(n, .6, {
                            scaleX: 1 === a || 3 === a ? 0 : 1,
                            scaleY: 0 === a || 2 === a ? 0 : 1,
                            xPercent: 1 === a ? 100 : 0,
                            yPercent: 2 === a ? 100 : 0
                        }, {scaleX: 1, scaleY: 1, xPercent: 0, yPercent: 0, ease: Fs.easeOut}, 0)
                    }
                }, {
                    key: "onPartnerRollOut", value: function () {
                        var e = event.currentTarget, t = e.querySelector(".partners__list__item__overlay"),
                            i = e.querySelector(".partners__list__item__overlay__background"),
                            n = {x: event.clientX, y: event.clientY},
                            r = this.getMouseDirection(e.getBoundingClientRect(), n);
                        Ss.killTweensOf([t, i]), (new Us).set(t, {visibility: "inherit"}).to(i, .4, {
                            scaleX: 1 === r || 3 === r ? 0 : 1,
                            scaleY: 0 === r || 2 === r ? 0 : 1,
                            xPercent: 1 === r ? 100 : 0,
                            yPercent: 2 === r ? 100 : 0,
                            ease: Fs.easeOut
                        }, 0).set(t, {clearProps: "visibility"})
                    }
                }]), t
            }(), subscribe: function (e) {
                function i(e) {
                    var t;
                    return es(this, i), (t = ls(this, rs(i).call(this, e))).sectionElementsToAnimateIn += ",.form__label,.form__submit", t
                }

                return ns(i, Cl), is(i, [{
                    key: "initPage", value: function () {
                        this.lineStepsSelector = ".form__submit", hs(rs(i.prototype), "initPage", this).call(this), this.initForm()
                    }
                }, {
                    key: "initForm", value: function () {
                        var i = this, e = this.element.querySelector(".form");
                        this.inputChangeCallback = this.onInputChange.bind(this), this.form = new qb(e), this.inputs = this.element.querySelectorAll(".form__input"), this.filledInputs = [], cs(this.inputs).forEach(function (e, t) {
                            e.addEventListener("input", i.inputChangeCallback), e.addEventListener("paste", i.inputChangeCallback), i.filledInputs[t] = 0
                        }), this.submitBorders = this.element.querySelectorAll(".form__submit__border")
                    }
                }, {
                    key: "dispose", value: function () {
                        hs(rs(i.prototype), "dispose", this).call(this), this.disposeForm()
                    }
                }, {
                    key: "disposeForm", value: function () {
                        var t = this;
                        this.form && (this.form.dispose(), cs(this.inputs).forEach(function (e) {
                            e.removeEventListener("input", t.inputChangeCallback), e.removeEventListener("paste", t.inputChangeCallback)
                        }))
                    }
                }, {
                    key: "createAnimInContent", value: function () {
                        hs(rs(i.prototype), "createAnimInContent", this).call(this);
                        var e = this.element.querySelector(".page__background");
                        this.timeline.from(e, 2, {
                            y: -40, scale: 1.5, rotationX: 25, rotationY: -7, ease: Power2.easeOut
                        }, 0).from(e, 1, {opacity: 0}, 0)
                    }
                }, {
                    key: "updateSubmitButton", value: function () {
                        var i = this.filledInputs.filter(function (e) {
                            return 1 === e
                        });
                        cs(this.submitBorders).forEach(function (e, t) {
                            e.classList.toggle("form__submit__border--filled", 1 === i[t])
                        }), this.form.element.classList.toggle("form--filled", 4 === i.length)
                    }
                }, {
                    key: "onInputChange", value: function (e) {
                        var t = e.currentTarget, i = Array.prototype.indexOf.call(this.inputs, t), n = 0 !== t.value.length,
                            r = 1 === this.filledInputs[i];
                        this.filledInputs[i] = n ? 1 : 0, t.classList.toggle("form__input--filled", n), n !== r && this.updateSubmitButton()
                    }
                }]), i
            }(), contact: function (e) {
                function t(e) {
                    return es(this, t), ls(this, rs(t).call(this, e))
                }

                return ns(t, Cl), is(t, [{
                    key: "initPage", value: function () {
                        this.sectionElementsToAnimateIn += ",.contact__col", this.lineStepsSelector = ".contact__actions", hs(rs(t.prototype), "initPage", this).call(this)
                    }
                }, {
                    key: "createAnimInContent", value: function () {
                        hs(rs(t.prototype), "createAnimInContent", this).call(this);
                        var e = this.element.querySelector(".page__background");
                        this.timeline.from(e, 4, {
                            y: -400, scale: 1.5, rotationX: 25, rotationY: -7, ease: Power4.easeOut
                        }, 0).from(e, 1, {opacity: 0}, 0)
                    }
                }]), t
            }()
        }, Zb = "URLSearchParams" in self, Jb = "Symbol" in self && "iterator" in Symbol,
        Kb = "FileReader" in self && "Blob" in self && function () {
            try {
                return new Blob, !0
            } catch (e) {
                return !1
            }
        }(), $b = "FormData" in self, ew = "ArrayBuffer" in self;
    if (ew) var tw = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
        iw = ArrayBuffer.isView || function (e) {
            return e && -1 < tw.indexOf(Object.prototype.toString.call(e))
        };

    function nw(e) {
        if ("string" != typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e)) throw new TypeError("Invalid character in header field name");
        return e.toLowerCase()
    }

    function rw(e) {
        return "string" != typeof e && (e = String(e)), e
    }

    function aw(t) {
        var e = {
            next: function () {
                var e = t.shift();
                return {done: void 0 === e, value: e}
            }
        };
        return Jb && (e[Symbol.iterator] = function () {
            return e
        }), e
    }

    function ow(t) {
        this.map = {}, t instanceof ow ? t.forEach(function (e, t) {
            this.append(t, e)
        }, this) : Array.isArray(t) ? t.forEach(function (e) {
            this.append(e[0], e[1])
        }, this) : t && Object.getOwnPropertyNames(t).forEach(function (e) {
            this.append(e, t[e])
        }, this)
    }

    function sw(e) {
        if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
        e.bodyUsed = !0
    }

    function lw(i) {
        return new Promise(function (e, t) {
            i.onload = function () {
                e(i.result)
            }, i.onerror = function () {
                t(i.error)
            }
        })
    }

    function hw(e) {
        var t = new FileReader, i = lw(t);
        return t.readAsArrayBuffer(e), i
    }

    function cw(e) {
        if (e.slice) return e.slice(0);
        var t = new Uint8Array(e.byteLength);
        return t.set(new Uint8Array(e)), t.buffer
    }

    function uw() {
        return this.bodyUsed = !1, this._initBody = function (e) {
            var t;
            (this._bodyInit = e) ? "string" == typeof e ? this._bodyText = e : Kb && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : $b && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : Zb && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : ew && Kb && ((t = e) && DataView.prototype.isPrototypeOf(t)) ? (this._bodyArrayBuffer = cw(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : ew && (ArrayBuffer.prototype.isPrototypeOf(e) || iw(e)) ? this._bodyArrayBuffer = cw(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Zb && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
        }, Kb && (this.blob = function () {
            var e = sw(this);
            if (e) return e;
            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
            if (this._bodyFormData) throw new Error("could not read FormData body as blob");
            return Promise.resolve(new Blob([this._bodyText]))
        }, this.arrayBuffer = function () {
            return this._bodyArrayBuffer ? sw(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(hw)
        }), this.text = function () {
            var e, t, i, n = sw(this);
            if (n) return n;
            if (this._bodyBlob) return e = this._bodyBlob, t = new FileReader, i = lw(t), t.readAsText(e), i;
            if (this._bodyArrayBuffer) return Promise.resolve(function (e) {
                for (var t = new Uint8Array(e), i = new Array(t.length), n = 0; n < t.length; n++) i[n] = String.fromCharCode(t[n]);
                return i.join("")
            }(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText)
        }, $b && (this.formData = function () {
            return this.text().then(fw)
        }), this.json = function () {
            return this.text().then(JSON.parse)
        }, this
    }

    ow.prototype.append = function (e, t) {
        e = nw(e), t = rw(t);
        var i = this.map[e];
        this.map[e] = i ? i + ", " + t : t
    }, ow.prototype.delete = function (e) {
        delete this.map[nw(e)]
    }, ow.prototype.get = function (e) {
        return e = nw(e), this.has(e) ? this.map[e] : null
    }, ow.prototype.has = function (e) {
        return this.map.hasOwnProperty(nw(e))
    }, ow.prototype.set = function (e, t) {
        this.map[nw(e)] = rw(t)
    }, ow.prototype.forEach = function (e, t) {
        for (var i in this.map) this.map.hasOwnProperty(i) && e.call(t, this.map[i], i, this)
    }, ow.prototype.keys = function () {
        var i = [];
        return this.forEach(function (e, t) {
            i.push(t)
        }), aw(i)
    }, ow.prototype.values = function () {
        var t = [];
        return this.forEach(function (e) {
            t.push(e)
        }), aw(t)
    }, ow.prototype.entries = function () {
        var i = [];
        return this.forEach(function (e, t) {
            i.push([t, e])
        }), aw(i)
    }, Jb && (ow.prototype[Symbol.iterator] = ow.prototype.entries);
    var pw = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

    function dw(e, t) {
        var i, n, r = (t = t || {}).body;
        if (e instanceof dw) {
            if (e.bodyUsed) throw new TypeError("Already read");
            this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new ow(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, r || null == e._bodyInit || (r = e._bodyInit, e.bodyUsed = !0)
        } else this.url = String(e);
        if (this.credentials = t.credentials || this.credentials || "same-origin", !t.headers && this.headers || (this.headers = new ow(t.headers)), this.method = (i = t.method || this.method || "GET", n = i.toUpperCase(), -1 < pw.indexOf(n) ? n : i), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && r) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(r)
    }

    function fw(e) {
        var r = new FormData;
        return e.trim().split("&").forEach(function (e) {
            if (e) {
                var t = e.split("="), i = t.shift().replace(/\+/g, " "), n = t.join("=").replace(/\+/g, " ");
                r.append(decodeURIComponent(i), decodeURIComponent(n))
            }
        }), r
    }

    function mw(e, t) {
        t || (t = {}), this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = 200 <= this.status && this.status < 300, this.statusText = "statusText" in t ? t.statusText : "OK", this.headers = new ow(t.headers), this.url = t.url || "", this._initBody(e)
    }

    dw.prototype.clone = function () {
        return new dw(this, {body: this._bodyInit})
    }, uw.call(dw.prototype), uw.call(mw.prototype), mw.prototype.clone = function () {
        return new mw(this._bodyInit, {
            status: this.status, statusText: this.statusText, headers: new ow(this.headers), url: this.url
        })
    }, mw.error = function () {
        var e = new mw(null, {status: 0, statusText: ""});
        return e.type = "error", e
    };
    var gw = [301, 302, 303, 307, 308];
    mw.redirect = function (e, t) {
        if (-1 === gw.indexOf(t)) throw new RangeError("Invalid status code");
        return new mw(null, {status: t, headers: {location: e}})
    };
    var vw = self.DOMException;
    try {
        new vw
    } catch (e) {
        (vw = function (e, t) {
            this.message = e, this.name = t;
            var i = Error(e);
            this.stack = i.stack
        }).prototype = Object.create(Error.prototype), vw.prototype.constructor = vw
    }

    function yw(r, o) {
        return new Promise(function (n, e) {
            var t = new dw(r, o);
            if (t.signal && t.signal.aborted) return e(new vw("Aborted", "AbortError"));
            var a = new XMLHttpRequest;

            function i() {
                a.abort()
            }

            a.onload = function () {
                var e, r, t = {
                    status: a.status,
                    statusText: a.statusText,
                    headers: (e = a.getAllResponseHeaders() || "", r = new ow, e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function (e) {
                        var t = e.split(":"), i = t.shift().trim();
                        if (i) {
                            var n = t.join(":").trim();
                            r.append(i, n)
                        }
                    }), r)
                };
                t.url = "responseURL" in a ? a.responseURL : t.headers.get("X-Request-URL");
                var i = "response" in a ? a.response : a.responseText;
                n(new mw(i, t))
            }, a.onerror = function () {
                e(new TypeError("Network request failed"))
            }, a.ontimeout = function () {
                e(new TypeError("Network request failed"))
            }, a.onabort = function () {
                e(new vw("Aborted", "AbortError"))
            }, a.open(t.method, t.url, !0), "include" === t.credentials ? a.withCredentials = !0 : "omit" === t.credentials && (a.withCredentials = !1), "responseType" in a && Kb && (a.responseType = "blob"), t.headers.forEach(function (e, t) {
                a.setRequestHeader(t, e)
            }), t.signal && (t.signal.addEventListener("abort", i), a.onreadystatechange = function () {
                4 === a.readyState && t.signal.removeEventListener("abort", i)
            }), a.send(void 0 === t._bodyInit ? null : t._bodyInit)
        })
    }

    yw.polyfill = !0, self.fetch || (self.fetch = yw, self.Headers = ow, self.Request = dw, self.Response = mw), Ts._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function () {
        var f, S, A, m, B = function () {
            ks.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = B.prototype.setRatio
        }, h = Ts._gsDefine.globals, g = {}, e = B.prototype = new ks("css");
        (e.constructor = B).version = "2.0.2", B.API = 2, B.defaultTransformPerspective = 0, B.defaultSkewType = "compensated", B.defaultSmoothOrigin = !0, e = "px", B.suffixMap = {
            top: e,
            right: e,
            bottom: e,
            left: e,
            width: e,
            height: e,
            fontSize: e,
            padding: e,
            margin: e,
            perspective: e,
            lineHeight: ""
        };
        var M, v, y, U, _, E, P, L, t, i, C = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
            I = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, c = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            R = /(?:\d|\-|\+|=|#|\.)*/g, O = /opacity *= *([^)]*)/i, b = /opacity:([^;]*)/i,
            a = /alpha\(opacity *=.+?\)/i, w = /^(rgb|hsl)/, o = /([A-Z])/g, s = /-([a-z])/gi,
            T = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, l = function (e, t) {
                return t.toUpperCase()
            }, d = /(?:Left|Right|Width)/i, u = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            F = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, N = /,(?=[^\)]*(?:\(|$))/gi, k = /[\s,\(]/i,
            D = Math.PI / 180, H = 180 / Math.PI, z = {}, n = {style: {}}, G = Ts.document || {
                createElement: function () {
                    return n
                }
            }, p = function (e, t) {
                return G.createElementNS ? G.createElementNS(t || "http://www.w3.org/1999/xhtml", e) : G.createElement(e)
            }, j = p("div"), V = p("img"), r = B._internals = {_specialProps: g}, X = (Ts.navigator || {}).userAgent || "",
            W = (t = X.indexOf("Android"), i = p("a"), y = -1 !== X.indexOf("Safari") && -1 === X.indexOf("Chrome") && (-1 === t || 3 < parseFloat(X.substr(t + 8, 2))), _ = y && parseFloat(X.substr(X.indexOf("Version/") + 8, 2)) < 6, U = -1 !== X.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(X) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(X)) && (E = parseFloat(RegExp.$1)), !!i && (i.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(i.style.opacity))),
            Y = function (e) {
                return O.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
            }, q = function (e) {
                Ts.console && console.log(e)
            }, Q = "", Z = "", J = function (e, t) {
                var i, n, r = (t = t || j).style;
                if (void 0 !== r[e]) return e;
                for (e = e.charAt(0).toUpperCase() + e.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; -1 < --n && void 0 === r[i[n] + e];) ;
                return 0 <= n ? (Q = "-" + (Z = 3 === n ? "ms" : i[n]).toLowerCase() + "-", Z + e) : null
            }, K = ("undefined" != typeof window ? window : G.defaultView || {
                getComputedStyle: function () {
                }
            }).getComputedStyle, $ = B.getStyle = function (e, t, i, n, r) {
                var a;
                return W || "opacity" !== t ? (!n && e.style[t] ? a = e.style[t] : (i = i || K(e)) ? a = i[t] || i.getPropertyValue(t) || i.getPropertyValue(t.replace(o, "-$1").toLowerCase()) : e.currentStyle && (a = e.currentStyle[t]), null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : Y(e)
            }, ee = r.convertToPixels = function (e, t, i, n, r) {
                if ("px" === n || !n && "lineHeight" !== t) return i;
                if ("auto" === n || !i) return 0;
                var a, o, s, l = d.test(t), h = e, c = j.style, u = i < 0, p = 1 === i;
                if (u && (i = -i), p && (i *= 100), "lineHeight" !== t || n) if ("%" === n && -1 !== t.indexOf("border")) a = i / 100 * (l ? e.clientWidth : e.clientHeight); else {
                    if (c.cssText = "border:0 solid red;position:" + $(e, "position") + ";line-height:0;", "%" !== n && h.appendChild && "v" !== n.charAt(0) && "rem" !== n) c[l ? "borderLeftWidth" : "borderTopWidth"] = i + n; else {
                        if (h = e.parentNode || G.body, -1 !== $(h, "display").indexOf("flex") && (c.position = "absolute"), o = h._gsCache, s = Ss.ticker.frame, o && l && o.time === s) return o.width * i / 100;
                        c[l ? "width" : "height"] = i + n
                    }
                    h.appendChild(j), a = parseFloat(j[l ? "offsetWidth" : "offsetHeight"]), h.removeChild(j), l && "%" === n && !1 !== B.cacheWidths && ((o = h._gsCache = h._gsCache || {}).time = s, o.width = a / i * 100), 0 !== a || r || (a = ee(e, t, i, n, !0))
                } else o = K(e).lineHeight, e.style.lineHeight = i, a = parseFloat(K(e).lineHeight), e.style.lineHeight = o;
                return p && (a /= 100), u ? -a : a
            }, te = r.calculateOffset = function (e, t, i) {
                if ("absolute" !== $(e, "position", i)) return 0;
                var n = "left" === t ? "Left" : "Top", r = $(e, "margin" + n, i);
                return e["offset" + n] - (ee(e, t, parseFloat(r), r.replace(R, "")) || 0)
            }, ie = function (e, t) {
                var i, n, r, a = {};
                if (t = t || K(e, null)) if (i = t.length) for (; -1 < --i;) -1 !== (r = t[i]).indexOf("-transform") && Oe !== r || (a[r.replace(s, l)] = t.getPropertyValue(r)); else for (i in t) -1 !== i.indexOf("Transform") && Re !== i || (a[i] = t[i]); else if (t = e.currentStyle || e.style) for (i in t) "string" == typeof i && void 0 === a[i] && (a[i.replace(s, l)] = t[i]);
                return W || (a.opacity = Y(e)), n = We(e, t, !1), a.rotation = n.rotation, a.skewX = n.skewX, a.scaleX = n.scaleX, a.scaleY = n.scaleY, a.x = n.x, a.y = n.y, Ne && (a.z = n.z, a.rotationX = n.rotationX, a.rotationY = n.rotationY, a.scaleZ = n.scaleZ), a.filters && delete a.filters, a
            }, ne = function (e, t, i, n, r) {
                var a, o, s, l = {}, h = e.style;
                for (o in i) "cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (a = i[o]) || r && r[o]) && -1 === o.indexOf("Origin") && ("number" != typeof a && "string" != typeof a || (l[o] = "auto" !== a || "left" !== o && "top" !== o ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof t[o] || "" === t[o].replace(c, "") ? a : 0 : te(e, o), void 0 !== h[o] && (s = new ye(h, o, h[o], s))));
                if (n) for (o in n) "className" !== o && (l[o] = n[o]);
                return {difs: l, firstMPT: s}
            }, re = {width: ["Left", "Right"], height: ["Top", "Bottom"]},
            ae = ["marginLeft", "marginRight", "marginTop", "marginBottom"], oe = function (e, t, i) {
                if ("svg" === (e.nodeName + "").toLowerCase()) return (i || K(e))[t] || 0;
                if (e.getCTM && je(e)) return e.getBBox()[t] || 0;
                var n = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight), r = re[t], a = r.length;
                for (i = i || K(e, null); -1 < --a;) n -= parseFloat($(e, "padding" + r[a], i, !0)) || 0, n -= parseFloat($(e, "border" + r[a] + "Width", i, !0)) || 0;
                return n
            }, se = function (e, t) {
                if ("contain" === e || "auto" === e || "auto auto" === e) return e + " ";
                null != e && "" !== e || (e = "0 0");
                var i, n = e.split(" "), r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : n[0],
                    a = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : n[1];
                if (3 < n.length && !t) {
                    for (n = e.split(", ").join(",").split(","), e = [], i = 0; i < n.length; i++) e.push(se(n[i]));
                    return e.join(",")
                }
                return null == a ? a = "center" === r ? "50%" : "0" : "center" === a && (a = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), e = r + " " + a + (2 < n.length ? " " + n[2] : ""), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== a.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === a.charAt(1), t.ox = parseFloat(r.replace(c, "")), t.oy = parseFloat(a.replace(c, "")), t.v = e), t || e
            }, le = function (e, t) {
                return "function" == typeof e && (e = e(L, P)), "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t) || 0
            }, he = function (e, t) {
                "function" == typeof e && (e = e(L, P));
                var i = "string" == typeof e && "=" === e.charAt(1);
                return "string" == typeof e && "v" === e.charAt(e.length - 2) && (e = (i ? e.substr(0, 2) : 0) + window["inner" + ("vh" === e.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? e.substr(2) : e) / 100)), null == e ? t : i ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e) || 0
            }, ce = function (e, t, i, n) {
                var r, a, o, s;
                return "function" == typeof e && (e = e(L, P)), (o = null == e ? t : "number" == typeof e ? e : (360, r = e.split("_"), a = ((s = "=" === e.charAt(1)) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(r[0].substr(2)) : parseFloat(r[0])) * (-1 === e.indexOf("rad") ? 1 : H) - (s ? 0 : t), r.length && (n && (n[i] = t + a), -1 !== e.indexOf("short") && (a %= 360) !== a % 180 && (a = a < 0 ? a + 360 : a - 360), -1 !== e.indexOf("_cw") && a < 0 ? a = (a + 3599999999640) % 360 - 360 * (a / 360 | 0) : -1 !== e.indexOf("ccw") && 0 < a && (a = (a - 3599999999640) % 360 - 360 * (a / 360 | 0))), t + a)) < 1e-6 && -1e-6 < o && (o = 0), o
            }, ue = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            }, pe = function (e, t, i) {
                return 255 * (6 * (e = e < 0 ? e + 1 : 1 < e ? e - 1 : e) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) + .5 | 0
            }, de = B.parseColor = function (e, t) {
                var i, n, r, a, o, s, l, h, c, u, p;
                if (e) if ("number" == typeof e) i = [e >> 16, e >> 8 & 255, 255 & e]; else {
                    if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), ue[e]) i = ue[e]; else if ("#" === e.charAt(0)) 4 === e.length && (e = "#" + (n = e.charAt(1)) + n + (r = e.charAt(2)) + r + (a = e.charAt(3)) + a), i = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e]; else if ("hsl" === e.substr(0, 3)) if (i = p = e.match(C), t) {
                        if (-1 !== e.indexOf("=")) return e.match(I)
                    } else o = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), 3 < i.length && (i[3] = Number(i[3])), i[0] = pe(o + 1 / 3, n, r), i[1] = pe(o, n, r), i[2] = pe(o - 1 / 3, n, r); else i = e.match(C) || ue.transparent;
                    i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), 3 < i.length && (i[3] = Number(i[3]))
                } else i = ue.black;
                return t && !p && (n = i[0] / 255, r = i[1] / 255, a = i[2] / 255, l = ((h = Math.max(n, r, a)) + (c = Math.min(n, r, a))) / 2, h === c ? o = s = 0 : (u = h - c, s = .5 < l ? u / (2 - h - c) : u / (h + c), o = h === n ? (r - a) / u + (r < a ? 6 : 0) : h === r ? (a - n) / u + 2 : (n - r) / u + 4, o *= 60), i[0] = o + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
            }, fe = function (e, t) {
                var i, n, r, a = e.match(me) || [], o = 0, s = "";
                if (!a.length) return e;
                for (i = 0; i < a.length; i++) n = a[i], o += (r = e.substr(o, e.indexOf(n, o) - o)).length + n.length, 3 === (n = de(n, t)).length && n.push(1), s += r + (t ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                return s + e.substr(o)
            }, me = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (e in ue) me += "|" + e + "\\b";
        me = new RegExp(me + ")", "gi"), B.colorStringFilter = function (e) {
            var t, i = e[0] + " " + e[1];
            me.test(i) && (t = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), e[0] = fe(e[0], t), e[1] = fe(e[1], t)), me.lastIndex = 0
        }, Ss.defaultStringFilter || (Ss.defaultStringFilter = B.colorStringFilter);
        var ge = function (e, t, a, o) {
            if (null == e) return function (e) {
                return e
            };
            var s, l = t ? (e.match(me) || [""])[0] : "", h = e.split(l).join("").match(x) || [],
                c = e.substr(0, e.indexOf(h[0])), u = ")" === e.charAt(e.length - 1) ? ")" : "",
                p = -1 !== e.indexOf(" ") ? " " : ",", d = h.length, f = 0 < d ? h[0].replace(C, "") : "";
            return d ? s = t ? function (e) {
                var t, i, n, r;
                if ("number" == typeof e) e += f; else if (o && N.test(e)) {
                    for (r = e.replace(N, "|").split("|"), n = 0; n < r.length; n++) r[n] = s(r[n]);
                    return r.join(",")
                }
                if (t = (e.match(me) || [l])[0], n = (i = e.split(t).join("").match(x) || []).length, d > n--) for (; ++n < d;) i[n] = a ? i[(n - 1) / 2 | 0] : h[n];
                return c + i.join(p) + p + t + u + (-1 !== e.indexOf("inset") ? " inset" : "")
            } : function (e) {
                var t, i, n;
                if ("number" == typeof e) e += f; else if (o && N.test(e)) {
                    for (i = e.replace(N, "|").split("|"), n = 0; n < i.length; n++) i[n] = s(i[n]);
                    return i.join(",")
                }
                if (n = (t = e.match(x) || []).length, d > n--) for (; ++n < d;) t[n] = a ? t[(n - 1) / 2 | 0] : h[n];
                return c + t.join(p) + u
            } : function (e) {
                return e
            }
        }, ve = function (h) {
            return h = h.split(","), function (e, t, i, n, r, a, o) {
                var s, l = (t + "").split(" ");
                for (o = {}, s = 0; s < 4; s++) o[h[s]] = l[s] = l[s] || l[(s - 1) / 2 >> 0];
                return n.parse(e, o, r, a)
            }
        }, ye = (r._setPluginRatio = function (e) {
            this.plugin.setRatio(e);
            for (var t, i, n, r, a, o = this.data, s = o.proxy, l = o.firstMPT; l;) t = s[l.v], l.r ? t = l.r(t) : t < 1e-6 && -1e-6 < t && (t = 0), l.t[l.p] = t, l = l._next;
            if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === e || 0 === e) for (l = o.firstMPT, a = 1 === e ? "e" : "b"; l;) {
                if ((i = l.t).type) {
                    if (1 === i.type) {
                        for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                        i[a] = r
                    }
                } else i[a] = i.s + i.xs0;
                l = l._next
            }
        }, function (e, t, i, n, r) {
            this.t = e, this.p = t, this.v = i, this.r = r, n && ((n._prev = this)._next = n)
        }), _e = (r._parseToProxy = function (e, t, i, n, r, a) {
            var o, s, l, h, c, u = n, p = {}, d = {}, f = i._transform, m = z;
            for (i._transform = null, z = t, n = c = i.parse(e, t, n, r), z = m, a && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                if (n.type <= 1 && (d[s = n.p] = n.s + n.c, p[s] = n.s, a || (h = new ye(n, "s", s, h, n.r), n.c = 0), 1 === n.type)) for (o = n.l; 0 < --o;) l = "xn" + o, d[s = n.p + "_" + l] = n.data[l], p[s] = n[l], a || (h = new ye(n, l, s, h, n.rxp[l]));
                n = n._next
            }
            return {proxy: p, end: d, firstMPT: h, pt: c}
        }, r.CSSPropTween = function (e, t, i, n, r, a, o, s, l, h, c) {
            this.t = e, this.p = t, this.s = i, this.c = n, this.n = o || t, e instanceof _e || m.push(this.n), this.r = s ? "function" == typeof s ? s : Math.round : s, this.type = a || 0, l && (this.pr = l, f = !0), this.b = void 0 === h ? i : h, this.e = void 0 === c ? i + n : c, r && ((this._next = r)._prev = this)
        }), xe = function (e, t, i, n, r, a) {
            var o = new _e(e, t, i, n - i, r, -1, a);
            return o.b = i, o.e = o.xs0 = n, o
        }, be = B.parseComplex = function (e, t, i, n, r, a, o, s, l, h) {
            i = i || a || "", "function" == typeof n && (n = n(L, P)), o = new _e(e, t, 0, 0, o, h ? 2 : 1, null, !1, s, i, n), n += "", r && me.test(n + i) && (n = [i, n], B.colorStringFilter(n), i = n[0], n = n[1]);
            var c, u, p, d, f, m, g, v, y, _, x, b, w, T = i.split(", ").join(",").split(" "),
                S = n.split(", ").join(",").split(" "), E = T.length, A = !1 !== M;
            for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (S = -1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (T = T.join(" ").replace(N, ", ").split(" "), S.join(" ").replace(N, ", ").split(" ")) : (T = T.join(" ").split(",").join(", ").split(" "), S.join(" ").split(",").join(", ").split(" ")), E = T.length), E !== S.length && (E = (T = (a || "").split(" ")).length), o.plugin = l, o.setRatio = h, c = me.lastIndex = 0; c < E; c++) if (d = T[c], f = S[c] + "", (v = parseFloat(d)) || 0 === v) o.appendXtra("", v, le(f, v), f.replace(I, ""), !(!A || -1 === f.indexOf("px")) && Math.round, !0); else if (r && me.test(d)) b = ")" + ((b = f.indexOf(")") + 1) ? f.substr(b) : ""), w = -1 !== f.indexOf("hsl") && W, _ = f, d = de(d, w), f = de(f, w), (y = 6 < d.length + f.length) && !W && 0 === f[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(S[c]).join("transparent")) : (W || (y = !1), w ? o.appendXtra(_.substr(0, _.indexOf("hsl")) + (y ? "hsla(" : "hsl("), d[0], le(f[0], d[0]), ",", !1, !0).appendXtra("", d[1], le(f[1], d[1]), "%,", !1).appendXtra("", d[2], le(f[2], d[2]), y ? "%," : "%" + b, !1) : o.appendXtra(_.substr(0, _.indexOf("rgb")) + (y ? "rgba(" : "rgb("), d[0], f[0] - d[0], ",", Math.round, !0).appendXtra("", d[1], f[1] - d[1], ",", Math.round).appendXtra("", d[2], f[2] - d[2], y ? "," : b, Math.round), y && (d = d.length < 4 ? 1 : d[3], o.appendXtra("", d, (f.length < 4 ? 1 : f[3]) - d, b, !1))), me.lastIndex = 0; else if (m = d.match(C)) {
                if (!(g = f.match(I)) || g.length !== m.length) return o;
                for (u = p = 0; u < m.length; u++) x = m[u], _ = d.indexOf(x, p), o.appendXtra(d.substr(p, _ - p), Number(x), le(g[u], x), "", !(!A || "px" !== d.substr(_ + x.length, 2)) && Math.round, 0 === u), p = _ + x.length;
                o["xs" + o.l] += d.substr(p)
            } else o["xs" + o.l] += o.l || o["xs" + o.l] ? " " + f : f;
            if (-1 !== n.indexOf("=") && o.data) {
                for (b = o.xs0 + o.data.s, c = 1; c < o.l; c++) b += o["xs" + c] + o.data["xn" + c];
                o.e = b + o["xs" + c]
            }
            return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o
        }, we = 9;
        for ((e = _e.prototype).l = e.pr = 0; 0 < --we;) e["xn" + we] = 0, e["xs" + we] = "";
        e.xs0 = "", e._next = e._prev = e.xfirst = e.data = e.plugin = e.setRatio = e.rxp = null, e.appendXtra = function (e, t, i, n, r, a) {
            var o = this, s = o.l;
            return o["xs" + s] += a && (s || o["xs" + s]) ? " " + e : e || "", i || 0 === s || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = n || "", 0 < s ? (o.data["xn" + s] = t + i, o.rxp["xn" + s] = r, o["xn" + s] = t, o.plugin || (o.xfirst = new _e(o, "xn" + s, t, i, o.xfirst || o, 0, o.n, r, o.pr), o.xfirst.xs0 = 0)) : (o.data = {s: t + i}, o.rxp = {}, o.s = t, o.c = i, o.r = r), o) : (o["xs" + s] += t + (n || ""), o)
        };
        var Te = function (e, t) {
            t = t || {}, this.p = t.prefix && J(e) || e, g[e] = g[this.p] = this, this.format = t.formatter || ge(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
        }, Se = r._registerComplexSpecialProp = function (e, t, i) {
            "object" != typeof t && (t = {parser: i});
            var n, r = e.split(","), a = t.defaultValue;
            for (i = i || [a], n = 0; n < r.length; n++) t.prefix = 0 === n && t.prefix, t.defaultValue = i[n] || a, new Te(r[n], t)
        }, Ee = r._registerPluginProp = function (e) {
            if (!g[e]) {
                var l = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                Se(e, {
                    parser: function (e, t, i, n, r, a, o) {
                        var s = h.com.greensock.plugins[l];
                        return s ? (s._cssRegister(), g[i].parse(e, t, i, n, r, a, o)) : (q("Error: " + l + " js file not loaded."), r)
                    }
                })
            }
        };
        (e = Te.prototype).parseComplex = function (e, t, i, n, r, a) {
            var o, s, l, h, c, u, p = this.keyword;
            if (this.multi && (N.test(i) || N.test(t) ? (s = t.replace(N, "|").split("|"), l = i.replace(N, "|").split("|")) : p && (s = [t], l = [i])), l) {
                for (h = l.length > s.length ? l.length : s.length, o = 0; o < h; o++) t = s[o] = s[o] || this.dflt, i = l[o] = l[o] || this.dflt, p && (c = t.indexOf(p)) !== (u = i.indexOf(p)) && (-1 === u ? s[o] = s[o].split(p).join("") : -1 === c && (s[o] += " " + p));
                t = s.join(", "), i = l.join(", ")
            }
            return be(e, this.p, t, i, this.clrs, this.dflt, n, this.pr, r, a)
        }, e.parse = function (e, t, i, n, r, a, o) {
            return this.parseComplex(e.style, this.format($(e, this.p, A, !1, this.dflt)), this.format(t), r, a)
        }, B.registerSpecialProp = function (e, l, h) {
            Se(e, {
                parser: function (e, t, i, n, r, a, o) {
                    var s = new _e(e, i, 0, 0, r, 2, i, !1, h);
                    return s.plugin = a, s.setRatio = l(e, t, n._tween, i), s
                }, priority: h
            })
        }, B.useSVGTransformAttr = !0;
        var Ae, Me, Pe, Le, Ce,
            Ie = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
            Re = J("transform"), Oe = Q + "transform", Fe = J("transformOrigin"), Ne = null !== J("perspective"),
            ke = r.Transform = function () {
                this.perspective = parseFloat(B.defaultTransformPerspective) || 0, this.force3D = !(!1 === B.defaultForce3D || !Ne) && (B.defaultForce3D || "auto")
            }, Ue = Ts.SVGElement, De = function (e, t, i) {
                var n, r = G.createElementNS("http://www.w3.org/2000/svg", e), a = /([a-z])([A-Z])/g;
                for (n in i) r.setAttributeNS(null, n.replace(a, "$1-$2").toLowerCase(), i[n]);
                return t.appendChild(r), r
            }, ze = G.documentElement || {},
            Be = (Ce = E || /Android/i.test(X) && !Ts.chrome, G.createElementNS && !Ce && (Me = De("svg", ze), Le = (Pe = De("rect", Me, {
                width: 100, height: 50, x: 100
            })).getBoundingClientRect().width, Pe.style[Fe] = "50% 50%", Pe.style[Re] = "scaleX(0.5)", Ce = Le === Pe.getBoundingClientRect().width && !(U && Ne), ze.removeChild(Me)), Ce),
            He = function (e, t, i, n, r, a) {
                var o, s, l, h, c, u, p, d, f, m, g, v, y, _, x = e._gsTransform, b = Xe(e, !0);
                x && (y = x.xOrigin, _ = x.yOrigin), (!n || (o = n.split(" ")).length < 2) && (0 === (p = e.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = {
                    x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
                    y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
                    width: 0,
                    height: 0
                }), o = [(-1 !== (t = se(t).split(" "))[0].indexOf("%") ? parseFloat(t[0]) / 100 * p.width : parseFloat(t[0])) + p.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * p.height : parseFloat(t[1])) + p.y]), i.xOrigin = h = parseFloat(o[0]), i.yOrigin = c = parseFloat(o[1]), n && b !== Ve && (u = b[0], p = b[1], d = b[2], f = b[3], m = b[4], g = b[5], (v = u * f - p * d) && (s = h * (f / v) + c * (-d / v) + (d * g - f * m) / v, l = h * (-p / v) + c * (u / v) - (u * g - p * m) / v, h = i.xOrigin = o[0] = s, c = i.yOrigin = o[1] = l)), x && (a && (i.xOffset = x.xOffset, i.yOffset = x.yOffset, x = i), r || !1 !== r && !1 !== B.defaultSmoothOrigin ? (s = h - y, l = c - _, x.xOffset += s * b[0] + l * b[2] - s, x.yOffset += s * b[1] + l * b[3] - l) : x.xOffset = x.yOffset = 0), a || e.setAttribute("data-svg-origin", o.join(" "))
            }, Ge = function (e) {
                var t,
                    i = p("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode, r = this.nextSibling, a = this.style.cssText;
                if (ze.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                    t = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ge
                } catch (e) {
                } else this._originalGetBBox && (t = this._originalGetBBox());
                return r ? n.insertBefore(this, r) : n.appendChild(this), ze.removeChild(i), this.style.cssText = a, t
            }, je = function (e) {
                return !(!Ue || !e.getCTM || e.parentNode && !e.ownerSVGElement || !function (t) {
                    try {
                        return t.getBBox()
                    } catch (e) {
                        return Ge.call(t, !0)
                    }
                }(e))
            }, Ve = [1, 0, 0, 1, 0, 0], Xe = function (e, t) {
                var i, n, r, a, o, s, l = e._gsTransform || new ke, h = e.style;
                if (Re ? n = $(e, Oe, null, !0) : e.currentStyle && (n = (n = e.currentStyle.filter.match(u)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, !Re || !(s = !K(e) || "none" === K(e).display) && e.parentNode || (s && (a = h.display, h.display = "block"), e.parentNode || (o = 1, ze.appendChild(e)), i = !(n = $(e, Oe, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, a ? h.display = a : s && Ze(h, "display"), o && ze.removeChild(e)), (l.svg || e.getCTM && je(e)) && (i && -1 !== (h[Re] + "").indexOf("matrix") && (n = h[Re], i = 0), r = e.getAttribute("transform"), i && r && (n = "matrix(" + (r = e.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return Ve;
                for (r = (n || "").match(C) || [], we = r.length; -1 < --we;) a = Number(r[we]), r[we] = (o = a - (a |= 0)) ? (1e5 * o + (o < 0 ? -.5 : .5) | 0) / 1e5 + a : a;
                return t && 6 < r.length ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
            }, We = r.getTransform = function (e, t, i, n) {
                if (e._gsTransform && i && !n) return e._gsTransform;
                var r, a, o, s, l, h, c = i && e._gsTransform || new ke, u = c.scaleX < 0,
                    p = Ne && (parseFloat($(e, Fe, t, !1, "0 0 0").split(" ")[2]) || c.zOrigin) || 0,
                    d = parseFloat(B.defaultTransformPerspective) || 0;
                if (c.svg = !(!e.getCTM || !je(e)), c.svg && (He(e, $(e, Fe, t, !1, "50% 50%") + "", c, e.getAttribute("data-svg-origin")), Ae = B.useSVGTransformAttr || Be), (r = Xe(e)) !== Ve) {
                    if (16 === r.length) {
                        var f, m, g, v, y, _ = r[0], x = r[1], b = r[2], w = r[3], T = r[4], S = r[5], E = r[6], A = r[7],
                            M = r[8], P = r[9], L = r[10], C = r[12], I = r[13], R = r[14], O = r[11], F = Math.atan2(E, L);
                        c.zOrigin && (C = M * (R = -c.zOrigin) - r[12], I = P * R - r[13], R = L * R + c.zOrigin - r[14]), c.rotationX = F * H, F && (f = T * (v = Math.cos(-F)) + M * (y = Math.sin(-F)), m = S * v + P * y, g = E * v + L * y, M = T * -y + M * v, P = S * -y + P * v, L = E * -y + L * v, O = A * -y + O * v, T = f, S = m, E = g), F = Math.atan2(-b, L), c.rotationY = F * H, F && (m = x * (v = Math.cos(-F)) - P * (y = Math.sin(-F)), g = b * v - L * y, P = x * y + P * v, L = b * y + L * v, O = w * y + O * v, _ = f = _ * v - M * y, x = m, b = g), F = Math.atan2(x, _), c.rotation = F * H, F && (f = _ * (v = Math.cos(F)) + x * (y = Math.sin(F)), m = T * v + S * y, g = M * v + P * y, x = x * v - _ * y, S = S * v - T * y, P = P * v - M * y, _ = f, T = m, M = g), c.rotationX && 359.9 < Math.abs(c.rotationX) + Math.abs(c.rotation) && (c.rotationX = c.rotation = 0, c.rotationY = 180 - c.rotationY), F = Math.atan2(T, S), c.scaleX = (1e5 * Math.sqrt(_ * _ + x * x + b * b) + .5 | 0) / 1e5, c.scaleY = (1e5 * Math.sqrt(S * S + E * E) + .5 | 0) / 1e5, c.scaleZ = (1e5 * Math.sqrt(M * M + P * P + L * L) + .5 | 0) / 1e5, _ /= c.scaleX, T /= c.scaleY, x /= c.scaleX, S /= c.scaleY, 2e-5 < Math.abs(F) ? (c.skewX = F * H, T = 0, "simple" !== c.skewType && (c.scaleY *= 1 / Math.cos(F))) : c.skewX = 0, c.perspective = O ? 1 / (O < 0 ? -O : O) : 0, c.x = C, c.y = I, c.z = R, c.svg && (c.x -= c.xOrigin - (c.xOrigin * _ - c.yOrigin * T), c.y -= c.yOrigin - (c.yOrigin * x - c.xOrigin * S))
                    } else if (!Ne || n || !r.length || c.x !== r[4] || c.y !== r[5] || !c.rotationX && !c.rotationY) {
                        var N = 6 <= r.length, k = N ? r[0] : 1, U = r[1] || 0, D = r[2] || 0, z = N ? r[3] : 1;
                        c.x = r[4] || 0, c.y = r[5] || 0, o = Math.sqrt(k * k + U * U), s = Math.sqrt(z * z + D * D), l = k || U ? Math.atan2(U, k) * H : c.rotation || 0, h = D || z ? Math.atan2(D, z) * H + l : c.skewX || 0, c.scaleX = o, c.scaleY = s, c.rotation = l, c.skewX = h, Ne && (c.rotationX = c.rotationY = c.z = 0, c.perspective = d, c.scaleZ = 1), c.svg && (c.x -= c.xOrigin - (c.xOrigin * k + c.yOrigin * D), c.y -= c.yOrigin - (c.xOrigin * U + c.yOrigin * z))
                    }
                    for (a in 90 < Math.abs(c.skewX) && Math.abs(c.skewX) < 270 && (u ? (c.scaleX *= -1, c.skewX += c.rotation <= 0 ? 180 : -180, c.rotation += c.rotation <= 0 ? 180 : -180) : (c.scaleY *= -1, c.skewX += c.skewX <= 0 ? 180 : -180)), c.zOrigin = p, c) c[a] < 2e-5 && -2e-5 < c[a] && (c[a] = 0)
                }
                return i && (e._gsTransform = c).svg && (Ae && e.style[Re] ? Ss.delayedCall(.001, function () {
                    Ze(e.style, Re)
                }) : !Ae && e.getAttribute("transform") && Ss.delayedCall(.001, function () {
                    e.removeAttribute("transform")
                })), c
            }, Ye = function (e) {
                var t, i, n = this.data, r = -n.rotation * D, a = r + n.skewX * D,
                    o = (Math.cos(r) * n.scaleX * 1e5 | 0) / 1e5, s = (Math.sin(r) * n.scaleX * 1e5 | 0) / 1e5,
                    l = (Math.sin(a) * -n.scaleY * 1e5 | 0) / 1e5, h = (Math.cos(a) * n.scaleY * 1e5 | 0) / 1e5,
                    c = this.t.style, u = this.t.currentStyle;
                if (u) {
                    i = s, s = -l, l = -i, t = u.filter, c.filter = "";
                    var p, d, f = this.t.offsetWidth, m = this.t.offsetHeight, g = "absolute" !== u.position,
                        v = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + s + ", M21=" + l + ", M22=" + h,
                        y = n.x + f * n.xPercent / 100, _ = n.y + m * n.yPercent / 100;
                    if (null != n.ox && (y += (p = (n.oxp ? f * n.ox * .01 : n.ox) - f / 2) - (p * o + (d = (n.oyp ? m * n.oy * .01 : n.oy) - m / 2) * s), _ += d - (p * l + d * h)), v += g ? ", Dx=" + ((p = f / 2) - (p * o + (d = m / 2) * s) + y) + ", Dy=" + (d - (p * l + d * h) + _) + ")" : ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = t.replace(F, v) : c.filter = v + " " + t, 0 !== e && 1 !== e || 1 === o && 0 === s && 0 === l && 1 === h && (g && -1 === v.indexOf("Dx=0, Dy=0") || O.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && c.removeAttribute("filter")), !g) {
                        var x, b, w, T = E < 8 ? 1 : -1;
                        for (p = n.ieOffsetX || 0, d = n.ieOffsetY || 0, n.ieOffsetX = Math.round((f - ((o < 0 ? -o : o) * f + (s < 0 ? -s : s) * m)) / 2 + y), n.ieOffsetY = Math.round((m - ((h < 0 ? -h : h) * m + (l < 0 ? -l : l) * f)) / 2 + _), we = 0; we < 4; we++) w = (i = -1 !== (x = u[b = ae[we]]).indexOf("px") ? parseFloat(x) : ee(this.t, b, parseFloat(x), x.replace(R, "")) || 0) !== n[b] ? we < 2 ? -n.ieOffsetX : -n.ieOffsetY : we < 2 ? p - n.ieOffsetX : d - n.ieOffsetY, c[b] = (n[b] = Math.round(i - w * (0 === we || 2 === we ? 1 : T))) + "px"
                    }
                }
            }, qe = r.set3DTransformRatio = r.setTransformRatio = function (e) {
                var t, i, n, r, a, o, s, l, h, c, u, p, d, f, m, g, v, y, _, x, b = this.data, w = this.t.style,
                    T = b.rotation, S = b.rotationX, E = b.rotationY, A = b.scaleX, M = b.scaleY, P = b.scaleZ, L = b.x,
                    C = b.y, I = b.z, R = b.svg, O = b.perspective, F = b.force3D, N = b.skewY, k = b.skewX;
                if (N && (k += N, T += N), !((1 !== e && 0 !== e || "auto" !== F || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && F || I || O || E || S || 1 !== P) || Ae && R || !Ne) T || k || R ? (T *= D, x = k * D, 1e5, i = Math.cos(T) * A, a = Math.sin(T) * A, n = Math.sin(T - x) * -M, o = Math.cos(T - x) * M, x && "simple" === b.skewType && (t = Math.tan(x - N * D), n *= t = Math.sqrt(1 + t * t), o *= t, N && (t = Math.tan(N * D), i *= t = Math.sqrt(1 + t * t), a *= t)), R && (L += b.xOrigin - (b.xOrigin * i + b.yOrigin * n) + b.xOffset, C += b.yOrigin - (b.xOrigin * a + b.yOrigin * o) + b.yOffset, Ae && (b.xPercent || b.yPercent) && (m = this.t.getBBox(), L += .01 * b.xPercent * m.width, C += .01 * b.yPercent * m.height), L < (m = 1e-6) && -m < L && (L = 0), C < m && -m < C && (C = 0)), _ = (1e5 * i | 0) / 1e5 + "," + (1e5 * a | 0) / 1e5 + "," + (1e5 * n | 0) / 1e5 + "," + (1e5 * o | 0) / 1e5 + "," + L + "," + C + ")", R && Ae ? this.t.setAttribute("transform", "matrix(" + _) : w[Re] = (b.xPercent || b.yPercent ? "translate(" + b.xPercent + "%," + b.yPercent + "%) matrix(" : "matrix(") + _) : w[Re] = (b.xPercent || b.yPercent ? "translate(" + b.xPercent + "%," + b.yPercent + "%) matrix(" : "matrix(") + A + ",0,0," + M + "," + L + "," + C + ")"; else {
                    if (U && (A < (m = 1e-4) && -m < A && (A = P = 2e-5), M < m && -m < M && (M = P = 2e-5), !O || b.z || b.rotationX || b.rotationY || (O = 0)), T || k) T *= D, g = i = Math.cos(T), v = a = Math.sin(T), k && (T -= k * D, g = Math.cos(T), v = Math.sin(T), "simple" === b.skewType && (t = Math.tan((k - N) * D), g *= t = Math.sqrt(1 + t * t), v *= t, b.skewY && (t = Math.tan(N * D), i *= t = Math.sqrt(1 + t * t), a *= t))), n = -v, o = g; else {
                        if (!(E || S || 1 !== P || O || R)) return void (w[Re] = (b.xPercent || b.yPercent ? "translate(" + b.xPercent + "%," + b.yPercent + "%) translate3d(" : "translate3d(") + L + "px," + C + "px," + I + "px)" + (1 !== A || 1 !== M ? " scale(" + A + "," + M + ")" : ""));
                        i = o = 1, n = a = 0
                    }
                    c = 1, r = s = l = h = u = p = 0, d = O ? -1 / O : 0, f = b.zOrigin, m = 1e-6, ",", "0", (T = E * D) && (g = Math.cos(T), u = d * (l = -(v = Math.sin(T))), r = i * v, s = a * v, d *= c = g, i *= g, a *= g), (T = S * D) && (t = n * (g = Math.cos(T)) + r * (v = Math.sin(T)), y = o * g + s * v, h = c * v, p = d * v, r = n * -v + r * g, s = o * -v + s * g, c *= g, d *= g, n = t, o = y), 1 !== P && (r *= P, s *= P, c *= P, d *= P), 1 !== M && (n *= M, o *= M, h *= M, p *= M), 1 !== A && (i *= A, a *= A, l *= A, u *= A), (f || R) && (f && (L += r * -f, C += s * -f, I += c * -f + f), R && (L += b.xOrigin - (b.xOrigin * i + b.yOrigin * n) + b.xOffset, C += b.yOrigin - (b.xOrigin * a + b.yOrigin * o) + b.yOffset), L < m && -m < L && (L = "0"), C < m && -m < C && (C = "0"), I < m && -m < I && (I = 0)), _ = b.xPercent || b.yPercent ? "translate(" + b.xPercent + "%," + b.yPercent + "%) matrix3d(" : "matrix3d(", _ += (i < m && -m < i ? "0" : i) + "," + (a < m && -m < a ? "0" : a) + "," + (l < m && -m < l ? "0" : l), _ += "," + (u < m && -m < u ? "0" : u) + "," + (n < m && -m < n ? "0" : n) + "," + (o < m && -m < o ? "0" : o), S || E || 1 !== P ? (_ += "," + (h < m && -m < h ? "0" : h) + "," + (p < m && -m < p ? "0" : p) + "," + (r < m && -m < r ? "0" : r), _ += "," + (s < m && -m < s ? "0" : s) + "," + (c < m && -m < c ? "0" : c) + "," + (d < m && -m < d ? "0" : d) + ",") : _ += ",0,0,0,0,1,0,", _ += L + "," + C + "," + I + "," + (O ? 1 + -I / O : 1) + ")", w[Re] = _
                }
            };
        (e = ke.prototype).x = e.y = e.z = e.skewX = e.skewY = e.rotation = e.rotationX = e.rotationY = e.zOrigin = e.xPercent = e.yPercent = e.xOffset = e.yOffset = 0, e.scaleX = e.scaleY = e.scaleZ = 1, Se("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function (e, t, i, n, r, a, o) {
                if (n._lastParsedTransform === o) return r;
                var s, l = (n._lastParsedTransform = o).scale && "function" == typeof o.scale ? o.scale : 0;
                "function" == typeof o[i] && (s = o[i], o[i] = t), l && (o.scale = l(L, e));
                var h, c, u, p, d, f, m, g, v, y = e._gsTransform, _ = e.style, x = Ie.length, b = o, w = {},
                    T = "transformOrigin", S = We(e, A, !0, b.parseTransform),
                    E = b.transform && ("function" == typeof b.transform ? b.transform(L, P) : b.transform);
                if (S.skewType = b.skewType || S.skewType || B.defaultSkewType, n._transform = S, "rotationZ" in b && (b.rotation = b.rotationZ), E && "string" == typeof E && Re) (c = j.style)[Re] = E, c.display = "block", c.position = "absolute", -1 !== E.indexOf("%") && (c.width = $(e, "width"), c.height = $(e, "height")), G.body.appendChild(j), h = We(j, null, !1), "simple" === S.skewType && (h.scaleY *= Math.cos(h.skewX * D)), S.svg && (f = S.xOrigin, m = S.yOrigin, h.x -= S.xOffset, h.y -= S.yOffset, (b.transformOrigin || b.svgOrigin) && (E = {}, He(e, se(b.transformOrigin), E, b.svgOrigin, b.smoothOrigin, !0), f = E.xOrigin, m = E.yOrigin, h.x -= E.xOffset - S.xOffset, h.y -= E.yOffset - S.yOffset), (f || m) && (g = Xe(j, !0), h.x -= f - (f * g[0] + m * g[2]), h.y -= m - (f * g[1] + m * g[3]))), G.body.removeChild(j), h.perspective || (h.perspective = S.perspective), null != b.xPercent && (h.xPercent = he(b.xPercent, S.xPercent)), null != b.yPercent && (h.yPercent = he(b.yPercent, S.yPercent)); else if ("object" == typeof b) {
                    if (h = {
                        scaleX: he(null != b.scaleX ? b.scaleX : b.scale, S.scaleX),
                        scaleY: he(null != b.scaleY ? b.scaleY : b.scale, S.scaleY),
                        scaleZ: he(b.scaleZ, S.scaleZ),
                        x: he(b.x, S.x),
                        y: he(b.y, S.y),
                        z: he(b.z, S.z),
                        xPercent: he(b.xPercent, S.xPercent),
                        yPercent: he(b.yPercent, S.yPercent),
                        perspective: he(b.transformPerspective, S.perspective)
                    }, null != (d = b.directionalRotation)) if ("object" == typeof d) for (c in d) b[c] = d[c]; else b.rotation = d;
                    "string" == typeof b.x && -1 !== b.x.indexOf("%") && (h.x = 0, h.xPercent = he(b.x, S.xPercent)), "string" == typeof b.y && -1 !== b.y.indexOf("%") && (h.y = 0, h.yPercent = he(b.y, S.yPercent)), h.rotation = ce("rotation" in b ? b.rotation : "shortRotation" in b ? b.shortRotation + "_short" : S.rotation, S.rotation, "rotation", w), Ne && (h.rotationX = ce("rotationX" in b ? b.rotationX : "shortRotationX" in b ? b.shortRotationX + "_short" : S.rotationX || 0, S.rotationX, "rotationX", w), h.rotationY = ce("rotationY" in b ? b.rotationY : "shortRotationY" in b ? b.shortRotationY + "_short" : S.rotationY || 0, S.rotationY, "rotationY", w)), h.skewX = ce(b.skewX, S.skewX), h.skewY = ce(b.skewY, S.skewY)
                }
                for (Ne && null != b.force3D && (S.force3D = b.force3D, p = !0), (u = S.force3D || S.z || S.rotationX || S.rotationY || h.z || h.rotationX || h.rotationY || h.perspective) || null == b.scale || (h.scaleZ = 1); -1 < --x;) (1e-6 < (E = h[v = Ie[x]] - S[v]) || E < -1e-6 || null != b[v] || null != z[v]) && (p = !0, r = new _e(S, v, S[v], E, r), v in w && (r.e = w[v]), r.xs0 = 0, r.plugin = a, n._overwriteProps.push(r.n));
                return E = b.transformOrigin, S.svg && (E || b.svgOrigin) && (f = S.xOffset, m = S.yOffset, He(e, se(E), h, b.svgOrigin, b.smoothOrigin), r = xe(S, "xOrigin", (y ? S : h).xOrigin, h.xOrigin, r, T), r = xe(S, "yOrigin", (y ? S : h).yOrigin, h.yOrigin, r, T), f === S.xOffset && m === S.yOffset || (r = xe(S, "xOffset", y ? f : S.xOffset, S.xOffset, r, T), r = xe(S, "yOffset", y ? m : S.yOffset, S.yOffset, r, T)), E = "0px 0px"), (E || Ne && u && S.zOrigin) && (Re ? (p = !0, v = Fe, E = (E || $(e, v, A, !1, "50% 50%")) + "", (r = new _e(_, v, 0, 0, r, -1, T)).b = _[v], r.plugin = a, r.xs0 = r.e = Ne ? (c = S.zOrigin, E = E.split(" "), S.zOrigin = (2 < E.length && (0 === c || "0px" !== E[2]) ? parseFloat(E[2]) : c) || 0, r.xs0 = r.e = E[0] + " " + (E[1] || "50%") + " 0px", (r = new _e(S, "zOrigin", 0, 0, r, -1, r.n)).b = c, S.zOrigin) : E) : se(E + "", S)), p && (n._transformType = S.svg && Ae || !u && 3 !== this._transformType ? 2 : 3), s && (o[i] = s), l && (o.scale = l), r
            }, prefix: !0
        }), Se("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset"
        }), Se("borderRadius", {
            defaultValue: "0px", parser: function (e, t, i, n, r, a) {
                t = this.format(t);
                var o, s, l, h, c, u, p, d, f, m, g, v, y, _, x, b,
                    w = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    T = e.style;
                for (f = parseFloat(e.offsetWidth), m = parseFloat(e.offsetHeight), o = t.split(" "), s = 0; s < w.length; s++) this.p.indexOf("border") && (w[s] = J(w[s])), -1 !== (c = h = $(e, w[s], A, !1, "0px")).indexOf(" ") && (c = (h = c.split(" "))[0], h = h[1]), u = l = o[s], p = parseFloat(c), v = c.substr((p + "").length), "" === (g = (y = "=" === u.charAt(1)) ? (d = parseInt(u.charAt(0) + "1", 10), u = u.substr(2), d *= parseFloat(u), u.substr((d + "").length - (d < 0 ? 1 : 0)) || "") : (d = parseFloat(u), u.substr((d + "").length))) && (g = S[i] || v), g !== v && (_ = ee(e, "borderLeft", p, v), x = ee(e, "borderTop", p, v), h = "%" === g ? (c = _ / f * 100 + "%", x / m * 100 + "%") : "em" === g ? (c = _ / (b = ee(e, "borderLeft", 1, "em")) + "em", x / b + "em") : (c = _ + "px", x + "px"), y && (u = parseFloat(c) + d + g, l = parseFloat(h) + d + g)), r = be(T, w[s], c + " " + h, u + " " + l, !1, "0px", r);
                return r
            }, prefix: !0, formatter: ge("0px 0px 0px 0px", !1, !0)
        }), Se("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
            defaultValue: "0px", parser: function (e, t, i, n, r, a) {
                return be(e.style, i, this.format($(e, i, A, !1, "0px 0px")), this.format(t), !1, "0px", r)
            }, prefix: !0, formatter: ge("0px 0px", !1, !0)
        }), Se("backgroundPosition", {
            defaultValue: "0 0", parser: function (e, t, i, n, r, a) {
                var o, s, l, h, c, u, p = "background-position", d = A || K(e, null),
                    f = this.format((d ? E ? d.getPropertyValue(p + "-x") + " " + d.getPropertyValue(p + "-y") : d.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                    m = this.format(t);
                if (-1 !== f.indexOf("%") != (-1 !== m.indexOf("%")) && m.split(",").length < 2 && (u = $(e, "backgroundImage").replace(T, "")) && "none" !== u) {
                    for (o = f.split(" "), s = m.split(" "), V.setAttribute("src", u), l = 2; -1 < --l;) (h = -1 !== (f = o[l]).indexOf("%")) !== (-1 !== s[l].indexOf("%")) && (c = 0 === l ? e.offsetWidth - V.width : e.offsetHeight - V.height, o[l] = h ? parseFloat(f) / 100 * c + "px" : parseFloat(f) / c * 100 + "%");
                    f = o.join(" ")
                }
                return this.parseComplex(e.style, f, m, r, a)
            }, formatter: se
        }), Se("backgroundSize", {
            defaultValue: "0 0", formatter: function (e) {
                return "co" === (e += "").substr(0, 2) ? e : se(-1 === e.indexOf(" ") ? e + " " + e : e)
            }
        }), Se("perspective", {defaultValue: "0px", prefix: !0}), Se("perspectiveOrigin", {
            defaultValue: "50% 50%", prefix: !0
        }), Se("transformStyle", {prefix: !0}), Se("backfaceVisibility", {prefix: !0}), Se("userSelect", {prefix: !0}), Se("margin", {parser: ve("marginTop,marginRight,marginBottom,marginLeft")}), Se("padding", {parser: ve("paddingTop,paddingRight,paddingBottom,paddingLeft")}), Se("clip", {
            defaultValue: "rect(0px,0px,0px,0px)", parser: function (e, t, i, n, r, a) {
                var o, s, l;
                return t = E < 9 ? (s = e.currentStyle, l = E < 8 ? " " : ",", o = "rect(" + s.clipTop + l + s.clipRight + l + s.clipBottom + l + s.clipLeft + ")", this.format(t).split(",").join(l)) : (o = this.format($(e, this.p, A, !1, this.dflt)), this.format(t)), this.parseComplex(e.style, o, t, r, a)
            }
        }), Se("textShadow", {
            defaultValue: "0px 0px 0px #999", color: !0, multi: !0
        }), Se("autoRound,strictUnits", {
            parser: function (e, t, i, n, r) {
                return r
            }
        }), Se("border", {
            defaultValue: "0px solid #000", parser: function (e, t, i, n, r, a) {
                var o = $(e, "borderTopWidth", A, !1, "0px"), s = this.format(t).split(" "), l = s[0].replace(R, "");
                return "px" !== l && (o = parseFloat(o) / ee(e, "borderTopWidth", 1, l) + l), this.parseComplex(e.style, this.format(o + " " + $(e, "borderTopStyle", A, !1, "solid") + " " + $(e, "borderTopColor", A, !1, "#000")), s.join(" "), r, a)
            }, color: !0, formatter: function (e) {
                var t = e.split(" ");
                return t[0] + " " + (t[1] || "solid") + " " + (e.match(me) || ["#000"])[0]
            }
        }), Se("borderWidth", {parser: ve("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}), Se("float,cssFloat,styleFloat", {
            parser: function (e, t, i, n, r, a) {
                var o = e.style, s = "cssFloat" in o ? "cssFloat" : "styleFloat";
                return new _e(o, s, 0, 0, r, -1, i, !1, 0, o[s], t)
            }
        });
        var Qe = function (e) {
            var t, i = this.t, n = i.filter || $(this.data, "filter") || "", r = this.s + this.c * e | 0;
            100 === r && (t = -1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), !$(this.data, "filter")) : (i.filter = n.replace(a, ""), !0)), t || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(O, "opacity=" + r))
        };
        Se("opacity,alpha,autoAlpha", {
            defaultValue: "1", parser: function (e, t, i, n, r, a) {
                var o = parseFloat($(e, "opacity", A, !1, "1")), s = e.style, l = "autoAlpha" === i;
                return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + o), l && 1 === o && "hidden" === $(e, "visibility", A) && 0 !== t && (o = 0), W ? r = new _e(s, "opacity", o, t - o, r) : ((r = new _e(s, "opacity", 100 * o, 100 * (t - o), r)).xn1 = l ? 1 : 0, s.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = e, r.plugin = a, r.setRatio = Qe), l && ((r = new _e(s, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(r.n), n._overwriteProps.push(i)), r
            }
        });
        var Ze = function (e, t) {
            t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(o, "-$1").toLowerCase())) : e.removeAttribute(t))
        }, Je = function (e) {
            if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                this.t.setAttribute("class", 0 === e ? this.b : this.e);
                for (var t = this.data, i = this.t.style; t;) t.v ? i[t.p] = t.v : Ze(i, t.p), t = t._next;
                1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
        };
        Se("className", {
            parser: function (e, t, i, n, r, a, o) {
                var s, l, h, c, u, p = e.getAttribute("class") || "", d = e.style.cssText;
                if ((r = n._classNamePT = new _e(e, i, 0, 0, r, 2)).setRatio = Je, r.pr = -11, f = !0, r.b = p, l = ie(e, A), h = e._gsClassPT) {
                    for (c = {}, u = h.data; u;) c[u.p] = 1, u = u._next;
                    h.setRatio(1)
                }
                return (e._gsClassPT = r).e = "=" !== t.charAt(1) ? t : p.replace(new RegExp("(?:\\s|^)" + t.substr(2) + "(?![\\w-])"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), e.setAttribute("class", r.e), s = ne(e, l, ie(e), o, c), e.setAttribute("class", p), r.data = s.firstMPT, e.style.cssText = d, r = r.xfirst = n.parse(e, s.difs, r, a)
            }
        });
        var Ke = function (e) {
            if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var t, i, n, r, a, o = this.t.style, s = g.transform.parse;
                if ("all" === this.e) r = !(o.cssText = ""); else for (n = (t = this.e.split(" ").join("").split(",")).length; -1 < --n;) i = t[n], g[i] && (g[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Fe : g[i].p), Ze(o, i);
                r && (Ze(o, Re), (a = this.t._gsTransform) && (a.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
            }
        };
        for (Se("clearProps", {
            parser: function (e, t, i, n, r) {
                return (r = new _e(e, i, 0, 0, r, 2)).setRatio = Ke, r.e = t, r.pr = -10, r.data = n._tween, f = !0, r
            }
        }), e = "bezier,throwProps,physicsProps,physics2D".split(","), we = e.length; we--;) Ee(e[we]);
        (e = B.prototype)._firstPT = e._lastParsedTransform = e._transform = null, e._onInitTween = function (e, t, i, n) {
            if (!e.nodeType) return !1;
            this._target = P = e, this._tween = i, this._vars = t, L = n, M = t.autoRound, f = !1, S = t.suffixMap || B.suffixMap, A = K(e, ""), m = this._overwriteProps;
            var r, a, o, s, l, h, c, u, p, d = e.style;
            if (v && "" === d.zIndex && ("auto" !== (r = $(e, "zIndex", A)) && "" !== r || this._addLazySet(d, "zIndex", 0)), "string" == typeof t && (s = d.cssText, r = ie(e, A), d.cssText = s + ";" + t, r = ne(e, r, ie(e)).difs, !W && b.test(t) && (r.opacity = parseFloat(RegExp.$1)), t = r, d.cssText = s), t.className ? this._firstPT = a = g.className.parse(e, t.className, "className", this, null, null, t) : this._firstPT = a = this.parse(e, t, null), this._transformType) {
                for (p = 3 === this._transformType, Re ? y && (v = !0, "" === d.zIndex && ("auto" !== (c = $(e, "zIndex", A)) && "" !== c || this._addLazySet(d, "zIndex", 0)), _ && this._addLazySet(d, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (p ? "visible" : "hidden"))) : d.zoom = 1, o = a; o && o._next;) o = o._next;
                u = new _e(e, "transform", 0, 0, null, 2), this._linkCSSP(u, null, o), u.setRatio = Re ? qe : Ye, u.data = this._transform || We(e, A, !0), u.tween = i, u.pr = -1, m.pop()
            }
            if (f) {
                for (; a;) {
                    for (h = a._next, o = s; o && o.pr > a.pr;) o = o._next;
                    (a._prev = o ? o._prev : l) ? a._prev._next = a : s = a, (a._next = o) ? o._prev = a : l = a, a = h
                }
                this._firstPT = s
            }
            return !0
        }, e.parse = function (e, t, i, n) {
            var r, a, o, s, l, h, c, u, p, d, f = e.style;
            for (r in t) {
                if ("function" == typeof (h = t[r]) && (h = h(L, P)), a = g[r]) i = a.parse(e, h, r, this, i, n, t); else {
                    if ("--" === r.substr(0, 2)) {
                        this._tween._propLookup[r] = this._addTween.call(this._tween, e.style, "setProperty", K(e).getPropertyValue(r) + "", h + "", r, !1, r);
                        continue
                    }
                    l = $(e, r, A) + "", p = "string" == typeof h, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || p && w.test(h) ? (p || (h = (3 < (h = de(h)).length ? "rgba(" : "rgb(") + h.join(",") + ")"), i = be(f, r, l, h, !0, "transparent", i, 0, n)) : p && k.test(h) ? i = be(f, r, l, h, !0, null, i, 0, n) : (c = (o = parseFloat(l)) || 0 === o ? l.substr((o + "").length) : "", "" !== l && "auto" !== l || (c = "width" === r || "height" === r ? (o = oe(e, r, A), "px") : "left" === r || "top" === r ? (o = te(e, r, A), "px") : (o = "opacity" !== r ? 0 : 1, "")), "" === (u = (d = p && "=" === h.charAt(1)) ? (s = parseInt(h.charAt(0) + "1", 10), h = h.substr(2), s *= parseFloat(h), h.replace(R, "")) : (s = parseFloat(h), p ? h.replace(R, "") : "")) && (u = r in S ? S[r] : c), h = s || 0 === s ? (d ? s + o : s) + u : t[r], c !== u && ("" === u && "lineHeight" !== r || (s || 0 === s) && o && (o = ee(e, r, o, c), "%" === u ? (o /= ee(e, r, 100, "%") / 100, !0 !== t.strictUnits && (l = o + "%")) : "em" === u || "rem" === u || "vw" === u || "vh" === u ? o /= ee(e, r, 1, u) : "px" !== u && (s = ee(e, r, s, u), u = "px"), d && (s || 0 === s) && (h = s + o + u))), d && (s += o), !o && 0 !== o || !s && 0 !== s ? void 0 !== f[r] && (h || h + "" != "NaN" && null != h) ? (i = new _e(f, r, s || o || 0, 0, i, -1, r, !1, 0, l, h)).xs0 = "none" !== h || "display" !== r && -1 === r.indexOf("Style") ? h : l : q("invalid " + r + " tween value: " + t[r]) : (i = new _e(f, r, o, s - o, i, 0, r, !1 !== M && ("px" === u || "zIndex" === r), 0, l, h)).xs0 = u)
                }
                n && i && !i.plugin && (i.plugin = n)
            }
            return i
        }, e.setRatio = function (e) {
            var t, i, n, r = this._firstPT;
            if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime) for (; r;) {
                if (t = r.c * e + r.s, r.r ? t = r.r(t) : t < 1e-6 && -1e-6 < t && (t = 0), r.type) if (1 === r.type) if (2 === (n = r.l)) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2; else if (3 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else {
                    for (i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                    r.t[r.p] = i
                } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(e); else r.t[r.p] = t + r.xs0;
                r = r._next
            } else for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(e), r = r._next; else for (; r;) {
                if (2 !== r.type) if (r.r && -1 !== r.type) if (t = r.r(r.s + r.c), r.type) {
                    if (1 === r.type) {
                        for (n = r.l, i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                        r.t[r.p] = i
                    }
                } else r.t[r.p] = t + r.xs0; else r.t[r.p] = r.e; else r.setRatio(e);
                r = r._next
            }
        }, e._enableTransforms = function (e) {
            this._transform = this._transform || We(this._target, A, !0), this._transformType = this._transform.svg && Ae || !e && 3 !== this._transformType ? 2 : 3
        };
        var $e = function (e) {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
        };
        e._addLazySet = function (e, t, i) {
            var n = this._firstPT = new _e(e, t, 0, 0, this._firstPT, 2);
            n.e = i, n.setRatio = $e, n.data = this
        }, e._linkCSSP = function (e, t, i, n) {
            return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, n = !0), i ? i._next = e : n || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = i), e
        }, e._mod = function (e) {
            for (var t = this._firstPT; t;) "function" == typeof e[t.p] && (t.r = e[t.p]), t = t._next
        }, e._kill = function (e) {
            var t, i, n, r = e;
            if (e.autoAlpha || e.alpha) {
                for (i in r = {}, e) r[i] = e[i];
                r.opacity = 1, r.autoAlpha && (r.visibility = 1)
            }
            for (e.className && (t = this._classNamePT) && ((n = t.xfirst) && n._prev ? this._linkCSSP(n._prev, t._next, n._prev._prev) : n === this._firstPT && (this._firstPT = t._next), t._next && this._linkCSSP(t._next, t._next._next, n._prev), this._classNamePT = null), t = this._firstPT; t;) t.plugin && t.plugin !== i && t.plugin._kill && (t.plugin._kill(e), i = t.plugin), t = t._next;
            return ks.prototype._kill.call(this, r)
        };
        var et = function (e, t, i) {
            var n, r, a, o;
            if (e.slice) for (r = e.length; -1 < --r;) et(e[r], t, i); else for (r = (n = e.childNodes).length; -1 < --r;) o = (a = n[r]).type, a.style && (t.push(ie(a)), i && i.push(a)), 1 !== o && 9 !== o && 11 !== o || !a.childNodes.length || et(a, t, i)
        };
        return B.cascadeTo = function (e, t, i) {
            var n, r, a, o, s = Ss.to(e, t, i), l = [s], h = [], c = [], u = [], p = Ss._internals.reservedProps;
            for (e = s._targets || s.target, et(e, h, u), s.render(t, !0, !0), et(e, c), s.render(0, !0, !0), s._enabled(!0), n = u.length; -1 < --n;) if ((r = ne(u[n], h[n], c[n])).firstMPT) {
                for (a in r = r.difs, i) p[a] && (r[a] = i[a]);
                for (a in o = {}, r) o[a] = h[n][a];
                l.push(Ss.fromTo(u[n], t, o, r))
            }
            return l
        }, ks.activate([B]), B
    }, !0);
    Es.CSSPlugin;
    var _w = (Ts.document || {}).documentElement, xw = Ts, bw = function (e, t) {
        var i = "x" === t ? "Width" : "Height", n = "scroll" + i, r = "client" + i,
            a = document.querySelector('#__nuxt');
        return e === xw || e === _w || e === a ? Math.max(_w[n], a[n]) - (xw["inner" + i] || _w[r] || a[r]) : e[n] - e["offset" + i]
    }, ww = function (e, t) {
        var i = "scroll" + ("x" === t ? "Left" : "Top");
        return e === xw && (null != e.pageXOffset ? i = "page" + t.toUpperCase() + "Offset" : e = null != _w[i] ? _w : document.querySelector('#__nuxt')), function () {
            return e[i]
        }
    }, Tw = function (e, t) {
        var i,
            n = (i = e, "string" == typeof i && (i = TweenLite.selector(i)), i.length && i !== xw && i[0] && i[0].style && !i.nodeType && (i = i[0]), i === xw || i.nodeType && i.style ? i : null).getBoundingClientRect(),
            r = document.querySelector('#__nuxt'), a = !t || t === xw || t === r, o = a ? {
                top: _w.clientTop - (window.pageYOffset || _w.scrollTop || r.scrollTop || 0),
                left: _w.clientLeft - (window.pageXOffset || _w.scrollLeft || r.scrollLeft || 0)
            } : t.getBoundingClientRect(), s = {x: n.left - o.left, y: n.top - o.top};
        return !a && t && (s.x += ww(t, "x")(), s.y += ww(t, "y")()), s
    }, Sw = function (e, t, i) {
        var n = typeof e;
        return isNaN(e) ? "number" === n || "string" === n && "=" === e.charAt(1) ? e : "max" === e ? bw(t, i) : Math.min(bw(t, i), Tw(e, t)[i]) : parseFloat(e)
    }, Ew = Ts._gsDefine.plugin({
        propName: "scrollTo", API: 2, global: !0, version: "1.9.1", init: function (e, t, i) {
            return this._wdw = e === xw, this._target = e, this._tween = i, "object" != typeof t ? "string" == typeof (t = {y: t}).y && "max" !== t.y && "=" !== t.y.charAt(1) && (t.x = t.y) : t.nodeType && (t = {
                y: t, x: t
            }), this.vars = t, this._autoKill = !1 !== t.autoKill, this.getX = ww(e, "x"), this.getY = ww(e, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != t.x ? (this._addTween(this, "x", this.x, Sw(t.x, e, "x") - (t.offsetX || 0), "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != t.y ? (this._addTween(this, "y", this.y, Sw(t.y, e, "y") - (t.offsetY || 0), "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0
        }, set: function (e) {
            this._super.setRatio.call(this, e);
            var t = this._wdw || !this.skipX ? this.getX() : this.xPrev,
                i = this._wdw || !this.skipY ? this.getY() : this.yPrev, n = i - this.yPrev, r = t - this.xPrev,
                a = Ew.autoKillThreshold;
            this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (a < r || r < -a) && t < bw(this._target, "x") && (this.skipX = !0), !this.skipY && (a < n || n < -a) && i < bw(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? xw.scrollTo(this.skipX ? t : this.x, this.skipY ? i : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y
        }
    }), Aw = Ew.prototype;
    Ew.max = bw, Ew.getOffset = Tw, Ew.buildGetter = ww, Ew.autoKillThreshold = 7, Aw._kill = function (e) {
        return e.scrollTo_x && (this.skipX = !0), e.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, e)
    };
    var Mw = Array.isArray || function (e) {
            return "[object Array]" == Object.prototype.toString.call(e)
        }, Pw = Bw, Lw = Fw, Cw = function (e) {
            return Nw(Fw(e))
        }, Iw = Nw, Rw = zw,
        Ow = new RegExp(["(\\\\.)", "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))"].join("|"), "g");

    function Fw(e) {
        for (var t, i, n = [], r = 0, a = 0, o = ""; null != (t = Ow.exec(e));) {
            var s = t[0], l = t[1], h = t.index;
            if (o += e.slice(a, h), a = h + s.length, l) o += l[1]; else {
                o && (n.push(o), o = "");
                var c = t[2], u = t[3], p = t[4], d = t[5], f = t[6], m = t[7], g = "+" === f || "*" === f,
                    v = "?" === f || "*" === f, y = c || "/", _ = p || d || (m ? ".*" : "[^" + y + "]+?");
                n.push({
                    name: u || r++,
                    prefix: c || "",
                    delimiter: y,
                    optional: v,
                    repeat: g,
                    pattern: (i = _, i.replace(/([=!:$\/()])/g, "\\$1"))
                })
            }
        }
        return a < e.length && (o += e.substr(a)), o && n.push(o), n
    }

    function Nw(l) {
        for (var h = new Array(l.length), e = 0; e < l.length; e++) "object" == typeof l[e] && (h[e] = new RegExp("^" + l[e].pattern + "$"));
        return function (e) {
            for (var t = "", i = e || {}, n = 0; n < l.length; n++) {
                var r = l[n];
                if ("string" != typeof r) {
                    var a, o = i[r.name];
                    if (null == o) {
                        if (r.optional) continue;
                        throw new TypeError('Expected "' + r.name + '" to be defined')
                    }
                    if (Mw(o)) {
                        if (!r.repeat) throw new TypeError('Expected "' + r.name + '" to not repeat, but received "' + o + '"');
                        if (0 === o.length) {
                            if (r.optional) continue;
                            throw new TypeError('Expected "' + r.name + '" to not be empty')
                        }
                        for (var s = 0; s < o.length; s++) {
                            if (a = encodeURIComponent(o[s]), !h[n].test(a)) throw new TypeError('Expected all "' + r.name + '" to match "' + r.pattern + '", but received "' + a + '"');
                            t += (0 === s ? r.prefix : r.delimiter) + a
                        }
                    } else {
                        if (a = encodeURIComponent(o), !h[n].test(a)) throw new TypeError('Expected "' + r.name + '" to match "' + r.pattern + '", but received "' + a + '"');
                        t += r.prefix + a
                    }
                } else t += r
            }
            return t
        }
    }

    function kw(e) {
        return e.replace(/([.+*?=^!:${}()[\]|\/])/g, "\\$1")
    }

    function Uw(e, t) {
        return e.keys = t, e
    }

    function Dw(e) {
        return e.sensitive ? "" : "i"
    }

    function zw(e, t) {
        for (var i = (t = t || {}).strict, n = !1 !== t.end, r = "", a = e[e.length - 1], o = "string" == typeof a && /\/$/.test(a), s = 0; s < e.length; s++) {
            var l = e[s];
            if ("string" == typeof l) r += kw(l); else {
                var h = kw(l.prefix), c = l.pattern;
                l.repeat && (c += "(?:" + h + c + ")*"), r += c = l.optional ? h ? "(?:" + h + "(" + c + "))?" : "(" + c + ")?" : h + "(" + c + ")"
            }
        }
        return i || (r = (o ? r.slice(0, -2) : r) + "(?:\\/(?=$))?"), r += n ? "$" : i && o ? "" : "(?=\\/|$)", new RegExp("^" + r, Dw(t))
    }

    function Bw(e, t, i) {
        return Mw(t = t || []) ? i || (i = {}) : (i = t, t = []), e instanceof RegExp ? function (e, t) {
            var i = e.source.match(/\((?!\?)/g);
            if (i) for (var n = 0; n < i.length; n++) t.push({
                name: n, prefix: null, delimiter: null, optional: !1, repeat: !1, pattern: null
            });
            return Uw(e, t)
        }(e, t) : Mw(e) ? function (e, t, i) {
            for (var n = [], r = 0; r < e.length; r++) n.push(Bw(e[r], t, i).source);
            return Uw(new RegExp("(?:" + n.join("|") + ")", Dw(i)), t)
        }(e, t, i) : function (e, t, i) {
            for (var n = Fw(e), r = zw(n, i), a = 0; a < n.length; a++) "string" != typeof n[a] && t.push(n[a]);
            return Uw(r, t)
        }(e, t, i)
    }

    Pw.parse = Lw, Pw.compile = Cw, Pw.tokensToFunction = Iw, Pw.tokensToRegExp = Rw;
    var Hw, Gw = "undefined" != typeof document, jw = "undefined" != typeof window, Vw = "undefined" != typeof history,
        Xw = "undefined" != typeof process, Ww = Gw && document.ontouchstart ? "touchstart" : "click",
        Yw = jw && !(!window.history.location && !window.location);

    function qw() {
        this.callbacks = [], this.exits = [], this.current = "", this.len = 0, this._decodeURLComponents = !0, this._base = "", this._strict = !1, this._running = !1, this._hashbang = !1, this.clickHandler = this.clickHandler.bind(this), this._onpopstate = this._onpopstate.bind(this)
    }

    function Qw(e, t) {
        if ("function" == typeof e) return Qw.call(this, "*", e);
        if ("function" == typeof t) for (var i = new Jw(e, null, this), n = 1; n < arguments.length; ++n) this.callbacks.push(i.middleware(arguments[n])); else "string" == typeof e ? this["string" == typeof t ? "redirect" : "show"](e, t) : this.start(e)
    }

    function Zw(e, t, i) {
        var n = this.page = i || Qw, r = n._window, a = n._hashbang, o = n._getBase();
        "/" === e[0] && 0 !== e.indexOf(o) && (e = o + (a ? "#!" : "") + e);
        var s = e.indexOf("?");
        if (this.canonicalPath = e, this.path = e.replace(o, "") || "/", a && (this.path = this.path.replace("#!", "") || "/"), this.title = Gw && r.document.title, this.state = t || {}, this.state.path = e, this.querystring = ~s ? n._decodeURLEncodedURIComponent(e.slice(s + 1)) : "", this.pathname = n._decodeURLEncodedURIComponent(~s ? e.slice(0, s) : e), this.params = {}, this.hash = "", !a) {
            if (!~this.path.indexOf("#")) return;
            var l = this.path.split("#");
            this.path = this.pathname = l[0], this.hash = n._decodeURLEncodedURIComponent(l[1]) || "", this.querystring = this.querystring.split("#")[0]
        }
    }

    function Jw(e, t, i) {
        this.page = i || Kw;
        var n = t || {};
        n.strict = n.strict || i._strict, this.path = "*" === e ? "(.*)" : e, this.method = "GET", this.regexp = Pw(this.path, this.keys = [], n)
    }

    qw.prototype.configure = function (e) {
        var t = e || {};
        this._window = t.window || jw && window, this._decodeURLComponents = !1 !== t.decodeURLComponents, this._popstate = !1 !== t.popstate && jw, this._click = !1 !== t.click && Gw, this._hashbang = !!t.hashbang;
        var i = this._window;
        this._popstate ? i.addEventListener("popstate", this._onpopstate, !1) : jw && i.removeEventListener("popstate", this._onpopstate, !1), this._click ? i.document.addEventListener(Ww, this.clickHandler, !1) : Gw && i.document.removeEventListener(Ww, this.clickHandler, !1), this._hashbang && jw && !Vw ? i.addEventListener("hashchange", this._onpopstate, !1) : jw && i.removeEventListener("hashchange", this._onpopstate, !1)
    }, qw.prototype.base = function (e) {
        if (0 === arguments.length) return this._base;
        this._base = e
    }, qw.prototype._getBase = function () {
        var e = this._base;
        if (e) return e;
        var t = jw && this._window && this._window.location;
        return jw && this._hashbang && t && "file:" === t.protocol && (e = t.pathname), e
    }, qw.prototype.strict = function (e) {
        if (0 === arguments.length) return this._strict;
        this._strict = e
    }, qw.prototype.start = function (e) {
        var t = e || {};
        if (this.configure(t), !1 !== t.dispatch) {
            var i;
            if (this._running = !0, Yw) {
                var n = this._window.location;
                i = this._hashbang && ~n.hash.indexOf("#!") ? n.hash.substr(2) + n.search : this._hashbang ? n.search + n.hash : n.pathname + n.search + n.hash
            }
            this.replace(i, null, !0, t.dispatch)
        }
    }, qw.prototype.stop = function () {
        if (this._running) {
            this.current = "", this.len = 0, this._running = !1;
            var e = this._window;
            this._click && e.document.removeEventListener(Ww, this.clickHandler, !1), jw && e.removeEventListener("popstate", this._onpopstate, !1), jw && e.removeEventListener("hashchange", this._onpopstate, !1)
        }
    }, qw.prototype.show = function (e, t, i, n) {
        var r = new Zw(e, t, this), a = this.prevContext;
        return this.prevContext = r, this.current = r.path, !1 !== i && this.dispatch(r, a), !1 !== r.handled && !1 !== n && r.pushState(), r
    }, qw.prototype.back = function (e, t) {
        var i = this;
        if (0 < this.len) {
            var n = this._window;
            Vw && n.history.back(), this.len--
        } else e ? setTimeout(function () {
            i.show(e, t)
        }) : setTimeout(function () {
            i.show(i._getBase(), t)
        })
    }, qw.prototype.redirect = function (e, t) {
        var i = this;
        "string" == typeof e && "string" == typeof t && Qw.call(this, e, function (e) {
            setTimeout(function () {
                i.replace(t)
            }, 0)
        }), "string" == typeof e && void 0 === t && setTimeout(function () {
            i.replace(e)
        }, 0)
    }, qw.prototype.replace = function (e, t, i, n) {
        var r = new Zw(e, t, this), a = this.prevContext;
        return this.prevContext = r, this.current = r.path, r.init = i, r.save(), !1 !== n && this.dispatch(r, a), r
    }, qw.prototype.dispatch = function (t, i) {
        var n = 0, r = 0, a = this;

        function o() {
            var e = a.callbacks[n++];
            if (t.path === a.current) return e ? void e(t, o) : function (e) {
                if (e.handled) return;
                var t, i = this._window;
                t = this._hashbang ? Yw && this._getBase() + i.location.hash.replace("#!", "") : Yw && i.location.pathname + i.location.search;
                if (t === e.canonicalPath) return;
                this.stop(), e.handled = !1, Yw && (i.location.href = e.canonicalPath)
            }.call(a, t);
            t.handled = !1
        }

        i ? function e() {
            var t = a.exits[r++];
            if (!t) return o();
            t(i, e)
        }() : o()
    }, qw.prototype.exit = function (e, t) {
        if ("function" == typeof e) return this.exit("*", e);
        for (var i = new Jw(e, null, this), n = 1; n < arguments.length; ++n) this.exits.push(i.middleware(arguments[n]))
    }, qw.prototype.clickHandler = function (e) {
        if (1 === this._which(e) && !(e.metaKey || e.ctrlKey || e.shiftKey || e.defaultPrevented)) {
            var t = e.target, i = e.path || (e.composedPath ? e.composedPath() : null);
            if (i) for (var n = 0; n < i.length; n++) if (i[n].nodeName && "A" === i[n].nodeName.toUpperCase() && i[n].href) {
                t = i[n];
                break
            }
            for (; t && "A" !== t.nodeName.toUpperCase();) t = t.parentNode;
            if (t && "A" === t.nodeName.toUpperCase()) {
                var r = "object" == typeof t.href && "SVGAnimatedString" === t.href.constructor.name;
                if (!t.hasAttribute("download") && "external" !== t.getAttribute("rel")) {
                    var a = t.getAttribute("href");
                    if ((this._hashbang || !this._samePath(t) || !t.hash && "#" !== a) && !(a && -1 < a.indexOf("mailto:")) && (r ? !t.target.baseVal : !t.target) && (r || this.sameOrigin(t.href))) {
                        var o = r ? t.href.baseVal : t.pathname + t.search + (t.hash || "");
                        o = "/" !== o[0] ? "/" + o : o, Xw && o.match(/^\/[a-zA-Z]:\//) && (o = o.replace(/^\/[a-zA-Z]:\//, "/"));
                        var s = o, l = this._getBase();
                        0 === o.indexOf(l) && (o = o.substr(l.length)), this._hashbang && (o = o.replace("#!", "")), (!l || s !== o || Yw && "file:" === this._window.location.protocol) && (e.preventDefault(), this.show(s))
                    }
                }
            }
        }
    }, qw.prototype._onpopstate = (Hw = !1, jw ? (Gw && "complete" === document.readyState ? Hw = !0 : window.addEventListener("load", function () {
        setTimeout(function () {
            Hw = !0
        }, 0)
    }), function (e) {
        if (Hw) if (e.state) {
            var t = e.state.path;
            this.replace(t, e.state)
        } else if (Yw) {
            var i = this._window.location;
            this.show(i.pathname + i.search + i.hash, void 0, void 0, !1)
        }
    }) : function () {
    }), qw.prototype._which = function (e) {
        return null == (e = e || jw && this._window.event).which ? e.button : e.which
    }, qw.prototype._toURL = function (e) {
        var t = this._window;
        if ("function" == typeof URL && Yw) return new URL(e, t.location.toString());
        if (Gw) {
            var i = t.document.createElement("a");
            return i.href = e, i
        }
    }, qw.prototype.sameOrigin = function (e) {
        if (!e || !Yw) return !1;
        var t = this._toURL(e), i = this._window.location;
        return i.protocol === t.protocol && i.hostname === t.hostname && i.port === t.port
    }, qw.prototype._samePath = function (e) {
        if (!Yw) return !1;
        var t = this._window.location;
        return e.pathname === t.pathname && e.search === t.search
    }, qw.prototype._decodeURLEncodedURIComponent = function (e) {
        return "string" != typeof e ? e : this._decodeURLComponents ? decodeURIComponent(e.replace(/\+/g, " ")) : e
    }, Zw.prototype.pushState = function () {
        var e = this.page, t = e._window, i = e._hashbang;
        e.len++, Vw && t.history.pushState(this.state, this.title, i && "/" !== this.path ? "#!" + this.path : this.canonicalPath)
    }, Zw.prototype.save = function () {
        var e = this.page;
        Vw && "file:" !== e._window.location.protocol && e._window.history.replaceState(this.state, this.title, e._hashbang && "/" !== this.path ? "#!" + this.path : this.canonicalPath)
    }, Jw.prototype.middleware = function (i) {
        var n = this;
        return function (e, t) {
            if (n.match(e.path, e.params)) return i(e, t);
            t()
        }
    }, Jw.prototype.match = function (e, t) {
        var i = this.keys, n = e.indexOf("?"), r = ~n ? e.slice(0, n) : e, a = this.regexp.exec(decodeURIComponent(r));
        if (!a) return !1;
        for (var o = 1, s = a.length; o < s; ++o) {
            var l = i[o - 1], h = this.page._decodeURLEncodedURIComponent(a[o]);
            void 0 === h && hasOwnProperty.call(t, l.name) || (t[l.name] = h)
        }
        return !0
    };
    var Kw = function e() {
        var t = new qw;

        function i() {
            return Qw.apply(t, arguments)
        }

        return i.callbacks = t.callbacks, i.exits = t.exits, i.base = t.base.bind(t), i.strict = t.strict.bind(t), i.start = t.start.bind(t), i.stop = t.stop.bind(t), i.show = t.show.bind(t), i.back = t.back.bind(t), i.redirect = t.redirect.bind(t), i.replace = t.replace.bind(t), i.dispatch = t.dispatch.bind(t), i.exit = t.exit.bind(t), i.configure = t.configure.bind(t), i.sameOrigin = t.sameOrigin.bind(t), i.clickHandler = t.clickHandler.bind(t), i.create = e, Object.defineProperty(i, "len", {
            get: function () {
                return t.len
            }, set: function (e) {
                t.len = e
            }
        }), Object.defineProperty(i, "current", {
            get: function () {
                return t.current
            }, set: function (e) {
                t.current = e
            }
        }), i.Context = Zw, i.Route = Jw, i
    }(), $w = Kw, eT = Kw;
    $w.default = eT;
    var tT, iT, nT, rT = function (e) {
        function t() {
            var e;
            return es(this, t), (e = ls(this, rs(t).call(this))).clickEvent = document.ontouchstart ? "touchstart" : "click", e.keepSearch = !0, document.addEventListener(e.clickEvent, e.onClick.bind(ss(ss(e)))), e
        }

        return ns(t, ps), is(t, [{
            key: "addRoute", value: function (t) {
                var i = this;
                $w(t.url, function (e) {
                    i.onRouteChange(t)
                })
            }
        }, {
            key: "start", value: function () {
                $w.start({dispatch: !1, click: !1})
            }
        }, {
            key: "onRouteChange", value: function (e) {
                this.emit("change", e)
            }
        }, {
            key: "gotoHref", value: function (e, t) {
                t !== window.location.pathname && $w.show(t)
            }
        }, {
            key: "isSameOrigin", value: function (e) {
                var t = location.protocol + "//" + location.hostname;
                return location.port && (t += ":" + location.port), e && 0 === e.indexOf(t)
            }
        }, {
            key: "onClick", value: function (e) {
                if (!(e.metaKey || e.ctrlKey || e.shiftKey || e.defaultPrevented)) {
                    var t = e.target, i = e.path || (e.composedPath ? e.composedPath() : null);
                    if (i) for (var n = 0; n < i.length; n++) if (i[n].nodeName && "A" === i[n].nodeName.toUpperCase() && i[n].href) {
                        t = i[n];
                        break
                    }
                    for (; t && "A" !== t.nodeName.toUpperCase();) t = t.parentNode;
                    t && "A" === t.nodeName.toUpperCase() && this.onLinkClick(e, t)
                }
            }
        }, {
            key: "onLinkClick", value: function (e) {
                var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : null;
                if (!e.defaultPrevented) {
                    var i = t || e.currentTarget;
                    if (!i.hasAttribute("download")) {
                        var n = i.getAttribute("href"), r = i.href;
                        n && n.length && (-1 < n.indexOf("mailto:") || this.isSameOrigin(r) && (i.target || (e.preventDefault(), this.keepSearch && window.location.search && (r += window.location.search), this.gotoHref(r, i.pathname))))
                    }
                }
            }
        }]), t
    }(), aT = !0;

    function oT(e) {
        var t = e.id, i = e.url, n = e.element, r = e.color, a = tT.getScreen(t);
        if (!a) {
            var o = Qb[t] || Qb.default;
            a = new ds(o), tT.addScreen(t, a)
        }
        var s = {arguments: [{id: t, element: n, url: i, color: r, owner: tT}]};
        tT.showScreen(t, null, s)
    }

    function sT() {
        aT ? aT = !1 : (Hb.setSelectedItem(tT.currentItemId), Hb.hide())
    }

    function lT(e) {
        e.state === vl.OPEN ? Hb.hide() : Hb.show()
    }

    function hT(e) {
        yl.setState(e.isVisible ? vl.CLOSE : vl.OPEN), e.isVisible ? tT.currentScreen.lockScroll() : tT.currentScreen.unlockScroll()
    }

    function cT(e) {
        var t = tT && tT.currentScreen;
        if (app.windowWidth = window.innerWidth, app.windowHeight = window.innerHeight, app.isMobile) {
            var i = .01 * app.windowHeight;
            document.documentElement.style.setProperty("--vh", "".concat(i, "px"))
        }
        t && t.resize(e), Hb.resize(e)
    }

    function uT(e) {
        oT({url: e.url, color: e.color, id: e.name})
    }

    window.app = window.app || {}, app.screenXS = 480, app.screenS = 600, app.screenM = 900, app.screenL = 1280, app.screenXL = 1400, app.screenXXL = 1600, app.windowWidth = 0, app.windowHeight = 0, app.hasTouch = Modernizr.touchevents, app.urlQuery = window.location.search, app.browser = document.documentElement.getAttribute("data-browser"), app.skip = app.isDebug && window.location.search && -1 !== window.location.search.indexOf("skip"), (tT = new ws).transitionType = xs.OutAndIn, tT.on("transitionStart", sT), yl.on("click", lT), Hb.on("visibilityChange", hT), (iT = new rT).on("change", uT), app.routes.forEach(function (e) {
        iT.addRoute(e)
    }), iT.start(), app.analyticsId && Ll.init({id: app.analyticsId}), "scrollRestoration" in window.history && (window.history.scrollRestoration = "manual"), window.addEventListener("resize", cT), cT(), oT({
        id: (nT = document.querySelector(".page")).getAttribute("data-page"), element: nT
    })
}();
